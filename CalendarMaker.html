<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>·ª®ng d·ª•ng Th∆∞ k√Ω Cu·ªôc h·ªçp</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for Inter font */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Hide default file input */
        input[type="file"] {
            display: none;
        }
        /* Style for custom file input button */
        .custom-file-upload {
            border: 2px dashed #006B68; /* Use BIDV primary color */
            background-color: #E6F3E6; /* Lighter shade of primary for background */
            color: #006B68; /* Use BIDV primary color for text */
            padding: 1rem 1.5rem;
            border-radius: 0.5rem; /* rounded-lg */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            transition: all 0.2s ease-in-out;
        }
        .custom-file-upload:hover {
            border-color: #005A58; /* Darker shade for hover */
            background-color: #D0E6D0; /* Slightly darker shade for hover */
        }
        .custom-file-upload.has-file {
            border-color: #FFC62F; /* Use BIDV accent yellow for success */
            background-color: #FFFBEB; /* Lighter shade of accent yellow */
            color: #D97706; /* Darker yellow/orange for text (tailwind yellow-700 equivalent) */
        }
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #006B68; /* Use BIDV primary color for spinner */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Styles for the main buttons using direct hex codes */
        .btn-bidv-primary {
            background-color: #006B68;
            color: white;
            font-weight: 600;
            padding: 0.75rem 1.5rem; /* py-3 px-6 */
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); /* shadow-md */
            transition: background-color 300ms ease-in-out;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .btn-bidv-primary:hover:not(:disabled) {
            background-color: #005A58; /* Darker shade for hover */
        }
        .btn-bidv-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">
    <div class="bg-white p-8 rounded-xl shadow-lg w-full max-w-3xl space-y-6">
        <h1 class="text-3xl font-bold text-gray-800 text-center mb-6">T·∫°o L·ªãch H·ªçp t·ª´ T√†i li·ªáu</h1>

        <!-- File Upload Section -->
        <div class="border-b pb-6 mb-6">
            <label for="file-upload" class="custom-file-upload" id="file-upload-label">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" />
                </svg>
                <span id="file-upload-text">T·∫£i l√™n ho·∫∑c ch·ª•p ·∫£nh t√†i li·ªáu (JPG, PNG)</span>
                <div id="file-upload-spinner" class="loading-spinner hidden"></div>
            </label>
            <input id="file-upload" type="file" accept="image/jpeg,image/png" />
            <div id="image-preview-container" class="mt-4 hidden">
                <img id="image-preview" class="max-w-full h-auto rounded-lg shadow-md mx-auto" src="#" alt="Xem tr∆∞·ªõc ·∫£nh" />
            </div>
            <p id="file-error" class="text-red-500 text-sm mt-2 hidden">K√≠ch th∆∞·ªõc t·ªáp qu√° l·ªõn. Vui l√≤ng ch·ªçn t·ªáp d∆∞·ªõi 4MB.</p>
        </div>

        <!-- Process Button -->
        <div class="flex justify-center">
            <button id="process-button" class="btn-bidv-primary" disabled>
                <span id="button-text">Tr√≠ch xu·∫•t th√¥ng tin & T·∫°o l·ªãch</span>
                <div id="loading-spinner" class="loading-spinner hidden"></div>
            </button>
        </div>

        <!-- Extracted Information Display -->
        <div id="extracted-info-section" class="mt-8 border-t pt-6 hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Th√¥ng tin cu·ªôc h·ªçp ƒë√£ tr√≠ch xu·∫•t:</h2>
            <div id="extracted-info" class="bg-gray-50 p-4 rounded-lg border border-gray-200 text-gray-800 text-sm overflow-x-auto">
                <!-- Extracted JSON will be displayed here -->
            </div>
            <div class="flex justify-center mt-6">
                <a id="download-ics" class="btn-bidv-primary" style="display: none;">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3" />
                    </svg>
                    T·∫£i xu·ªëng t·ªáp ICS
                </a>
            </div>
        </div>

        <!-- Error Message Display -->
        <div id="error-message" class="mt-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg hidden">
            <p class="font-semibold">ƒê√£ x·∫£y ra l·ªói:</p>
            <p id="error-text"></p>
        </div>
    </div>

    <script type="module">
        // UI elements
        const fileUpload = document.getElementById('file-upload');
        const fileUploadLabel = document.getElementById('file-upload-label');
        const fileUploadText = document.getElementById('file-upload-text');
        const fileUploadSpinner = document.getElementById('file-upload-spinner'); // New spinner for file upload label
        const imagePreviewContainer = document.getElementById('image-preview-container');
        const imagePreview = document.getElementById('image-preview');
        const fileError = document.getElementById('file-error');
        const processButton = document.getElementById('process-button');
        const buttonText = document.getElementById('button-text');
        const loadingSpinner = document.getElementById('loading-spinner'); // Spinner for process button
        const extractedInfoSection = document.getElementById('extracted-info-section');
        const extractedInfoDiv = document.getElementById('extracted-info');
        const downloadIcsLink = document.getElementById('download-ics');
        const errorMessageDiv = document.getElementById('error-message');
        const errorTextP = document.getElementById('error-text');

        let uploadedImageBase64 = null; // Stores the Base64 representation of the uploaded image
        let mimeTypeForGemini = 'image/jpeg'; // Global variable to store the mime type for Gemini API

        /**
         * Compresses an image file to be under 4MB, optionally resizing it.
         * Converts PNG to JPEG if necessary for compression.
         * @param {File} file The image file to compress.
         * @returns {Promise<{base64: string, mimeType: string}>} A promise that resolves with the compressed base64 data and its mime type.
         */
        async function compressImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        let width = img.width;
                        let height = img.height;
                        const MAX_DIMENSION = 2000; // Max dimension for width/height to prevent excessively large canvases

                        // Resize if image is too large in dimensions
                        if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
                            if (width > height) {
                                height = Math.round(height * (MAX_DIMENSION / width));
                                width = MAX_DIMENSION;
                            } else {
                                width = Math.round(width * (MAX_DIMENSION / height));
                                height = MAX_DIMENSION;
                            }
                        }

                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);

                        let quality = 0.9; // Start with high quality for JPEG compression
                        let compressedDataUrl = '';
                        let compressedBase64 = '';
                        let outputMimeType = 'image/jpeg'; // Default output to JPEG for compression

                        // If original is PNG and it's large, we'll convert it to JPEG for compression.
                        // Otherwise, try to maintain original type if it's JPEG.
                        if (file.type === 'image/png' && file.size > 4 * 1024 * 1024) {
                            outputMimeType = 'image/jpeg';
                        } else if (file.type === 'image/jpeg') {
                            outputMimeType = 'image/jpeg';
                        } else {
                            // Fallback for other image types, though accept="image/jpeg,image/png" limits this
                            outputMimeType = 'image/jpeg';
                        }

                        const attemptCompression = () => {
                            compressedDataUrl = canvas.toDataURL(outputMimeType, quality);
                            compressedBase64 = compressedDataUrl.split(',')[1];
                            // Approximate size for base64: (length * 0.75) for typical base64 encoding
                            const sizeInBytes = (compressedBase64.length * 0.75);

                            // If size is within limit or quality is too low, resolve
                            if (sizeInBytes <= 4 * 1024 * 1024 || quality <= 0.1) {
                                resolve({ base64: compressedBase64, mimeType: outputMimeType });
                            } else {
                                quality -= 0.1; // Reduce quality
                                if (quality < 0.1) quality = 0.1; // Don't go below 0.1
                                setTimeout(attemptCompression, 0); // Continue compression asynchronously
                            }
                        };

                        attemptCompression();
                    };
                    img.onerror = (error) => reject(new Error("Kh√¥ng th·ªÉ t·∫£i ·∫£nh ƒë·ªÉ n√©n."));
                    img.src = event.target.result;
                };
                reader.onerror = (error) => reject(new Error("Kh√¥ng th·ªÉ ƒë·ªçc t·ªáp ·∫£nh."));
                reader.readAsDataURL(file);
            });
        }

        // Event listener for file input change
        fileUpload.addEventListener('change', async function(event) {
            const file = event.target.files[0];
            if (!file) {
                imagePreviewContainer.classList.add('hidden');
                processButton.disabled = true;
                fileUploadLabel.classList.remove('has-file');
                fileUploadText.textContent = 'T·∫£i l√™n ho·∫∑c ch·ª•p ·∫£nh t√†i li·ªáu (JPG, PNG)';
                uploadedImageBase64 = null;
                hideResults();
                hideError();
                return;
            }

            fileUploadLabel.classList.add('has-file');
            fileUploadText.textContent = `ƒêang x·ª≠ l√Ω: ${file.name}`;
            fileUploadSpinner.classList.remove('hidden'); // Show loading spinner on label
            processButton.disabled = true; // Disable button during processing
            hideResults();
            hideError();

            try {
                let finalBase64 = null;
                let finalMimeType = file.type; // Start with original mime type

                // If file is already small, just read it
                if (file.size <= 4 * 1024 * 1024) {
                    const reader = new FileReader();
                    await new Promise((resolve) => {
                        reader.onload = (e) => {
                            finalBase64 = e.target.result.split(',')[1];
                            resolve();
                        };
                        reader.readAsDataURL(file);
                    });
                } else {
                    // Attempt to compress if larger than 4MB
                    fileUploadText.textContent = `ƒêang n√©n ·∫£nh: ${file.name}`;
                    const compressedResult = await compressImage(file);
                    finalBase64 = compressedResult.base64;
                    finalMimeType = compressedResult.mimeType;

                    // Re-check size after compression
                    const compressedSizeInBytes = (finalBase64.length * 0.75);
                    if (compressedSizeInBytes > 4 * 1024 * 1024) {
                        throw new Error('K√≠ch th∆∞·ªõc t·ªáp sau khi n√©n v·∫´n qu√° l·ªõn (>4MB).');
                    }
                }

                imagePreview.src = `data:${finalMimeType};base64,${finalBase64}`;
                imagePreviewContainer.classList.remove('hidden');
                uploadedImageBase64 = finalBase64;
                mimeTypeForGemini = finalMimeType; // Update global mime type for Gemini
                processButton.disabled = false; // Enable button
                fileError.classList.add('hidden'); // Hide any previous file error
                fileUploadText.textContent = file.name; // Reset label text to original file name

            } catch (error) {
                console.error('L·ªói khi x·ª≠ l√Ω t·ªáp ·∫£nh:', error);
                fileError.textContent = `L·ªói: ${error.message || 'Kh√¥ng th·ªÉ x·ª≠ l√Ω t·ªáp ·∫£nh.'} Vui l√≤ng ch·ªçn t·ªáp kh√°c.`;
                fileError.classList.remove('hidden');
                imagePreviewContainer.classList.add('hidden');
                processButton.disabled = true;
                uploadedImageBase64 = null;
                fileUploadLabel.classList.remove('has-file');
                fileUploadText.textContent = 'T·∫£i l√™n ho·∫∑c ch·ª•p ·∫£nh t√†i li·ªáu (JPG, PNG)';
            } finally {
                fileUploadSpinner.classList.add('hidden'); // Hide loading spinner on label
            }
        });

        // Event listener for process button click
        processButton.addEventListener('click', async () => {
            if (!uploadedImageBase64) {
                showError('Vui l√≤ng t·∫£i l√™n m·ªôt t·ªáp ·∫£nh tr∆∞·ªõc.');
                return;
            }

            // Show loading state
            buttonText.textContent = 'ƒêang x·ª≠ l√Ω...';
            loadingSpinner.classList.remove('hidden');
            processButton.disabled = true;
            hideResults();
            hideError();

            try {
                const meetingData = await sendImageToGemini(uploadedImageBase64);
                displayMeetingInfo(meetingData);
                generateIcsFile(meetingData);
            } catch (error) {
                console.error('L·ªói khi x·ª≠ l√Ω t√†i li·ªáu:', error);
                // Display the specific error message from the AI if available
                showError(`L·ªói: ${error.message || 'Kh√¥ng th·ªÉ tr√≠ch xu·∫•t th√¥ng tin ho·∫∑c t·∫°o t·ªáp ICS. Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c ki·ªÉm tra ƒë·ªãnh d·∫°ng t√†i li·ªáu.'}`);
            } finally {
                // Reset button state
                buttonText.textContent = 'Tr√≠ch xu·∫•t th√¥ng tin & T·∫°o l·ªãch';
                loadingSpinner.classList.add('hidden');
                processButton.disabled = false;
            }
        });

        /**
         * Sends the image to Gemini API for information extraction.
         * @param {string} base64ImageData The Base64 encoded image data.
         * @returns {Promise<Object>} A promise that resolves with the extracted meeting data.
         */
        async function sendImageToGemini(base64ImageData) {
            const prompt = `B·∫°n l√† tr·ª£ l√Ω AI chuy√™n h·ªó tr·ª£ t·∫°o v√† qu·∫£n l√Ω l·ªãch h·ªçp, c√≥ kh·∫£ nƒÉng ƒë·ªçc hi·ªÉu t√†i li·ªáu v√† tr√≠ch xu·∫•t th√¥ng tin ch√≠nh x√°c ƒë·ªÉ x√¢y d·ª±ng l·ªãch h·ªçp chuy√™n nghi·ªáp.
            
            D·ª±a tr√™n t√†i li·ªáu h√¨nh ·∫£nh ƒë∆∞·ª£c cung c·∫•p, h√£y tr√≠ch xu·∫•t c√°c th√¥ng tin sau v√† tr·∫£ v·ªÅ d∆∞·ªõi d·∫°ng JSON. N·∫øu th√¥ng tin kh√¥ng c√≥, h√£y ƒë·ªÉ tr·ªëng ho·∫∑c s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh theo quy t·∫Øc.

            Quy t·∫Øc tr√≠ch xu·∫•t:
            - "Ch·ªß ƒë·ªÅ cu·ªôc h·ªçp": Ti√™u ƒë·ªÅ cu·ªôc h·ªçp. **B·∫Øt bu·ªôc k√®m theo s·ªë c√¥ng vƒÉn ho·∫∑c s·ªë th√¥ng b√°o (n·∫øu c√≥) v√†o cu·ªëi ti√™u ƒë·ªÅ, trong d·∫•u ngo·∫∑c ƒë∆°n (V√≠ d·ª•: "Ti√™u ƒë·ªÅ cu·ªôc h·ªçp (CV-2024/001)"). N·∫øu kh√¥ng c√≥ s·ªë, ch·ªâ ghi ti√™u ƒë·ªÅ.**
            - "ƒê·ªãa ƒëi·ªÉm h·ªçp": L·∫•y theo n·ªôi dung t√†i li·ªáu. N·∫øu kh√¥ng c√≥, ƒë√°nh d·∫•u l√† "Ch∆∞a r√µ ‚Äì c·∫ßn x√°c minh".
            - "Th·ªùi gian b·∫Øt ƒë·∫ßu": Th·ªùi gian b·∫Øt ƒë·∫ßu cu·ªôc h·ªçp (ƒë·ªãnh d·∫°ng YYYY-MM-DD HH:MM).
            - "Th·ªùi gian k·∫øt th√∫c": Th·ªùi gian k·∫øt th√∫c cu·ªôc h·ªçp (ƒë·ªãnh d·∫°ng YYYY-MM-DD HH:MM). N·∫øu kh√¥ng ƒë∆∞·ª£c n√™u r√µ, m·∫∑c ƒë·ªãnh = Th·ªùi gian b·∫Øt ƒë·∫ßu + 2 gi·ªù.
            - "Th√†nh ph·∫ßn tham d·ª±": Li·ªát k√™ c√°c ƒë∆°n v·ªã/c√° nh√¢n theo t√†i li·ªáu d∆∞·ªõi d·∫°ng m·∫£ng c√°c chu·ªói. **Ch·ªâ tr√≠ch xu·∫•t t√™n/ƒë∆°n v·ªã, kh√¥ng th√™m k√Ω hi·ªáu hay ƒë·ªãnh d·∫°ng ƒë·∫∑c bi·ªát.**
            - "N·ªôi dung l√†m vi·ªác ch√≠nh": T√≥m t·∫Øt ng·∫Øn g·ªçn, r√µ r√†ng n·ªôi dung l√†m vi·ªác ch√≠nh. **Ch·ªâ tr√≠ch xu·∫•t n·ªôi dung, kh√¥ng th√™m k√Ω hi·ªáu hay ƒë·ªãnh d·∫°ng ƒë·∫∑c bi·ªát nh∆∞ g·∫°ch ƒë·∫ßu d√≤ng. N·∫øu c√≥ nhi·ªÅu m·ª•c, m·ªói m·ª•c tr√™n m·ªôt d√≤ng m·ªõi.**
            - "ƒê∆°n v·ªã ch·ªß tr√¨ ho·∫∑c t·ªï ch·ª©c th·ª±c hi·ªán": ƒê∆°n v·ªã ch·ªß tr√¨ ho·∫∑c t·ªï ch·ª©c th·ª±c hi·ªán. **Ch·ªâ tr√≠ch xu·∫•t t√™n ƒë∆°n v·ªã, kh√¥ng th√™m k√Ω hi·ªáu hay ƒë·ªãnh d·∫°ng ƒë·∫∑c bi·ªát.**
            - "Ng∆∞·ªùi ch·ªß tr√¨ cu·ªôc h·ªçp": (T√πy ch·ªçn) Ng∆∞·ªùi ch·ªß tr√¨ cu·ªôc h·ªçp. **Ch·ªâ tr√≠ch xu·∫•t t√™n ng∆∞·ªùi, kh√¥ng th√™m k√Ω hi·ªáu hay ƒë·ªãnh d·∫°ng ƒë·∫∑c bi·ªát.**
            - "ƒê∆∞·ªùng d·∫´n h·ªçp tr·ª±c tuy·∫øn (Zoom/Teams/Meet)": (T√πy ch·ªçn) ƒê∆∞·ªùng d·∫´n h·ªçp tr·ª±c tuy·∫øn (Zoom/Teams/Meet).
            - "Y√™u c·∫ßu nh·∫Øc l·ªãch tr∆∞·ªõc": (T√πy ch·ªçn) Y√™u c·∫ßu nh·∫Øc l·ªãch tr∆∞·ªõc (v√≠ d·ª•: "1 NG√ÄY", "30 PH√öT"). N·∫øu kh√¥ng c√≥, m·∫∑c ƒë·ªãnh l√† "1 NG√ÄY".

            ƒê·∫£m b·∫£o r·∫±ng t·∫•t c·∫£ c√°c tr∆∞·ªùng ƒë∆∞·ª£c li·ªát k√™ trong schema ƒë·ªÅu c√≥ m·∫∑t trong JSON ƒë·∫ßu ra, ngay c·∫£ khi ch√∫ng tr·ªëng ho·∫∑c l√† gi√° tr·ªã m·∫∑c ƒë·ªãnh.
            `;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });

            const payload = {
                contents: [
                    {
                        role: "user",
                        parts: [
                            { text: prompt },
                            {
                                inlineData: {
                                    mimeType: mimeTypeForGemini, // Use the dynamically determined mime type
                                    data: base64ImageData
                                }
                            }
                        ]
                    }
                ],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "Ch·ªß ƒë·ªÅ cu·ªôc h·ªçp": { "type": "STRING" },
                            "ƒê·ªãa ƒëi·ªÉm h·ªçp": { "type": "STRING" },
                            "Th·ªùi gian b·∫Øt ƒë·∫ßu": { "type": "STRING" },
                            "Th·ªùi gian k·∫øt th√∫c": { "type": "STRING" },
                            "Th√†nh ph·∫ßn tham d·ª±": {
                                "type": "ARRAY",
                                "items": { "type": "STRING" }
                            },
                            "N·ªôi dung l√†m vi·ªác ch√≠nh": { "type": "STRING" },
                            "ƒê∆°n v·ªã ch·ªß tr√¨ ho·∫∑c t·ªï ch·ª©c th·ª±c hi·ªán": { "type": "STRING" },
                            "Ng∆∞·ªùi ch·ªß tr√¨ cu·ªôc h·ªçp": { "type": "STRING", "nullable": true },
                            "ƒê∆∞·ªùng d·∫´n h·ªçp tr·ª±c tuy·∫øn (Zoom/Teams/Meet)": { "type": "STRING", "nullable": true },
                            "Y√™u c·∫ßu nh·∫Øc l·ªãch tr∆∞·ªõc": { "type": "STRING", "nullable": true }
                        },
                        "required": [
                            "Ch·ªß ƒë·ªÅ cu·ªôc h·ªçp",
                            "ƒê·ªãa ƒëi·ªÉm h·ªçp",
                            "Th·ªùi gian b·∫Øt ƒë·∫ßu",
                            "Th·ªùi gian k·∫øt th√∫c",
                            "Th√†nh ph·∫ßn tham d·ª±",
                            "N·ªôi dung l√†m vi·ªác ch√≠nh",
                            "ƒê∆°n v·ªã ch·ªß tr√¨ ho·∫∑c t·ªï ch·ª©c th·ª±c hi·ªán"
                        ]
                    }
                }
            };

            const apiKey = "AIzaSyBaLi7TzZJ9SwmHilU24SRcV2i7lU6gqdQ"; // Canvas will automatically provide it in runtime
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API error: ${response.status} ${response.statusText} - ${errorData.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                const jsonString = result.candidates[0].content.parts[0].text;
                try {
                    const parsedJson = JSON.parse(jsonString);
                    return parsedJson;
                } catch (parseError) {
                    console.error("L·ªói ph√¢n t√≠ch JSON t·ª´ Gemini:", parseError);
                    console.error("Ph·∫£n h·ªìi th√¥ t·ª´ Gemini:", jsonString);
                    throw new Error("Ph·∫£n h·ªìi t·ª´ AI kh√¥ng ph·∫£i l√† JSON h·ª£p l·ªá.");
                }
            } else {
                throw new Error("Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi h·ª£p l·ªá t·ª´ Gemini.");
            }
        }

        /**
         * Displays the extracted meeting information in a readable format.
         * @param {Object} meetingData The extracted meeting data.
         */
        function displayMeetingInfo(meetingData) {
            extractedInfoDiv.innerHTML = `<pre class="whitespace-pre-wrap">${JSON.stringify(meetingData, null, 2)}</pre>`;
            extractedInfoSection.classList.remove('hidden');
        }

        /**
         * Generates an ICS file from the extracted meeting data and provides a download link.
         * @param {Object} meetingData The extracted meeting data.
         */
        function generateIcsFile(meetingData) {
            const subjectRaw = meetingData["Ch·ªß ƒë·ªÅ cu·ªôc h·ªçp"] || "Cu·ªôc h·ªçp";
            const location = meetingData["ƒê·ªãa ƒëi·ªÉm h·ªçp"] || "Ch∆∞a r√µ ‚Äì c·∫ßn x√°c minh";
            const attendees = meetingData["Th√†nh ph·∫ßn tham d·ª±"] || [];
            const mainContent = meetingData["N·ªôi dung l√†m vi·ªác ch√≠nh"] || ""; // Raw content
            const organizer = meetingData["ƒê∆°n v·ªã ch·ªß tr√¨ ho·∫∑c t·ªï ch·ª©c th·ª±c hi·ªán"] || "";
            const chair = meetingData["Ng∆∞·ªùi ch·ªß tr√¨ cu·ªôc h·ªçp"] || "";
            const onlineLink = meetingData["ƒê∆∞·ªùng d·∫´n h·ªçp tr·ª±c tuy·∫øn (Zoom/Teams/Meet)"] || "";
            const reminder = meetingData["Y√™u c·∫ßu nh·∫Øc l·ªãch tr∆∞·ªõc"] || "1 NG√ÄY";

            let startTime = null;
            let endTime = null;

            try {
                startTime = new Date(meetingData["Th·ªùi gian b·∫Øt ƒë·∫ßu"]);
                if (isNaN(startTime.getTime())) {
                    throw new Error("Th·ªùi gian b·∫Øt ƒë·∫ßu kh√¥ng h·ª£p l·ªá.");
                }

                if (meetingData["Th·ªùi gian k·∫øt th√∫c"]) {
                    endTime = new Date(meetingData["Th·ªùi gian k·∫øt th√∫c"]);
                    if (isNaN(endTime.getTime())) {
                        throw new Error("Th·ªùi gian k·∫øt th√∫c kh√¥ng h·ª£p l·ªá.");
                    }
                } else {
                    endTime = new Date(startTime.getTime() + 2 * 60 * 60 * 1000);
                }
            } catch (e) {
                showError(`L·ªói ƒë·ªãnh d·∫°ng th·ªùi gian: ${e.message}. Vui l√≤ng ƒë·∫£m b·∫£o "Th·ªùi gian b·∫Øt ƒë·∫ßu" v√† "Th·ªùi gian k·∫øt th√∫c" ƒë√∫ng ƒë·ªãnh d·∫°ng YYYY-MM-DD HH:MM.`);
                extractedInfoSection.classList.add('hidden');
                return;
            }

            const formatIcsDateTime = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                const seconds = String(date.getSeconds()).padStart(2, '0');
                return `${year}${month}${day}T${hours}${minutes}${seconds}`;
            };

            const dtStartIcs = formatIcsDateTime(startTime);
            const dtEndIcs = formatIcsDateTime(endTime);
            const dtStampIcs = formatIcsDateTime(new Date());
            const uid = `${dtStampIcs}-${Math.random().toString(36).substring(2, 15)}@${window.location.hostname || 'meeting-secretary-app'}`;

            const icsSummary = subjectRaw;

            // Construct description as per user's example
            let descriptionParts = [];

            // Main Content
            if (mainContent) {
                descriptionParts.push('üìå N·ªôi dung l√†m vi·ªác:');
                // Split by newline and add bullet points, then join with escaped newlines
                descriptionParts.push(mainContent.split('\n').map(line => `- ${line.trim()}`).join('\\n'));
            } else {
                descriptionParts.push('üìå N·ªôi dung l√†m vi·ªác:\\n- Kh√¥ng c√≥ n·ªôi dung ch√≠nh.');
            }

            // Chair
            descriptionParts.push(`\\nüë§ Ch·ªß tr√¨: ${chair || 'Ch∆∞a r√µ'}`);

            // Attendees
            descriptionParts.push(`\\nüë• Th√†nh ph·∫ßn:`);
            if (attendees.length > 0) {
                descriptionParts.push(attendees.map(att => `- ${att.trim()}`).join('\\n'));
            } else {
                descriptionParts.push(`- Kh√¥ng c√≥ th√†nh ph·∫ßn tham d·ª± c·ª• th·ªÉ.`);
            }

            // Organizer
            descriptionParts.push(`\\nüè¢ ƒê∆°n v·ªã t·ªï ch·ª©c: ${organizer || 'Ch∆∞a r√µ'}`);

            // Optional fields
            if (onlineLink) {
                descriptionParts.push(`\\nƒê∆∞·ªùng d·∫´n tr·ª±c tuy·∫øn: ${onlineLink}`);
            }
            
            descriptionParts.push(`\\nƒê·ªãa ƒëi·ªÉm: ${location}`);
            descriptionParts.push(`Th·ªùi gian: T·ª´ ${meetingData["Th·ªùi gian b·∫Øt ƒë·∫ßu"]} ƒë·∫øn ${meetingData["Th·ªùi gian k·∫øt th√∫c"]}`);

            const icsDescription = descriptionParts.join('\\n'); // Join all parts with escaped newlines

            // Handle reminder (ALARM) logic remains the same
            let alarmTrigger = '';
            const reminderMatch = reminder.match(/(\d+)\s*(NG√ÄY|GI·ªú|PH√öT)/i);
            if (reminderMatch) {
                const reminderValue = parseInt(reminderMatch[1]);
                const reminderUnit = reminderMatch[2].toUpperCase();

                switch (reminderUnit) {
                    case 'NG√ÄY':
                        alarmTrigger = `-P${reminderValue}D`;
                        break;
                    case 'GI·ªú':
                        alarmTrigger = `-PT${reminderValue}H`;
                        break;
                    case 'PH√öT':
                        alarmTrigger = `-PT${reminderValue}M`;
                        break;
                    default:
                        alarmTrigger = `-P1D`;
                }
            } else {
                alarmTrigger = `-P1D`;
            }

            const icsContent = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Meeting Secretary App//NONSGML v1.0//EN
CALSCALE:GREGORIAN
BEGIN:VTIMEZONE
TZID:Asia/Ho_Chi_Minh
X-LIC-LOCATION:Asia/Ho_Chi_Minh
BEGIN:STANDARD
TZOFFSETFROM:+0700
TZOFFSETTO:+0700
TZNAME:ICT
DTSTART:19700101T000000
END:STANDARD
END:VTIMEZONE
BEGIN:VEVENT
UID:${uid}
DTSTAMP:${dtStampIcs}
DTSTART;TZID=Asia/Ho_Chi_Minh:${dtStartIcs}
DTEND;TZID=Asia/Ho_Chi_Minh:${dtEndIcs}
SUMMARY:${icsSummary}
LOCATION:${location}
DESCRIPTION:${icsDescription}
${organizer ? `ORGANIZER;CN=${organizer}:MAILTO:noreply@example.com` : ''}
${attendees.map(att => `ATTENDEE;CN=${att}:MAILTO:noreply@example.com`).join('\n')}
BEGIN:VALARM
ACTION:DISPLAY
DESCRIPTION:Nh·∫Øc nh·ªü cu·ªôc h·ªçp: ${icsSummary}
TRIGGER:${alarmTrigger}
END:VALARM
END:VEVENT
END:VCALENDAR`;

            const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
            const url = URL.createObjectURL(blob);

            downloadIcsLink.href = url;
            downloadIcsLink.download = `${subjectRaw.replace(/[^a-z0-9]/gi, '_')}.ics`;
            downloadIcsLink.style.display = 'flex';
        }

        /**
         * Shows an error message.
         * @param {string} message The error message to display.
         */
        function showError(message) {
            errorTextP.textContent = message;
            errorMessageDiv.classList.remove('hidden');
        }

        /**
         * Hides the error message.
         */
        function hideError() {
            errorMessageDiv.classList.add('hidden');
            errorTextP.textContent = '';
        }

        /**
         * Hides the extracted info and download link.
         */
        function hideResults() {
            extractedInfoSection.classList.add('hidden');
            extractedInfoDiv.innerHTML = '';
            downloadIcsLink.style.display = 'none';
        }

        // Initial state setup
        hideResults();
        hideError();
    </script>
</body>
</html>

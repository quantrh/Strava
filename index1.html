<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>·ª®ng d·ª•ng Qu·∫£n l√Ω Th√†nh t√≠ch Ch·∫°y b·ªô - FOR RUNNER LOVER</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* Define BIDV brand colors */
        :root {
            --bidv-green: #006b68;
            --bidv-yellow: #FFC62F;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .btn-primary {
            background-color: var(--bidv-green);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn-primary:hover {
            background-color: #005a57; /* Darker green on hover */
        }

        .btn-secondary {
            background-color: var(--bidv-yellow);
            color: #333;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn-secondary:hover {
            background-color: #e6b32a; /* Darker yellow on hover */
        }

        .card {
            background-color: white;
            border-radius: 0.75rem;
            padding: 1.5rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
        }

        /* Styling for the bubble chart container */
        #bubble-chart-container {
            width: 100%;
            /* Height will be managed by JS for responsiveness */
            /* min-height: 400px; */ /* Optional: Set a minimum height */
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: hidden; /* Hide horizontal overflow */
            overflow-y: auto; /* Allow vertical scrolling */
        }

        .bubble {
            stroke: var(--bidv-green);
            stroke-width: 2px;
            fill-opacity: 0.7;
            cursor: pointer;
            transition: fill-opacity 0.3s ease;
        }

        .bubble:hover {
            fill-opacity: 1;
        }

        .bubble-text {
            font-size: 0.8rem;
            text-anchor: middle;
            fill: white;
            pointer-events: none; /* Allow clicks to pass through text to bubble */
        }

        .tooltip {
            position: absolute;
            text-align: center;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 0.5rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.9rem;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            .grid-cols-2 {
                grid-template-columns: 1fr;
            }
            /* #bubble-chart-container height can be adjusted here if a fixed min-height is desired */
        }

        /* Loading spinner for LLM analysis */
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid var(--bidv-green); /* BIDV Green */
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">
    <header class="bg-bidv-green p-4 shadow-md">
        <div class="container flex justify-between items-center">
            <div class="flex items-center space-x-4">
                <img src="https://placehold.co/50x50/006b68/FFC62F?text=BIDV" alt="Logo BIDV Running Club" class="h-12 w-auto rounded-md">
                <h1 class="text-2xl font-bold text-bidv-yellow">üèÉ‚Äç‚ôÇÔ∏è‚Äç‚û°Ô∏èRunning Lovers with AI‚ú®</h1>
            </div>
            <nav>
            </nav>
        </div>
    </header>

    <main class="flex-grow container py-8">
        <section id="auth-section" class="card mb-8 text-center">
            <h2 class="text-xl font-semibold mb-4">K·∫øt n·ªëi t√†i kho·∫£n Strava c·ªßa b·∫°n</h2>
            <p class="mb-6">ƒê·ªÉ theo d√µi th√†nh t√≠ch ch·∫°y b·ªô, vui l√≤ng k·∫øt n·ªëi v·ªõi t√†i kho·∫£n Strava c·ªßa b·∫°n.</p>
            <button id="connect-strava-btn" class="btn-primary">
                K·∫øt n·ªëi v·ªõi Strava
            </button>
            <div id="auth-status" class="mt-4 text-sm text-gray-600"></div>
        </section>

        <section id="data-section" class="card mb-8 hidden">
            <h2 class="text-xl font-semibold mb-4">D·ªØ li·ªáu th√†nh t√≠ch ch·∫°y b·ªô</h2>
            <p id="user-info" class="mb-4 text-lg font-medium"></p>
            <div class="mb-4">
                <label for="supabase-user-id" class="block text-gray-700 text-sm font-bold mb-2">Supabase User ID (UUID t·ª´ auth.users.id):</label>
                <input type="text" id="supabase-user-id" class="form-input" placeholder="D√°n UUID ng∆∞·ªùi d√πng Supabase c·ªßa b·∫°n v√†o ƒë√¢y" required>
                <p class="text-xs text-gray-500 mt-1">ƒê·ªÉ t√¨m ID n√†y, h√£y ƒëƒÉng nh·∫≠p v√†o Supabase, v√†o 'Authentication' -> 'Users', v√† sao ch√©p ID c·ªßa ng∆∞·ªùi d√πng b·∫°n mu·ªën li√™n k·∫øt.</p>
            </div>
            <div class="mb-4">
                <label for="activities-limit" class="block text-gray-700 text-sm font-bold mb-2">S·ªë l∆∞·ª£ng ho·∫°t ƒë·ªông mu·ªën t·∫£i (m·∫∑c ƒë·ªãnh 60):</label>
                <input type="number" id="activities-limit" class="form-input" value="60" min="1" step="1">
            </div>
            <div class="flex flex-wrap gap-4 mb-6">
                <button id="fetch-activities-btn" class="btn-primary">
                    T·∫£i/C·∫≠p nh·∫≠t d·ªØ li·ªáu t·ª´ Strava
                </button>
                <button id="view-stats-btn" class="btn-secondary">
                    Xem th·ªëng k√™
                </button>
                <button id="analyze-activities-btn" class="btn-primary">
                    ‚ú® Ph√¢n t√≠ch ho·∫°t ƒë·ªông
                </button>
                <button id="disconnect-strava-btn" class="btn-secondary">
                    Ng·∫Øt k·∫øt n·ªëi
                </button>
            </div>
            <div id="data-status" class="mt-4 text-sm text-gray-600"></div>

            <div id="activities-list" class="mt-6 border-t pt-4">
                <h3 class="text-lg font-semibold mb-3">C√°c ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y:</h3>
                <ul id="recent-activities" class="space-y-2 text-sm">
                    <!-- Recent activities will be listed here -->
                </ul>
            </div>

            <div id="llm-analysis-section" class="mt-6 border-t pt-4 hidden">
                <h3 class="text-lg font-semibold mb-3">Ph√¢n t√≠ch ho·∫°t ƒë·ªông c·ªßa b·∫°n:</h3>
                <div id="llm-analysis-content" class="bg-gray-100 p-4 rounded-md text-sm">
                    <p class="text-gray-500">Nh·∫•n "‚ú® Ph√¢n t√≠ch ho·∫°t ƒë·ªông" ƒë·ªÉ nh·∫≠n ph√¢n t√≠ch t·ª´ AI.</p>
                </div>
                <div id="llm-analysis-status" class="mt-2 text-sm text-gray-600"></div>
            </div>

        </section>

        <section id="stats-section" class="card hidden">
            <h2 class="text-xl font-semibold mb-4">Th·ªëng k√™ th√†nh t√≠ch theo tu·∫ßn</h2>
            <div id="bubble-chart-container">
                <!-- Bubble chart will be rendered here -->
            </div>
            <div id="chart-status" class="mt-4 text-sm text-gray-600"></div>
        </section>
    </main>

    <footer class="bg-bidv-green text-white p-4 text-center text-sm">
        <div class="container" style="color: var(--bidv-yellow);">
            &copy; 2025 Tr∆∞∆°ng H·ªìng Qu√¢n - BIDV Running Club. All rights reserved (Dev by AIs - Gemini, GPT).
        </div>
    </footer>

    <div id="custom-alert" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full text-center">
            <p id="alert-message" class="mb-4 text-lg"></p>
            <button id="alert-ok-btn" class="btn-primary">OK</button>
        </div>
    </div>

    <script>
        // Function to display custom alert instead of alert()
        function showAlert(message) {
            const customAlert = document.getElementById('custom-alert');
            const alertMessage = document.getElementById('alert-message');
            const alertOkBtn = document.getElementById('alert-ok-btn');

            alertMessage.textContent = message;
            customAlert.classList.remove('hidden');

            alertOkBtn.onclick = () => {
                customAlert.classList.add('hidden');
            };
        }

        // Your Strava and Supabase configuration
        // REPLACE THESE VALUES WITH YOUR ACTUAL INFORMATION
        const STRAVA_CLIENT_ID = '55949'; // Get from Strava API application
        const SUPABASE_URL = 'https://rmbsxccrwrktbjlnezpu.supabase.co'; // Your Supabase project URL
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJtYnN4Y2Nyd3JrdGJqbG5lenB1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg2MjczNjQsImV4cCI6MjA2NDIwMzM2NH0.ydCqificftdtn1niRciFCifeuo8aX6SDGti-hCY5Z_Y'; // Your public anon key for Supabase
        // URL of the Edge Function to handle OAuth callback
        const STRAVA_OAUTH_CALLBACK_URL = 'https://rmbsxccrwrktbjlnezpu.supabase.co/functions/v1/strava-oauth-callback';
        // URL of the Edge Function to fetch activity data
        const FETCH_ACTIVITIES_API_URL = 'https://rmbsxccrwrktbjlnezpu.supabase.co/functions/v1/fetch-strava-activities';
        // URL of the Edge Function to get statistics data
        const GET_STATS_API_URL = 'https://rmbsxccrwrktbjlnezpu.supabase.co/functions/v1/get-user-activities';


        // Global variables to store user status and activity data
        let currentUserId = null;
        let isAuthenticated = false;
        let userActivities = []; // New variable to store all loaded activities
        let weeklyStatsData = []; // Store weekly stats data globally

        // Initialize Supabase client instance
        let supabaseClientInstance;


        // Function to check login status and update UI
        async function checkAuthState() {
            // 1. Try to load from localStorage first
            const storedUserId = localStorage.getItem('strava_user_id');
            const storedAuthStatus = localStorage.getItem('strava_authenticated');

            if (storedUserId && storedAuthStatus === 'true') {
                currentUserId = storedUserId;
                isAuthenticated = true;
                console.log('Session restored from localStorage.');
                // Attempt to load activities from Supabase on UI update
                await loadStoredActivities(); 
            } else if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                // 2. If not in localStorage, check from __initial_auth_token (Canvas environment)
                const params = new URLSearchParams(window.location.search);
                const userIdFromUrl = params.get('userId');
                if (userIdFromUrl) {
                    currentUserId = userIdFromUrl;
                    isAuthenticated = true;
                    // If authenticated via URL, save to localStorage to maintain session
                    localStorage.setItem('strava_user_id', currentUserId);
                    localStorage.setItem('strava_authenticated', 'true');
                    console.log('Authentication successful via URL, session saved to localStorage.');
                    // Attempt to load activities from Supabase on UI update
                    await loadStoredActivities(); 
                }
            }
            updateUI();
        }

        // Function to update user interface based on authentication status
        function updateUI() {
            const authSection = document.getElementById('auth-section');
            const dataSection = document.getElementById('data-section');
            const statsSection = document.getElementById('stats-section');
            const userInfo = document.getElementById('user-info');
            const authStatus = document.getElementById('auth-status');
            const supabaseUserIdInput = document.getElementById('supabase-user-id'); // Get the input field

            if (isAuthenticated && currentUserId) {
                authSection.classList.add('hidden');
                dataSection.classList.remove('hidden');
                statsSection.classList.remove('hidden');
                userInfo.textContent = `Ch√†o m·ª´ng, Ng∆∞·ªùi d√πng ID: ${currentUserId}`;
                authStatus.textContent = 'ƒê√£ k·∫øt n·ªëi v·ªõi ·ª©ng d·ª•ng.';
                supabaseUserIdInput.value = currentUserId; // Prefill the Supabase User ID input
            } else {
                authSection.classList.remove('hidden');
                dataSection.classList.add('hidden');
                statsSection.classList.add('hidden');
                authStatus.textContent = 'Vui l√≤ng k·∫øt n·ªëi t√†i kho·∫£n Strava c·ªßa b·∫°n.';
                supabaseUserIdInput.value = ''; // Clear the Supabase User ID input
            }
        }

        // --- Handle OAuth 2.0 with Strava ---
        document.getElementById('connect-strava-btn').addEventListener('click', () => {
            const redirectUri = window.location.origin + '/Strava/';
            const scope = 'activity:read_all';
            const authUrl = `https://www.strava.com/oauth/authorize?client_id=${STRAVA_CLIENT_ID}&response_type=code&redirect_uri=${encodeURIComponent(redirectUri)}&approval_prompt=auto&scope=${scope}`;
            window.location.href = authUrl;
        });

        // Handle callback from Strava OAuth
        async function handleStravaCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const authStatus = document.getElementById('auth-status');

            if (code) {
                authStatus.textContent = 'ƒêang x·ª≠ l√Ω k·∫øt n·ªëi Strava...';
                try {
                    const response = await fetch(STRAVA_OAUTH_CALLBACK_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ code: code, redirect_uri: window.location.origin + '/Strava' }),
                    });

                    const result = await response.json();

                    if (response.ok && result.success) {
                        isAuthenticated = true;
                        currentUserId = result.userId;
                        // Save session information to localStorage upon successful authentication
                        localStorage.setItem('strava_user_id', currentUserId);
                        localStorage.setItem('strava_authenticated', 'true');
                        authStatus.textContent = 'K·∫øt n·ªëi Strava th√†nh c√¥ng!';
                        showAlert('K·∫øt n·ªëi Strava th√†nh c√¥ng!');
                        window.history.replaceState({}, document.title, window.location.pathname);
                        updateUI();
                        // Automatically fetch activities after successful login
                        await fetchActivities();
                    } else {
                        isAuthenticated = false; // Set to false on failure
                        currentUserId = null;
                        localStorage.removeItem('strava_user_id');
                        localStorage.removeItem('strava_authenticated');
                        authStatus.textContent = `L·ªói k·∫øt n·ªëi Strava: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`;
                        showAlert(`L·ªói k·∫øt n·ªëi Strava: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`);
                        updateUI();
                    }
                } catch (error) {
                    console.error('Error processing Strava callback:', error);
                    isAuthenticated = false; // Set to false on error
                    currentUserId = null;
                    localStorage.removeItem('strava_user_id');
                    localStorage.removeItem('strava_authenticated');
                    authStatus.textContent = 'Network or server error when processing Strava callback.';
                    showAlert('Network or server error when processing Strava callback.');
                    updateUI();
                }
            }
        }

        // --- Download and store running data ---
        document.getElementById('fetch-activities-btn').addEventListener('click', async () => {
            if (!isAuthenticated || !currentUserId) {
                showAlert('Vui l√≤ng k·∫øt n·ªëi t√†i kho·∫£n Strava tr∆∞·ªõc.');
                return;
            }

            const dataStatus = document.getElementById('data-status');
            dataStatus.textContent = 'ƒêang t·∫£i d·ªØ li·ªáu ho·∫°t ƒë·ªông t·ª´ Strava...';

            const activitiesLimit = parseInt(document.getElementById('activities-limit').value, 10) || 60;
            const supabaseUserId = document.getElementById('supabase-user-id').value.trim();

            if (!supabaseUserId) {
                showAlert('Vui l√≤ng nh·∫≠p Supabase User ID tr∆∞·ªõc khi t·∫£i ho·∫°t ƒë·ªông.');
                dataStatus.textContent = 'Thi·∫øu Supabase User ID.';
                return;
            }


            try {
                const response = await fetch(FETCH_ACTIVITIES_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    // Pass the Supabase user ID and activities limit to the Edge Function
                    body: JSON.stringify({ userId: currentUserId, supabaseUserId: supabaseUserId, limit: activitiesLimit }),
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    dataStatus.textContent = `ƒê√£ t·∫£i v√† l∆∞u ${result.count} ho·∫°t ƒë·ªông th√†nh c√¥ng!`;
                    showAlert(`ƒê√£ t·∫£i v√† l∆∞u ${result.count} ho·∫°t ƒë·ªông th√†nh c√¥ng!`);
                    userActivities = result.activities; // Save all activities
                    displayRecentActivities(userActivities); // Display newly loaded activities
                } else {
                    dataStatus.textContent = `L·ªói khi t·∫£i ho·∫°t ƒë·ªông: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`;
                    showAlert(`L·ªói khi t·∫£i ho·∫°t ƒë·ªông: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`);
                }
            } catch (error) {
                console.error('Error fetching activities:', error);
                dataStatus.textContent = 'Network or server error when fetching activities.';
                showAlert('Network or server error when fetching activities.');
            }
        });

        // Function to display recent activities
        function displayRecentActivities(activities) {
            const recentActivitiesList = document.getElementById('recent-activities');
            recentActivitiesList.innerHTML = ''; // Clear previous list

            if (activities && activities.length > 0) {
                // Sort activities by start_date in descending order (most recent first)
                const sortedActivities = activities.sort((a, b) => new Date(b.start_date) - new Date(a.start_date));

                // Display only the top 10 recent activities
                sortedActivities.slice(0, 10).forEach(activity => {
                    const li = document.createElement('li');
                    li.className = 'border-b last:border-b-0 py-2';
                    li.innerHTML = `
                        <p class="font-semibold">${activity.name}</p>
                        <p>Ng√†y: ${new Date(activity.start_date).toLocaleDateString('vi-VN')}</p>
                        <p>Qu√£ng ƒë∆∞·ªùng: ${(activity.distance / 1000).toFixed(2)} km</p>
                        <p>Th·ªùi gian: ${formatDuration(activity.moving_time)}</p>
                    `;
                    recentActivitiesList.appendChild(li);
                });
            } else {
                recentActivitiesList.innerHTML = '<li class="text-gray-500">Ch∆∞a c√≥ ho·∫°t ƒë·ªông n√†o ƒë∆∞·ª£c t·∫£i.</li>';
            }
        }


        // Function to format duration (seconds to HH:MM:SS)
        function formatDuration(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = seconds % 60;
            return [h, m, s].map(v => v < 10 ? "0" + v : v).filter((v, i) => v !== "00" || i > 0).join(":");
        }

        // --- Statistics and visualization of results ---
        document.getElementById('view-stats-btn').addEventListener('click', async () => {
            if (!isAuthenticated || !currentUserId) {
                showAlert('Vui l√≤ng k·∫øt n·ªëi t√†i kho·∫£n Strava tr∆∞·ªõc.');
                return;
            }

            const chartStatus = document.getElementById('chart-status');
            chartStatus.textContent = 'ƒêang t·∫£i d·ªØ li·ªáu th·ªëng k√™...';

            const supabaseUserId = document.getElementById('supabase-user-id').value.trim();
            if (!supabaseUserId) {
                showAlert('Vui l√≤ng nh·∫≠p Supabase User ID ƒë·ªÉ xem th·ªëng k√™.');
                chartStatus.textContent = 'Thi·∫øu Supabase User ID.';
                return;
            }

            try {
                const response = await fetch(GET_STATS_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ userId: supabaseUserId }), // Pass Supabase user ID
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    chartStatus.textContent = 'ƒê√£ t·∫£i d·ªØ li·ªáu th·ªëng k√™ th√†nh c√¥ng.';
                    weeklyStatsData = result.weeklyStats; // Store data globally
                    renderBubbleChart(weeklyStatsData); // Draw chart
                } else {
                    chartStatus.textContent = `L·ªói khi t·∫£i th·ªëng k√™: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`;
                    showAlert(`L·ªói khi t·∫£i th·ªëng k√™: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`);
                }
            } catch (error) {
                console.error('Error fetching statistics:', error);
                chartStatus.textContent = 'Network or server error when fetching statistics.';
                showAlert('Network or server error when fetching statistics.');
            }
        });

        // Helper function to convert ISO week string (YYYY-WW) to a Date object
        function getDateFromISOWeek(yearWeek) {
            const [yearStr, weekStr] = yearWeek.split('-W');
            const year = parseInt(yearStr);
            const week = parseInt(weekStr);

            // Get the first day of the year
            const jan1 = new Date(year, 0, 1);
            // Find the day of the week for Jan 1 (0 = Sunday, 1 = Monday, ..., 6 = Saturday)
            const dayOfWeekJan1 = jan1.getDay();
            // Calculate the offset to the first Thursday of the year (ISO week 1 always contains the first Thursday)
            // This ensures consistent week numbering as per ISO 8601
            const firstThursday = new Date(year, 0, 1 + (4 - dayOfWeekJan1 + 7) % 7);
            // Calculate the date for the desired week (mid-week to be safe, e.g., Thursday of that week)
            const date = new Date(firstThursday.getTime() + (week - 1) * 7 * 24 * 60 * 60 * 1000);
            return date;
        }

        // Function to draw the bubble chart
        function renderBubbleChart(data) {
            // data is weeklyStats: [{ week: 'YYYY-WW', totalDistance: ..., totalTime: ... }]

            // 1. Data Transformation: Group by month
            const monthlyDataMap = new Map();

            data.forEach(d => {
                const dateInWeek = getDateFromISOWeek(d.week);
                const monthKey = dateInWeek.getFullYear() + '-' + String(dateInWeek.getMonth() + 1).padStart(2, '0'); //YYYY-MM

                if (!monthlyDataMap.has(monthKey)) {
                    monthlyDataMap.set(monthKey, { month: monthKey, weeks: [] });
                }
                monthlyDataMap.get(monthKey).weeks.push(d);
            });

            // Convert map to array and sort months (newest first)
            const monthlyData = Array.from(monthlyDataMap.values()).sort((a, b) => b.month.localeCompare(a.month));

            // 2. SVG Setup
            const container = document.getElementById('bubble-chart-container');
            container.innerHTML = ''; // Clear previous chart

            if (!monthlyData || monthlyData.length === 0) {
                container.innerHTML = '<p class="text-gray-500">Kh√¥ng c√≥ d·ªØ li·ªáu th·ªëng k√™ ƒë·ªÉ hi·ªÉn th·ªã bi·ªÉu ƒë·ªì.</p>';
                return;
            }

            const width = container.clientWidth;
            // Dynamic height calculation based on number of months and screen size
            const monthBandHeight = width < 768 ? 120 : 180; // Increased height for better spacing
            const topPaddingForChart = width < 768 ? 70 : 100; // Increased initial padding

            const totalSvgContentHeight = (monthlyData.length * monthBandHeight) + topPaddingForChart;
            const svgHeight = Math.max(container.clientHeight, totalSvgContentHeight); // Ensure minimum height is met

            const svg = d3.select(container)
                .append("svg")
                .attr("width", width)
                .attr("height", svgHeight) // Set SVG height to accommodate all content
                .attr("viewBox", `0 0 ${width} ${svgHeight}`)
                .attr("preserveAspectRatio", "xMidYMid meet");

            // Define scales
            const maxDistance = d3.max(data, d => d.totalDistance);
            const minDistance = d3.min(data, d => d.totalDistance);

            // Dynamic radius scale based on container width
            const maxRadius = width < 768 ? 30 : 60; // Smaller max radius for small screens
            const minRadius = width < 768 ? 8 : 15; // Smaller min radius for small screens

            const radiusScale = d3.scaleSqrt()
                .domain([0, maxDistance])
                .range([minRadius, maxRadius]); // Min and max radius for bubbles

            // Color scale: larger distance -> darker color (using Viridis, reversed)
            const colorScale = d3.scaleSequential(d3.interpolateViridis)
                .domain([maxDistance, minDistance]); // Reversed domain for darker color on larger values

            // Layout parameters
            const bubbleHorizontalPadding = width < 768 ? 10 : 20; // Smaller padding for mobile
            const bubbleVerticalOffset = monthBandHeight / 2;


            let currentYOffset = topPaddingForChart; // Start Y offset with the added padding

            // Draw each month's band
            monthlyData.forEach((monthObj, monthIndex) => {
                const monthGroup = svg.append("g")
                    .attr("transform", `translate(0, ${currentYOffset})`);

                // Add month label
                monthGroup.append("text")
                    .attr("x", 20) // Left padding
                    .attr("y", 25) // Position label slightly below the top of the month band
                    .attr("font-size", width < 768 ? "1rem" : "1.2rem") // Smaller font size for mobile
                    .attr("font-weight", "bold")
                    .attr("fill", "#555")
                    .text(`Th√°ng ${monthObj.month.substring(5)}/${monthObj.month.substring(0, 4)}`);

                // Sort weeks within the month (oldest first for left-to-right flow)
                monthObj.weeks.sort((a, b) => a.week.localeCompare(b.week));

                let currentX = 20; // Start X for the first bubble in the month band

                // Calculate positions and radii for all bubbles in this month first
                const positionedWeeks = monthObj.weeks.map(d => {
                    const r = radiusScale(d.totalDistance);
                    const cx = currentX + r;
                    currentX += (r * 2) + bubbleHorizontalPadding;
                    return { ...d, r, cx, cy: bubbleVerticalOffset + (width < 768 ? 20 : 30) }; // Offset bubbles further below month label
                });

                // Draw circles
                monthGroup.selectAll(".bubble")
                    .data(positionedWeeks)
                    .enter().append("circle")
                    .attr("class", "bubble")
                    .attr("cx", d => d.cx)
                    .attr("cy", d => d.cy)
                    .attr("r", d => d.r)
                    .attr("fill", d => colorScale(d.totalDistance)) // Apply color based on distance
                    .attr("stroke", "#fff") // White stroke for contrast
                    .attr("stroke-width", 2)
                    .on("mouseover", function(event, d) {
                        d3.select(this).attr("stroke", "orange").attr("stroke-width", 3); // Highlight on hover
                        tooltip.style("opacity", 1)
                            .html(`Tu·∫ßn: ${d.week}<br>
                                   Qu√£ng ƒë∆∞·ªùng: ${(d.totalDistance / 1000).toFixed(2)} km<br>
                                   Th·ªùi gian: ${formatDuration(d.totalTime)}`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function(event, d) {
                        d3.select(this).attr("stroke", "#fff").attr("stroke-width", 2); // Revert stroke
                        tooltip.style("opacity", 0);
                    });

                // Add text labels to bubbles
                monthGroup.selectAll(".bubble-text")
                    .data(positionedWeeks)
                    .enter().append("text")
                    .attr("class", "bubble-text")
                    .attr("x", d => d.cx)
                    .attr("y", d => d.cy)
                    .text(d => d.r > (width < 768 ? 15 : 25) ? d.week.split('-W')[1] : '') // Show only week number if bubble is large enough (dynamic threshold)
                    .attr("dy", "0.35em")
                    .attr("fill", "white") // Text color
                    .attr("pointer-events", "none");

                currentYOffset += monthBandHeight; // Move to the next month's starting Y
            });

            // Tooltip setup (already exists, ensure it's appended to body)
            // Ensure only one tooltip exists
            let tooltip = d3.select("body").select(".tooltip");
            if (tooltip.empty()) {
                tooltip = d3.select("body").append("div")
                    .attr("class", "tooltip");
            }
        }


        // When the page loads
        window.onload = async () => {
            // Initialize Supabase client
            if (typeof window.supabase === 'undefined') {
                showAlert('L·ªói: Th∆∞ vi·ªán Supabase kh√¥ng ƒë∆∞·ª£c t·∫£i. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi internet ho·∫∑c URL CDN.');
                console.error('Th∆∞ vi·ªán Supabase kh√¥ng ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a. Vui l√≤ng ki·ªÉm tra th·∫ª script CDN Supabase.');
                return;
            }
            supabaseClientInstance = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);


            // Event Listeners
            document.getElementById('connect-strava-btn').addEventListener('click', () => {
                const redirectUri = window.location.origin + '/Strava/';
                const scope = 'activity:read_all';
                const authUrl = `https://www.strava.com/oauth/authorize?client_id=${STRAVA_CLIENT_ID}&response_type=code&redirect_uri=${encodeURIComponent(redirectUri)}&approval_prompt=auto&scope=${scope}`;
                window.location.href = authUrl;
            });

            document.getElementById('disconnect-strava-btn').addEventListener('click', () => {
                isAuthenticated = false;
                currentUserId = null;
                localStorage.removeItem('strava_user_id');
                localStorage.removeItem('strava_authenticated');
                userActivities = []; // Clear activities
                weeklyStatsData = []; // Clear stats data
                updateUI();
                showAlert('ƒê√£ ng·∫Øt k·∫øt n·ªëi v·ªõi Strava.');
            });

            document.getElementById('fetch-activities-btn').addEventListener('click', async () => {
                if (!isAuthenticated || !currentUserId) {
                    showAlert('Vui l√≤ng k·∫øt n·ªëi t√†i kho·∫£n Strava tr∆∞·ªõc.');
                    return;
                }

                const dataStatus = document.getElementById('data-status');
                dataStatus.textContent = 'ƒêang t·∫£i d·ªØ li·ªáu ho·∫°t ƒë·ªông t·ª´ Strava...';

                const activitiesLimit = parseInt(document.getElementById('activities-limit').value, 10) || 60;
                const supabaseUserId = document.getElementById('supabase-user-id').value.trim();

                if (!supabaseUserId) {
                    showAlert('Vui l√≤ng nh·∫≠p Supabase User ID tr∆∞·ªõc khi t·∫£i ho·∫°t ƒë·ªông.');
                    dataStatus.textContent = 'Thi·∫øu Supabase User ID.';
                    return;
                }


                try {
                    const response = await fetch(FETCH_ACTIVITIES_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ userId: currentUserId, supabaseUserId: supabaseUserId, limit: activitiesLimit }),
                    });

                    const result = await response.json();

                    if (response.ok && result.success) {
                        dataStatus.textContent = `ƒê√£ t·∫£i v√† l∆∞u ${result.count} ho·∫°t ƒë·ªông th√†nh c√¥ng!`;
                        showAlert(`ƒê√£ t·∫£i v√† l∆∞u ${result.count} ho·∫°t ƒë·ªông th√†nh c√¥ng!`);
                        // Ensure that activities from the server are formatted correctly for display
                        userActivities = result.activities.map(activity => ({
                            name: activity.name,
                            start_date: activity.start_date,
                            distance: activity.distance,
                            moving_time: activity.moving_time,
                            type: activity.type // Ensure type is present for filtering
                        }));
                        displayRecentActivities(userActivities);
                    } else {
                        dataStatus.textContent = `L·ªói khi t·∫£i ho·∫°t ƒë·ªông: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`;
                        showAlert(`L·ªói khi t·∫£i ho·∫°t ƒë·ªông: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`);
                    }
                } catch (error) {
                    console.error('Error fetching activities:', error);
                    dataStatus.textContent = 'Network or server error when fetching activities.';
                    showAlert('Network or server error when fetching activities.');
                }
            });

            document.getElementById('view-stats-btn').addEventListener('click', async () => {
                if (!isAuthenticated || !currentUserId) {
                    showAlert('Vui l√≤ng k·∫øt n·ªëi t√†i kho·∫£n Strava tr∆∞·ªõc.');
                    return;
                }

                const chartStatus = document.getElementById('chart-status');
                chartStatus.textContent = 'ƒêang t·∫£i d·ªØ li·ªáu th·ªëng k√™...';

                const supabaseUserId = document.getElementById('supabase-user-id').value.trim();
                if (!supabaseUserId) {
                    showAlert('Vui l√≤ng nh·∫≠p Supabase User ID ƒë·ªÉ xem th·ªëng k√™.');
                    chartStatus.textContent = 'Thi·∫øu Supabase User ID.';
                    return;
                }

                try {
                    const response = await fetch(GET_STATS_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ userId: supabaseUserId }), // Pass Supabase user ID
                    });

                    const result = await response.json();

                    if (response.ok && result.success) {
                        chartStatus.textContent = 'ƒê√£ t·∫£i d·ªØ li·ªáu th·ªëng k√™ th√†nh c√¥ng.';
                        weeklyStatsData = result.weeklyStats; // Store data globally
                        renderBubbleChart(weeklyStatsData); // Draw chart
                    } else {
                        chartStatus.textContent = `L·ªói khi t·∫£i th·ªëng k√™: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`;
                        showAlert(`L·ªói khi t·∫£i th·ªëng k√™: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`);
                    }
                } catch (error) {
                    console.error('Error fetching statistics:', error);
                    chartStatus.textContent = 'Network or server error when fetching statistics.';
                    showAlert('Network or server error when fetching statistics.');
                }
            });

            document.getElementById('analyze-activities-btn').addEventListener('click', async () => {
                if (!isAuthenticated || !currentUserId) {
                    showAlert('Vui l√≤ng k·∫øt n·ªëi t√†i kho·∫£n Strava tr∆∞·ªõc.');
                    return;
                }

                const llmAnalysisSection = document.getElementById('llm-analysis-section');
                const llmAnalysisContent = document.getElementById('llm-analysis-content');
                const llmAnalysisStatus = document.getElementById('llm-analysis-status');

                llmAnalysisSection.classList.remove('hidden'); // Show analysis section
                llmAnalysisContent.innerHTML = '<p class="text-gray-500">ƒêang ph√¢n t√≠ch ho·∫°t ƒë·ªông c·ªßa b·∫°n... <span class="loader"></span></p>';
                llmAnalysisStatus.textContent = '';

                // Ensure userActivities contains data
                if (userActivities.length === 0) {
                    llmAnalysisContent.innerHTML = '<p class="text-gray-500">Kh√¥ng c√≥ ho·∫°t ƒë·ªông n√†o ƒë·ªÉ ph√¢n t√≠ch. Vui l√≤ng t·∫£i d·ªØ li·ªáu t·ª´ Strava tr∆∞·ªõc.</p>';
                    return;
                }

                try {
                    // Prepare activity data to send to LLM
                    const activitiesForLLM = userActivities.map(activity => ({
                        name: activity.name,
                        distance_km: (activity.distance / 1000).toFixed(2),
                        moving_time_seconds: activity.moving_time,
                        start_date: new Date(activity.start_date).toISOString().split('T')[0] // Format date for LLM
                    }));

                    // Prompt for the LLM
                    const prompt = `Ph√¢n t√≠ch d·ªØ li·ªáu ho·∫°t ƒë·ªông ch·∫°y b·ªô sau ƒë√¢y v√† cung c·∫•p c√°i nh√¨n s√¢u s·∫Øc, xu h∆∞·ªõng, ho·∫∑c ƒë·ªÅ xu·∫•t c√° nh√¢n h√≥a.
                    D·ªØ li·ªáu ho·∫°t ƒë·ªông: ${JSON.stringify(activitiesForLLM)}`;

                    const payload = {
                        contents: [{ role: "user", parts: [{ text: prompt }] }],
                    };

                    llmAnalysisStatus.textContent = 'ƒêang g·ªçi AI ƒë·ªÉ ph√¢n t√≠ch...';

                    const apiKey = ""; // Canvas will automatically provide the API key
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const analysisText = result.candidates[0].content.parts[0].text;
                        llmAnalysisContent.innerHTML = markdownToHtml(analysisText); // Render Markdown to HTML
                        llmAnalysisStatus.textContent = 'Ph√¢n t√≠ch ho√†n t·∫•t!';
                    } else {
                        llmAnalysisContent.innerHTML = '<p class="text-red-500">Kh√¥ng th·ªÉ nh·∫≠n ƒë∆∞·ª£c ph√¢n t√≠ch t·ª´ AI.</p>';
                        llmAnalysisStatus.textContent = 'L·ªói ph√¢n t√≠ch AI.';
                    }
                } catch (error) {
                    console.error('Error during LLM analysis:', error);
                    llmAnalysisContent.innerHTML = '<p class="text-red-500">ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh ph√¢n t√≠ch AI.</p>';
                    llmAnalysisStatus.textContent = `L·ªói: ${error.message}`;
                }
            });

            // Initial check and UI update
            await handleStravaCallback(); // Process any OAuth callback first
            await checkAuthState(); // Then check the overall auth state and update UI
        };

        // Add resize event listener to redraw the chart
        window.addEventListener('resize', () => {
            if (weeklyStatsData && weeklyStatsData.length > 0) {
                renderBubbleChart(weeklyStatsData);
            }
        });

        // Function to convert basic Markdown to HTML
        function markdownToHtml(markdownText) {
            let htmlText = markdownText;
            // Convert **text** to <strong>text</strong>
            htmlText = htmlText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            // Convert *text* to <em>text</em>
            htmlText = htmlText.replace(/\*(.*?)\*/g, '<em>$1</em>');
            // Convert newlines to <br>
            htmlText = htmlText.replace(/\n/g, '<br>');
            return htmlText;
        }
    </script>
</body>
</html>

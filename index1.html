<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>·ª®ng d·ª•ng Qu·∫£n l√Ω Th√†nh t√≠ch Ch·∫°y b·ªô - FOR RUNNER LOVER</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- Th√™m th∆∞ vi·ªán Marked.js ƒë·ªÉ ph√¢n t√≠ch Markdown th√†nh HTML -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Th√™m Font Awesome ƒë·ªÉ s·ª≠ d·ª•ng icon -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Define BIDV brand colors */
        :root {
            --bidv-green: #006b68;
            --bidv-yellow: #FFC62F;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Adjust primary button to BIDV green */
        .btn-primary {
            background-color: var(--bidv-green);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn-primary:hover {
            background-color: #005a57; /* Darker green on hover */
        }

        /* Adjust secondary button to BIDV yellow */
        .btn-secondary {
            background-color: var(--bidv-yellow);
            color: #333;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn-secondary:hover {
            background-color: #e6b32a; /* Darker yellow on hover */
        }

        .btn-danger {
            @apply bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600 transition duration-300 ease-in-out shadow-md;
        }

        .form-input {
            @apply w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-orange-500;
        }
        
        /* Custom styles for multi-select */
        .multi-select-container {
            position: relative;
        }

        .multi-select-selected-items {
            @apply w-full p-2 border border-gray-300 rounded-md bg-white cursor-pointer flex flex-wrap gap-1;
            min-height: 42px; /* Ensure consistent height */
            align-items: center;
        }

        .multi-select-selected-item {
            @apply bg-gray-200 text-gray-700 text-xs px-2 py-1 rounded-full flex items-center gap-1;
        }

        .multi-select-selected-item span {
            cursor: pointer;
            font-weight: bold;
        }

        .multi-select-options {
            @apply absolute w-full border border-gray-300 rounded-md bg-white shadow-lg z-10;
            max-height: 200px;
            overflow-y: auto;
        }

        .multi-select-option {
            @apply p-2 cursor-pointer hover:bg-gray-100;
        }

        .multi-select-option.selected {
            @apply bg-blue-100 font-semibold;
        }

        .card {
            background-color: white;
            border-radius: 0.75rem;
            padding: 1.5rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none; /* Hidden by default */
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.75rem;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            position: relative;
            /* Th√™m c√°c thu·ªôc t√≠nh sau ƒë·ªÉ b·∫≠t thanh cu·ªôn */
            max-height: 90vh; /* Gi·ªõi h·∫°n chi·ªÅu cao t·ªëi ƒëa c·ªßa modal, v√≠ d·ª• 90% chi·ªÅu cao viewport */
            overflow-y: auto; /* B·∫≠t thanh cu·ªôn d·ªçc khi n·ªôi dung tr√†n */
            -webkit-overflow-scrolling: touch; /* C·∫£i thi·ªán cu·ªôn tr√™n thi·∫øt b·ªã di ƒë·ªông */
        }
        .close-button {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 1.5rem;
            cursor: pointer;
            color: #9ca3af;
        }

        /* Styling for the bubble chart container */
        #bubble-chart-container {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: hidden; /* Hide horizontal overflow */
            overflow-y: auto; /* Allow vertical scrolling */
            background-color: #f9fafb; /* Light background for chart */
            border-radius: 0.5rem;
            min-height: 300px;
        }

        .bubble {
           /* stroke: var(--bidv-green); 
            stroke-width: 2px; remove*/
            fill-opacity: 0.7;
            cursor: pointer;
            transition: fill-opacity 0.3s ease;
        }

        .bubble:hover {
            fill-opacity: 1;
        }

        .bubble-text {
            font-size: 0.8rem;
            text-anchor: middle;
            fill: white;
            pointer-events: none; /* Allow clicks to pass through text to bubble */
        }

        .tooltip {
            position: absolute;
            text-align: center;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 0.5rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.9rem;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            .flex-wrap > .btn-primary, .flex-wrap > .btn-secondary {
                flex-basis: 100%; /* Full width for buttons on small screens */
            }
        }

        /* Loading spinner for LLM analysis */
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid var(--bidv-green); /* BIDV Green */
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Collapsible Section Styles */
        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding-bottom: 1rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid #eee;
        }

        .collapsible-header h2 {
            margin-bottom: 0;
            display: flex; /* Enable flex for icon and text */
            align-items: center;
            gap: 0.75rem; /* Space between icon and text */
        }

        .collapsible-content {
            overflow-y: auto; /* Changed to auto to show scrollbar when content is too long */
            /* Transition will apply to max-height for divs, but for tbody we'll use display none/table-row-group */
            transition: max-height 0.3s ease-out; 
            max-height: 1000px; /* Large enough to show content for divs */
        }

        .collapsible-content.collapsed {
            max-height: 0; /* For div collapsibles */
            display: none; /* Force hide for tbody elements */
        }

        /* Adjust icon for collapsible sections */
        .collapsible-header .toggle-icon {
            transition: transform 0.3s ease-out;
        }

        /* Collapsed state (arrow right) */
        .collapsible-header .toggle-icon {
            transform: rotate(0deg); 
        }

        /* Expanded state (arrow down) */
        .collapsible-header .toggle-icon.rotate {
            transform: rotate(90deg); /* Rotate to point down for expanded */
        }

        /* Table styles */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }
        .data-table th, .data-table td {
            border: 1px solid #e2e8f0;
            padding: 0.75rem;
            text-align: left;
        }
        .data-table th {
            background-color: var(--bidv-green);
            color: white;
            font-weight: bold;
            font-size: 0.875rem;
            text-transform: uppercase;
        }
        .data-table tbody tr:nth-child(even) {
            background-color: #f8fafc;
        }
        .data-table tbody tr:hover {
            background-color: #f0f2f5;
        }
        .data-table .total-row {
            background-color: #e0f2f1; /* Light green for total rows */
            font-weight: bold;
        }
        .data-table .summary-row {
            background-color: #d1e7dd; /* Slightly darker green for summary */
            font-weight: bold;
        }
        .data-table .missing-row {
            background-color: #fee2e2; /* Light red for missing info */
            color: #ef4444;
            font-weight: bold;
        }
        /* Style for the tbody containing summary and total, make it look like a cohesive row */
        .data-table .runner-summary-group {
             border-bottom: 2px solid var(--bidv-green); /* Visual separator */
        }
        /* No border between total and summary row within the same tbody */
        .data-table .runner-summary-group .total-row td,
        .data-table .runner-summary-group .summary-row td {
            border-bottom: none;
        }
        .data-table .runner-summary-group .summary-row td {
            border-top: none;
        }
        .data-table .runner-summary-group .total-row {
            border-bottom: 1px solid #e2e8f0; /* Add a subtle line between total and summary */
        }


        /* Date picker styles */
        input[type="date"]::-webkit-calendar-picker-indicator {
            background: transparent;
            bottom: 0;
            color: transparent;
            cursor: pointer;
            height: auto;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            width: auto;
        }
        input[type="date"] {
            position: relative;
        }
        input[type="date"]::-webkit-inner-spin-button,
        input[type="date"]::-webkit-clear-button {
            display: none;
        }

        /* Scroll-to-top button styles */
        #scroll-to-top-btn {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 30px;
            z-index: 99;
            border: none;
            outline: none;
            background-color: var(--bidv-green);
            color: white;
            cursor: pointer;
            padding: 15px;
            border-radius: 50%;
            font-size: 18px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }

        #scroll-to-top-btn:hover {
            background-color: #005a57;
        }
    </style>
</head>
<body>
    <header class="bg-bidv-green text-white p-4 text-center text-sm" style="background-color: #006B68;">
        <div class="container flex justify-between items-center">
            <div class="flex items-center space-x-4">
                <img src="Running-Management-logo.png" alt="Logo BIDV Running Club" class="h-20 w-auto rounded-md">
                <h1 class="text-2xl font-bold text-white">Running Management with AI‚ú®</h1>
            </div>
            <nav>
              <!-- TH√äM ƒêO·∫†N M√É N√ÄY V√ÄO ƒê√ÇY -->
            <button id="toggle-settings-btn" class="ml-4 px-3 py-1 rounded-md text-white bg-gray-700 hover:bg-gray-600 transition duration-300 flex items-center gap-2">
                <i class="fas fa-gear"></i> <!-- Bi·ªÉu t∆∞·ª£ng b√°nh rƒÉng (c√†i ƒë·∫∑t) -->
                <span id="toggle-settings-text"></span> <!-- Nh√£n c·ªßa n√∫t (s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t b·∫±ng JS) -->
            </button>
        </nav>
        </div>
    </header>

    <main class="flex-grow container py-8">
        <!-- Application Authentication Section (Supabase Auth) -->
        <section id="app-auth-section" class="card mb-8">
            <div class="collapsible-header" data-target="app-auth-content">
                <h2 class="text-xl font-semibold"><i class="fas fa-lock text-yellow-500"></i>ƒêƒÉng nh·∫≠p/ƒêƒÉng k√Ω ·ª®ng d·ª•ng</h2>
                <i class="toggle-icon fas fa-chevron-right text-gray-600"></i>
            </div>
            <div id="app-auth-content" class="collapsible-content">
                <div id="logged-out-view">
                    <form id="auth-form" class="space-y-4 mb-4">
                        <div>
                            <label for="auth-email" class="block text-gray-700 text-sm font-bold mb-2">Email:</label>
                            <input type="email" id="auth-email" class="form-input" placeholder="example@email.com" required>
                        </div>
                        <div>
                            <label for="auth-password" class="block text-gray-700 text-sm font-bold mb-2">M·∫≠t kh·∫©u:</label>
                            <input type="password" id="auth-password" class="form-input" placeholder="M·∫≠t kh·∫©u c·ªßa b·∫°n" required>
                        </div>
                        <div class="flex justify-end gap-2">
                            <button type="submit" id="signup-btn" class="btn-primary">ƒêƒÉng k√Ω</button>
                            <button type="submit" id="signin-btn" class="btn-primary">ƒêƒÉng nh·∫≠p</button>
                        </div>
                    </form>
                    <div class="text-center">
                    </div>
                    <div id="auth-message" class="mt-4 text-sm text-center text-red-500"></div>
                </div>
                <div id="logged-in-view" class="hidden text-center">
                    <p class="mb-4 text-lg font-medium">Ch√†o m·ª´ng, <span id="current-app-user-email"></span>!</p>
                    <button id="signout-btn" class="btn-danger">ƒêƒÉng xu·∫•t ·ª®ng d·ª•ng</button>
                </div>
            </div>
        </section>

        <!-- Credential Management Section -->
        <section class="card mb-8 hidden" id="credential-management-section">
            <div class="collapsible-header" data-target="credential-management-content">
                <h2 class="text-xl font-semibold"><i class="fas fa-users-cog text-blue-500"></i>Qu·∫£n l√Ω Runner (Th√¥ng tin Runner v√† CLB)</h2>
                <div class="flex items-center gap-2">
                    <button id="add-credential-btn" class="btn-primary text-sm px-3 py-1">Th√™m Runner m·ªõi</button>
                    <i class="toggle-icon fas fa-chevron-right text-gray-600"></i>
                </div>
            </div>
            <div id="credential-management-content" class="collapsible-content">
                <div id="credentials-list" class="space-y-4">
                    <!-- Credentials will be loaded here -->
                    <p class="text-gray-500 text-center" id="no-credentials-message">Kh√¥ng c√≥ runner n√†o ƒë∆∞·ª£c l∆∞u.</p>
                </div>
                <p id="loading-credentials" class="text-gray-500 text-center hidden">ƒêang t·∫£i th√¥ng tin runner...</p>
                <p id="error-credentials" class="text-red-500 text-center hidden">L·ªói khi t·∫£i th√¥ng tin runner.</p>
            </div>
        </section>

        <!-- Strava Login Section (Adjusted) -->
        <section id="strava-auth-section" class="card mb-8 hidden">
            <div class="collapsible-header" data-target="strava-auth-content">
                <h2 class="text-xl font-semibold"><i class="fas fa-running text-orange-500"></i>K·∫øt n·ªëi t√†i kho·∫£n Strava c·ªßa b·∫°n</h2>
                <i class="toggle-icon fas fa-chevron-right text-gray-600"></i>
            </div>
            <div id="strava-auth-content" class="collapsible-content">
                <p class="mb-6">ƒê·ªÉ theo d√µi th√†nh t√≠ch ch·∫°y b·ªô, vui l√≤ng ch·ªçn m·ªôt runner v√† k·∫øt n·ªëi v·ªõi Strava.</p>
                
                <div class="mb-4">
                    <label for="runner-select" class="block text-gray-700 text-sm font-bold mb-2">Ch·ªçn Runner ƒë·ªÉ ƒëƒÉng nh·∫≠p:</label>
                    <select id="runner-select" class="form-input">
                        <option value="">-- Ch·ªçn Runner --</option>
                    </select>
                    <p class="text-xs text-gray-500 mt-1">Ch·ªçn runner ƒë√£ th√™m ·ªü tr√™n ƒë·ªÉ k·∫øt n·ªëi v·ªõi Strava.</p>
                </div>

                <!-- UPDATED: Replaced button with image and added centering classes -->
                <img id="connect-strava-btn" 
                     src="btn_strava_connect_with_white.png" 
                     alt="Connect with Strava" 
                     class="block mx-auto cursor-pointer w-48 h-auto rounded-lg shadow-md hover:opacity-90 transition duration-300 ease-in-out mb-4" /> 
                <!-- Added mb-4 for spacing below the image button -->

                <button id="disconnect-strava-btn" class="btn-primary ml-4">
                    ƒêƒÉng xu·∫•t Strava
                </button>
                <div id="auth-status" class="mt-4 text-sm text-gray-600"></div>
                <p id="current-runner-display" class="mt-2 text-center text-sm text-gray-600 hidden">ƒêang ƒëƒÉng nh·∫≠p v·ªõi: <span class="font-semibold" id="current-runner-name"></span></p>
            </div>
        </section>

        <!-- Section 1: Activity Data & Download -->
        <section id="data-section-part1" class="card mb-8 hidden">
            <div class="collapsible-header" data-target="data-section-part1-content" data-state-key="data-section-part1-state">
                <h2 class="text-xl font-semibold text-[#FC5200]"><i class="fa-brands fa-strava text-[#FC5200]"></i>T·∫£i/C·∫≠p nh·∫≠t d·ªØ li·ªáu t·ª´ Strava</h2>
                <i class="toggle-icon fas fa-chevron-right text-gray-600"></i>
            </div>
            <div id="data-section-part1-content" class="collapsible-content">
              

                <p id="user-info" class="mb-4 text-lg font-medium"></p>
                <div class="mb-4">
                    <label for="activities-limit" class="block text-gray-700 text-sm font-bold mb-2" style="background-color: #FFFACD; padding: 0.25rem 0.5rem; border-radius: 0.25rem;">S·ªë l∆∞·ª£ng ho·∫°t ƒë·ªông mu·ªën t·∫£i t·ª´ Strava (m·∫∑c ƒë·ªãnh 60, max 200):</label>
                    <input type="number" id="activities-limit" class="form-input" value="60" min="1" step="1" max="200">
                </div>

                <div class="flex flex-wrap gap-4 mb-6">
                    <button id="fetch-activities-btn" class="btn-primary">
                        T·∫£i/C·∫≠p nh·∫≠t d·ªØ li·ªáu t·ª´ Strava
                    </button>
                </div>
                
                <!-- Collapsible section for "Download Strava h·ªô" -->
                <section id="download-for-other-section" class="mt-6 border-t pt-4 bg-gray-100 rounded-lg p-4">
                    <div class="collapsible-header" data-target="download-for-other-content">
                        <h3 class="text-lg font-semibold"><i class="fas fa-user-friends text-purple-600"></i>T·∫£i d·ªØ li·ªáu Strava cho c√°c Runner kh√°c</h3>
                        <i class="toggle-icon fas fa-chevron-right text-gray-600"></i>
                    </div>
                    <div id="download-for-other-content" class="collapsible-content">
                        <div class="mb-4">
                            <label for="download-runner-select" class="block text-gray-700 text-sm font-bold mb-2">Ch·ªçn Runner ƒë·ªÉ t·∫£i h·ªô:</label>
                            <select id="download-runner-select" class="form-input">
                                <option value="">-- Ch·ªçn Runner --</option>
                            </select>
                            <p class="text-xs text-gray-500 mt-1">Ch·ªçn m·ªôt Runner ƒë√£ th√™m ƒë·ªÉ t·∫£i c√°c ho·∫°t ƒë·ªông Strava c·ªßa h·ªç.</p>
                        </div>
                        <button id="download-activities-for-other-btn" class="btn-primary">
                            Download Strava h·ªô
                        </button>
                        <div id="download-for-other-status" class="mt-4 text-sm text-gray-600"></div>
                    </div>
                </section>
                <div id="data-status" class="mt-4 text-sm text-gray-600"></div>
            </div>
        </section>

        <!-- Section 2: AI Analysis & Recent Activities -->
        <section id="data-section-part2" class="card mb-8 hidden">
            <div class="collapsible-header" data-target="data-section-part2-content"  data-state-key="data-section-part2-state">
                <h2 class="text-xl font-semibold"><i class="fas fa-brain text-indigo-500"></i>Ph√¢n t√≠ch AI & Ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y</h2>
                <i class="toggle-icon fas fa-chevron-right text-gray-600"></i>
            </div>
            <div id="data-section-part2-content" class="collapsible-content">
                <div id="activities-list-section" class="mt-4 pt-2">
                    <h3 class="text-lg font-semibold mb-3">C√°c ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y:</h3>
                    <div class="mb-4">
                        <label for="num-recent-activities" class="block text-gray-700 text-sm font-bold mb-2" style="background-color: #FFFACD; padding: 0.25rem 0.5rem; border-radius: 0.25rem;">S·ªë l∆∞·ª£ng ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y mu·ªën hi·ªÉn th·ªã (m·∫∑c ƒë·ªãnh 10):</label>
                        <input type="number" id="num-recent-activities" class="form-input" value="1000" min="1" step="1">
                    </div>
                    
                    <!-- Dropdown for filtering recent activities by runner -->
                    <div class="mb-4">
                        <label for="runner-recent-activities-filter" class="block text-gray-700 text-sm font-bold mb-2" style="background-color: #FFFACD; padding: 0.25rem 0.5rem; border-radius: 0.25rem;">L·ªçc ho·∫°t ƒë·ªông theo Runner:</label>
                        <select id="runner-recent-activities-filter" class="form-input">
                            <option value="all">T·∫•t c·∫£ Runner</option>
                            <!-- Runner options will be populated by JS -->
                        </select>
                    </div>

                    <!-- NEW: Dropdown for filtering recent activities by club -->
                    <div class="mb-4">
                        <label for="club-recent-activities-filter" class="block text-gray-700 text-sm font-bold mb-2" style="background-color: #FFFACD; padding: 0.25rem 0.5rem; border-radius: 0.25rem;">L·ªçc ho·∫°t ƒë·ªông theo C√¢u l·∫°c b·ªô:</label>
                        <select id="club-recent-activities-filter" class="form-input">
                            <option value="all">T·∫•t c·∫£ C√¢u l·∫°c b·ªô</option>
                            <!-- Club options will be populated by JS -->
                        </select>
                    </div>

                    <!-- Moved Activity Type Filter for Recent Activities -->
                    <div class="mb-4">
                        <label for="activity-type-filter-recent" class="block text-gray-700 text-sm font-bold mb-2" style="background-color: #FFFACD; padding: 0.25rem 0.5rem; border-radius: 0.25rem;">L·ªçc theo lo·∫°i ho·∫°t ƒë·ªông:</label>
                        <div class="multi-select-container">
                            <div id="multi-select-display-recent" class="multi-select-selected-items">
                                <span class="text-gray-500">Ch·ªçn lo·∫°i ho·∫°t ƒë·ªông</span>
                            </div>
                            <div id="multi-select-options-recent" class="multi-select-options hidden">
                                <!-- Options will be populated by JS -->
                            </div>
                        </div>
                    </div>

                    <!-- Moved Date Range Filter for Recent Activities -->
                    <div class="mb-4 flex gap-4">
                        <div class="flex-1">
                            <label for="start-date-recent" class="block text-gray-700 text-sm font-bold mb-2" style="background-color: #FFFACD; padding: 0.25rem 0.5rem; border-radius: 0.25rem;">T·ª´ ng√†y:</label>
                            <input type="date" id="start-date-recent" class="form-input">
                        </div>
                        <div class="flex-1">
                            <label for="end-date-recent" class="block text-gray-700 text-sm font-bold mb-2" style="background-color: #FFFACD; padding: 0.25rem 0.5rem; border-radius: 0.25rem;">ƒê·∫øn ng√†y:</label>
                            <input type="date" id="end-date-recent" class="form-input">
                        </div>
                    </div>

                    <!-- MOVED this button down -->
                    <button id="load-recent-activities-btn" class="btn-primary mb-4">
                        T·∫£i ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y
                    </button>
                    <button id="analyze-activities-btn" class="btn-primary">
                        ‚ú® Ph√¢n t√≠ch ho·∫°t ƒë·ªông (AI)
                    </button>
                 <!-- Changed from ul to div for multi-column layout -->
                    <div id="recent-activities-container" class="space-y-4"> <!-- B·ªè grid layout ·ªü ƒë√¢y ƒë·ªÉ c√°c ph·∫ßn t·ª≠ con t·ª± qu·∫£n l√Ω -->
                        <div id="recent-activities-summary-area" class="card p-4 text-gray-500 text-center col-span-full">
                            Nh·∫•n "T·∫£i ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y" ƒë·ªÉ xem.
                        </div>
                        <div id="detailed-recent-activities-cards" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 hidden">
                            <!-- Activity cards will be inserted here by JS -->
                        </div>
                    </div>
                    <div id="recent-activities-status" class="mt-2 text-sm text-gray-600"></div>
                </div>

                <div id="llm-analysis-section" class="mt-6 border-t pt-4 hidden">
                    <h3 class="text-lg font-semibold mb-3">Ph√¢n t√≠ch ho·∫°t ƒë·ªông c·ªßa b·∫°n:</h3>
                    <div id="llm-analysis-content" class="bg-gray-100 p-4 rounded-md text-sm">
                        <p class="text-gray-500">Nh·∫•n "‚ú® Ph√¢n t√≠ch ho·∫°t ƒë·ªông (AI)" ƒë·ªÉ nh·∫≠n ph√¢n t√≠ch t·ª´ AI.</p>
                    </div>
                    <div id="llm-analysis-status" class="mt-2 text-sm text-gray-600"></div>
                </div>
            </div>
        </section>

        <!-- New Detailed Stats Section -->
        <section id="detailed-stats-section" class="card hidden mb-8">
            <div class="collapsible-header" data-target="detailed-stats-content"  data-state-key="detailed-stats-section-state">
                <h2 class="text-xl font-semibold"><i class="fas fa-chart-line text-teal-600"></i>Th·ªëng k√™ chi ti·∫øt & Ti·ªÅn ph·∫°t/Th∆∞·ªüng</h2>
                <i class="toggle-icon fas fa-chevron-right text-gray-600"></i>
            </div>
            <div id="detailed-stats-content" class="collapsible-content">
                <div class="mb-4 flex gap-4 items-end">
                    <div class="flex-1">
                        <label for="penalty-per-km-gt10" class="block text-gray-700 text-sm font-bold mb-2">S·ªë ti·ªÅn n·ªôp cho 1KM (ngh√¨n VNƒê) khi thi·∫øu > 10KM:</label>
                        <input type="number" id="penalty-per-km-gt10" class="form-input bg-yellow-100" value="30" min="0" step="1">
                    </div>
                    <div class="flex-1">
                        <label for="penalty-per-km-lte10" class="block text-gray-700 text-sm font-bold mb-2">S·ªë ti·ªÅn n·ªôp cho 1KM (ngh√¨n VNƒê) khi thi·∫øu <= 10KM:</label>
                        <input type="number" id="penalty-per-km-lte10" class="form-input bg-yellow-100" value="20" min="0" step="1">
                    </div>
                    <div class="flex-1">
                        <label for="target-km-per-week" class="block text-gray-700 text-sm font-bold mb-2">S·ªë KM m·ªôt tu·∫ßn (KM):</label>
                        <input type="number" id="target-km-per-week" class="form-input bg-yellow-100" value="25" min="0" step="1">
                    </div>
                </div>
                <div id="detailed-stats-table-container" class="overflow-x-auto">
                    <table id="detailed-stats-table" class="data-table">
                        <thead>
                            <tr>
                                <th>T√™n Runner</th>
                                <th>Ng√†y ch·∫°y</th>
                                <th>Lo·∫°i ho·∫°t ƒë·ªông</th>
                                <th>Qu√£ng ƒë∆∞·ªùng (KM)</th>
                                <th>Pace</th>
                                <th>Nh·ªãp tim TB</th>
                                <th>ƒê·ªô cao tƒÉng</th>
                                <th>Th·ªùi gian ch·∫°y</th>
                            </tr>
                        </thead>
                        <!-- The tbodies for each runner will be inserted here dynamically by JS -->
                        <tbody></tbody> <!-- This empty tbody will be selected by JS and filled with content -->
                    </table>
                    <p id="detailed-stats-status" class="mt-4 text-sm text-gray-600 text-center">Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã.</p>
                </div>
            </div>
        </section>

        <section id="stats-section" class="card hidden">
            <div class="collapsible-header" data-target="stats-content" data-state-key="stats-section-state">
                <h2 class="text-xl font-semibold"><i class="fas fa-chart-bar text-red-500"></i>Th·ªëng k√™ th√†nh t√≠ch theo tu·∫ßn</h2>
                <i class="toggle-icon fas fa-chevron-right text-gray-600"></i>
            </div>
            <div id="stats-content" class="collapsible-content">
                <!-- Runner Filter for Stats Section -->
                <div class="mb-4">
                    <label for="runner-stats-filter" class="block text-gray-700 text-sm font-bold mb-2" style="background-color: #FFFACD; padding: 0.25rem 0.5rem; border-radius: 0.25rem;">Ch·ªçn Runner ƒë·ªÉ xem th·ªëng k√™:</label>
                    <select id="runner-stats-filter" class="form-input">
                        <option value="">T·∫•t c·∫£ Runner</option>
                        <!-- Options will be populated by JS -->
                    </select>
                </div>

                <!-- NEW: Club Filter for Stats Section -->
                <div class="mb-4">
                    <label for="club-stats-filter" class="block text-gray-700 text-sm font-bold mb-2" style="background-color: #FFFACD; padding: 0.25rem 0.5rem; border-radius: 0.25rem;">Ch·ªçn C√¢u l·∫°c b·ªô ƒë·ªÉ xem th·ªëng k√™:</label>
                    <select id="club-stats-filter" class="form-input">
                        <option value="">T·∫•t c·∫£ C√¢u l·∫°c b·ªô</option>
                        <!-- Club options will be populated by JS -->
                    </select>
                </div>

                <!-- Moved view-stats-btn here -->
                <button id="view-stats-btn" class="btn-primary mb-4">
                    Xem th·ªëng k√™ theo tu·∫ßn
                </button>

                <div id="bubble-chart-container">
                    <p class="text-gray-500 text-center">Nh·∫•n "Xem th·ªëng k√™ theo tu·∫ßn" ƒë·ªÉ hi·ªÉn th·ªã bi·ªÉu ƒë·ªì.</p>
                </div>
                <div id="chart-status" class="mt-4 text-sm text-gray-600"></div>
            </div>
        </section>

        <!-- Instruction Section -->
        <section id="instruction-section" class="card mb-8">
            <div class="collapsible-header" data-target="instruction-content">
                <h2 class="text-xl font-semibold"><i class="fas fa-info-circle text-blue-400"></i>H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng ·ª©ng d·ª•ng</h2>
                <i class="toggle-icon fas fa-chevron-right text-gray-600"></i>
            </div>
            <div id="instruction-content" class="collapsible-content">
                <div class="space-y-4 text-gray-700 max-h-96 overflow-y-auto pr-2">
                    <p>Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi ·ª®ng d·ª•ng Qu·∫£n l√Ω Th√†nh t√≠ch Ch·∫°y b·ªô - FOR RUNNER LOVER!</p>
                    <h3 class="font-bold text-lg text-bidv-green">1. ƒêƒÉng nh·∫≠p/ƒêƒÉng k√Ω ·ª®ng d·ª•ng:</h3>
                    <ul class="list-disc ml-6 space-y-1">
                        <li>B·∫°n c√≥ th·ªÉ ƒëƒÉng k√Ω t√†i kho·∫£n m·ªõi b·∫±ng Email v√† M·∫≠t kh·∫©u.</li>
                        <li>ƒêƒÉng nh·∫≠p n·∫øu ƒë√£ c√≥ t√†i kho·∫£n.</li>
                   </ul>
                    <h3 class="font-bold text-lg text-bidv-green">2. Qu·∫£n l√Ω Runner (K·∫øt n·ªëi v·ªõi Strava):</h3>
                    <ul class="list-disc ml-6 space-y-1">
                        <li>ƒê·ªÉ th√™m m·ªôt Runner m·ªõi v√† k·∫øt n·ªëi v·ªõi t√†i kho·∫£n Strava c·ªßa h·ªç, nh·∫•n "Th√™m Runner m·ªõi".</li>
                        <li>B·∫°n s·∫Ω ƒë∆∞·ª£c y√™u c·∫ßu nh·∫≠p t√™n cho Runner v√† sau ƒë√≥ ƒë∆∞·ª£c chuy·ªÉn h∆∞·ªõng ƒë·∫øn trang ·ªßy quy·ªÅn c·ªßa Strava.</li>
                        <li>Sau khi c·∫•p quy·ªÅn th√†nh c√¥ng, th√¥ng tin Runner v√† Strava Athlete ID s·∫Ω ƒë∆∞·ª£c l∆∞u l·∫°i.</li>
                        <li>Ch·ªâ ch·ªß s·ªü h·ªØu c·ªßa th√¥ng tin runner m·ªõi c√≥ th·ªÉ s·ª≠a ho·∫∑c x√≥a th√¥ng tin ƒë√≥.</li>
                    </ul>
                    <h3 class="font-bold text-lg text-bidv-green">3. Ch·ªçn Runner ƒë·ªÉ l√†m vi·ªác:</h3>
                    <ul class="list-disc ml-6 space-y-1">
                        <li>Ch·ªçn m·ªôt Runner t·ª´ danh s√°ch "Ch·ªçn Runner ƒë·ªÉ ƒëƒÉng nh·∫≠p" ƒë·ªÉ t·∫£i v√† qu·∫£n l√Ω d·ªØ li·ªáu cho Runner ƒë√≥.</li>
                        <li>·ª®ng d·ª•ng s·∫Ω t·ª± ƒë·ªông l√†m m·ªõi token v√† gi·ªØ k·∫øt n·ªëi v·ªõi Strava cho Runner ƒë√£ ch·ªçn.</li>
                        <li>S·ª≠ d·ª•ng "ƒêƒÉng xu·∫•t Strava" ƒë·ªÉ ng·∫Øt k·∫øt n·ªëi v·ªõi Runner hi·ªán t·∫°i.</li>
                    </ul>
                    <h3 class="font-bold text-lg text-bidv-green">4. D·ªØ li·ªáu th√†nh t√≠ch ch·∫°y b·ªô:</h3>
                    <ul class="list-disc ml-6 space-y-1">
                        <li><strong>T·∫£i/C·∫≠p nh·∫≠t d·ªØ li·ªáu t·ª´ Strava:</strong> T·∫£i c√°c ho·∫°t ƒë·ªông ch·∫°y b·ªô t·ª´ t√†i kho·∫£n Strava ƒëang k·∫øt n·ªëi v·ªÅ c∆° s·ªü d·ªØ li·ªáu c·ªßa ·ª©ng d·ª•ng. B·∫°n c√≥ th·ªÉ gi·ªõi h·∫°n s·ªë l∆∞·ª£ng ho·∫°t ƒë·ªông mu·ªën t·∫£i.</li>
                        <li><strong>L·ªçc theo lo·∫°i ho·∫°t ƒë·ªông:</strong> Ch·ªçn m·ªôt ho·∫∑c nhi·ªÅu lo·∫°i ho·∫°t ƒë·ªông (v√≠ d·ª•: Run, Ride, Swim) ƒë·ªÉ l·ªçc d·ªØ li·ªáu hi·ªÉn th·ªã.</li>
                        <li><strong>L·ªçc theo th·ªùi gian "T·ª´ ng√†y ƒë·∫øn ng√†y":</strong> Ch·ªçn kho·∫£ng th·ªùi gian ƒë·ªÉ l·ªçc c√°c ho·∫°t ƒë·ªông.</li>
                        <li><strong>C√°c ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y:</strong> Hi·ªÉn th·ªã danh s√°ch c√°c ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y nh·∫•t ƒë√£ ƒë∆∞·ª£c t·∫£i v·ªÅ, c√≥ th·ªÉ t√πy ch·ªânh s·ªë l∆∞·ª£ng hi·ªÉn th·ªã v√† l·ªçc theo Runner.</li>
                        <li><strong>Ph√¢n t√≠ch ho·∫°t ƒë·ªông (AI):</strong> S·ª≠ d·ª•ng AI ƒë·ªÉ ph√¢n t√≠ch c√°c ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y c·ªßa b·∫°n, ƒë∆∞a ra c√°i nh√¨n t·ªïng quan v·ªÅ hi·ªáu su·∫•t. Ph√¢n t√≠ch n√†y s·∫Ω t√≠nh ƒë·∫øn c√°c b·ªô l·ªçc hi·ªán c√≥.</li>
                    </ul>
                    <h3 class="font-bold text-lg text-bidv-green">5. Th·ªëng k√™ th√†nh t√≠ch theo tu·∫ßn:</h3>
                    <ul class="list-disc ml-6 space-y-1">
                        <li>Hi·ªÉn th·ªã bi·ªÉu ƒë·ªì bong b√≥ng th·ªëng k√™ t·ªïng qu√£ng ƒë∆∞·ªùng ch·∫°y theo tu·∫ßn cho Runner ƒë√£ ch·ªçn. K√≠ch th∆∞·ªõc bong b√≥ng t∆∞∆°ng ·ª©ng v·ªõi qu√£ng ƒë∆∞·ªùng.</li>
                        <li>Click v√†o bong b√≥ng ƒë·ªÉ xem chi ti·∫øt c√°c ho·∫°t ƒë·ªông trong tu·∫ßn ƒë√≥.</li>
                    </ul>
                    <h3 class="font-bold text-lg text-bidv-green">6. Th·ªëng k√™ chi ti·∫øt & Ti·ªÅn ph·∫°t/Th∆∞·ªüng:</h3>
                    <ul class="list-disc ml-6 space-y-1">
                        <li>Khu v·ª±c n√†y cho ph√©p b·∫°n theo d√µi chi ti·∫øt t·ª´ng ho·∫°t ƒë·ªông v√† t√≠nh to√°n c√°c kho·∫£n "ti·ªÅn ph·∫°t" n·∫øu kh√¥ng ƒë·∫°t m·ª•c ti√™u KM h√†ng tu·∫ßn.</li>
                        <li>Nh·∫≠p "S·ªë ti·ªÅn ph·∫°t 1KM" v√† "S·ªë KM m·ªôt tu·∫ßn" theo m·ª•c ti√™u c·ªßa b·∫°n.</li>
                        <li>B·∫£ng s·∫Ω t·ª± ƒë·ªông c·∫≠p nh·∫≠t ƒë·ªÉ hi·ªÉn th·ªã th√¥ng tin chi ti·∫øt t·ª´ng ho·∫°t ƒë·ªông ƒë√£ l·ªçc v√† t√≠nh to√°n t·ªïng k·∫øt cho t·ª´ng runner, bao g·ªìm s·ªë KM thi·∫øu v√† s·ªë ti·ªÅn thi·∫øu.</li>
                    </ul>
                    <p class="mt-4">Ch√∫c b·∫°n c√≥ nh·ªØng tr·∫£i nghi·ªám tuy·ªát v·ªùi v·ªõi ·ª©ng d·ª•ng!</p>
                </div>
            </div>
        </section>

    </main>

<footer class="bg-bidv-green text-white p-4 text-center text-sm" style="background-color: #006B68;">
    <div class="container" style="color: var(--bidv-yellow);">
        &copy; 2025 Tr∆∞∆°ng H·ªìng Qu√¢n - BIDV Running Club. All rights reserved (Dev by AIs - Gemini, GPT) - üìßquantrhvn@gmail.com - üì≥+84989073739 - 248064a v2.
        <br>
        <img src="PowerStrava.png" alt="PowerStrava Logo" style="height: 28px; margin: 5px auto 0 auto; display: block;">
        <br> <!-- Th√™m m·ªôt th·∫ª ng·∫Øt d√≤ng ƒë·ªÉ n√≥ xu·ªëng d√≤ng -->
        <span id="app-user-status" class="text-white text-sm"></span> <!-- D√ÅN D√íNG N√ÄY V√ÄO ƒê√ÇY -->
    </div>
</footer>

    <!-- Scroll to top button -->
    <button id="scroll-to-top-btn" title="Go to top">‚ñ≤</button>


    <!-- Credential Modal -->
    <div id="credential-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="close-modal-btn">&times;</span>
            <h3 id="modal-title" class="text-2xl font-bold mb-4 text-gray-800">Th√™m th√¥ng tin ƒëƒÉng nh·∫≠p Runner</h3>
            <form id="credential-form" class="space-y-4">
                <div>
                    <label for="runner-name" class="block text-gray-700 text-sm font-bold mb-2 text-red-500">T√™n Runner (Duy nh·∫•t):<span class="text-red-500">*</span></label>
                    <input type="text" id="runner-name" class="form-input" placeholder="V√≠ d·ª•: MyRunningAccount" required>
                </div>
                <!-- NEW FIELDS ADDED BELOW -->
                <div>
                    <label for="runner-full-name" class="block text-gray-700 text-sm font-bold mb-2">H·ªç v√† t√™n ch√≠nh th·ª©c:</label>
                    <input type="text" id="runner-full-name" class="form-input" placeholder="V√≠ d·ª•: Nguy·ªÖn VƒÉn A">
                </div>
                <div>
                    <label for="runner-phone-number" class="block text-gray-700 text-sm font-bold mb-2">S·ªë ƒëi·ªán tho·∫°i:</label>
                    <input type="tel" id="runner-phone-number" class="form-input" placeholder="V√≠ d·ª•: 0912345678">
                </div>
                <div>
                    <label for="runner-email" class="block text-gray-700 text-sm font-bold mb-2 text-red-500">Email Runner:<span class="text-red-500">*</span></label>
                    <input type="email" id="runner-email" class="form-input border-red-500 focus:ring-red-500" placeholder="V√≠ d·ª•: runner@example.com" required>
                </div>
                <div>
                    <label for="runner-date-of-birth" class="block text-gray-700 text-sm font-bold mb-2">Ng√†y sinh:</label>
                    <input type="date" id="runner-date-of-birth" class="form-input">
                </div>
                <div>
                    <label for="runner-weight-kg" class="block text-gray-700 text-sm font-bold mb-2">C√¢n n·∫∑ng (kg):</label>
                    <input type="number" id="runner-weight-kg" class="form-input" placeholder="V√≠ d·ª•: 65" min="1">
                </div>
                <div>
                    <label for="runner-shirt-size" class="block text-gray-700 text-sm font-bold mb-2">C·ª° √°o:</label>
                    <select id="runner-shirt-size" class="form-input">
                        <option value="">-- Ch·ªçn c·ª° √°o --</option>
                        <option value="XS">XS</option>
                        <option value="S">S</option>
                        <option value="M">M</option>
                        <option value="L">L</option>
                        <option value="XL">XL</option>
                        <option value="XXL">XXL</option>
                        <option value="XXXL">XXXL</option>
                    </select>
                </div>
                <div>
                    <label for="runner-team" class="block text-gray-700 text-sm font-bold mb-2 text-red-500">ƒê·ªôi ch·∫°y:<span class="text-red-500">*</span></label>
                    <select id="runner-team" class="form-input border-red-500 focus:ring-red-500" required>
                        <option value="">-- Ch·ªçn ƒë·ªôi ch·∫°y --</option>
                        <!-- Club options will be populated by JS -->
                    </select>
                </div>
                <div>
                    <label for="runner-gender" class="block text-gray-700 text-sm font-bold mb-2 text-red-500">Gi·ªõi t√≠nh:<span class="text-red-500">*</span></label>
                    <select id="runner-gender" class="form-input border-red-500 focus:ring-red-500" required>
                        <option value="">-- Ch·ªçn gi·ªõi t√≠nh --</option>
                        <option value="Nam">Nam</option>
                        <option value="N·ªØ">N·ªØ</option>
                        <option value="Kh√°c">Kh√°c</option>
                    </select>
                </div>
                <!-- END NEW FIELDS -->

                <!-- REMOVED: client-id, client-secret, refresh-token inputs -->
                <!-- client_id, client_secret now come from ENV variables on Edge Function side -->
                <!-- refresh_token will be obtained during OAuth flow -->
                
                <div>
                    <label for="redirect-uri" class="block text-gray-700 text-sm font-bold mb-2">Redirect URI:</label>
                    <!-- Value is now fixed and input is readonly -->
                    <input type="text" id="redirect-uri" class="form-input" value="https://quantrh.github.io/Strava/index1.html" readonly required>
                    <p class="text-xs text-gray-500 mt-1">URI n√†y l√† c·ªë ƒë·ªãnh cho ·ª©ng d·ª•ng v√† ƒë∆∞·ª£c d√πng trong qu√° tr√¨nh ·ªßy quy·ªÅn Strava.</p>
                </div>
                <input type="hidden" id="credential-id">
                <div class="flex justify-end gap-2 mt-6">
                    <button type="button" id="cancel-modal-btn" class="btn-primary">H·ªßy</button>
                    <button type="submit" class="btn-primary">L∆∞u th√¥ng tin</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Weekly Activities Modal -->
    <div id="weekly-activities-modal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <span class="close-button" id="close-weekly-activities-modal-btn">&times;</span>
            <h3 id="weekly-activities-title" class="text-2xl font-bold mb-4 text-gray-800">Ho·∫°t ƒë·ªông trong tu·∫ßn:</h3>
            <div class="max-h-96 overflow-y-auto border rounded-md p-2">
                <ul id="weekly-activities-list" class="space-y-2 text-sm">
                    <!-- Activities will be loaded here -->
                </ul>
            </div>
            <p id="weekly-activities-status" class="mt-4 text-sm text-gray-600"></p>
        </div>
    </div>

    <!-- Custom Alert/Confirm Modals -->
    <div id="custom-alert" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full text-center">
            <p id="alert-message" class="mb-4 text-lg"></p>
            <button id="alert-ok-btn" class="btn-primary">OK</button>
        </div>
    </div>

    <div id="custom-confirm-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full text-center">
            <p id="confirm-message" class="mb-4 text-lg"></p>
            <div class="flex justify-center gap-4">
                <button type="button" id="confirm-cancel-btn" class="btn-primary">H·ªßy</button>
                <button type="button" id="confirm-ok-btn" class="btn-danger">ƒê·ªìng √Ω</button>
            </div>
        </div>
    </div>

    <script>
        // Function to display custom alert instead of alert()
        function showAlert(message) {
            const customAlert = document.getElementById('custom-alert');
            const alertMessage = document.getElementById('alert-message');
            const alertOkBtn = document.getElementById('alert-ok-btn');

            alertMessage.textContent = message;
            customAlert.classList.remove('hidden');

            alertOkBtn.onclick = () => {
                customAlert.classList.add('hidden');
            };
        }

        // Function to display custom confirm dialog instead of window.confirm()
        function showConfirm(message) {
            return new Promise((resolve) => {
                const customConfirm = document.getElementById('custom-confirm-modal');
                const confirmMessage = document.getElementById('confirm-message');
                const confirmOkBtn = document.getElementById('confirm-ok-btn'); 
                const confirmCancelBtn = document.getElementById('confirm-cancel-btn');

                confirmMessage.textContent = message;
                customConfirm.classList.remove('hidden');

                const cleanup = () => {
                    customConfirm.classList.add('hidden');
                    confirmOkBtn.onclick = null;
                    confirmCancelBtn.onclick = null;
                };

                confirmOkBtn.onclick = () => {
                    cleanup();
                    resolve(true);
                };
                confirmCancelBtn.onclick = () => {
                    cleanup();
                    resolve(false);
                };
            });
        }

        // Your Supabase configuration
        const SUPABASE_URL = 'https://rmbsxccrwrktbjlnezpu.supabase.co'; // Your Supabase project URL
        // L∆ØU √ù: L·ªói "Invalid API key" khi t·∫£i danh s√°ch c√¢u l·∫°c b·ªô th∆∞·ªùng xu·∫•t hi·ªán n·∫øu kh√≥a n√†y kh√¥ng ƒë√∫ng
        // ho·∫∑c c√°c ch√≠nh s√°ch b·∫£o m·∫≠t (RLS) tr√™n b·∫£ng 'clubs' trong d·ª± √°n Supabase c·ªßa b·∫°n kh√¥ng cho ph√©p truy c·∫≠p.
        // Vui l√≤ng ki·ªÉm tra l·∫°i Anon Key v√† c·∫•u h√¨nh RLS tr√™n b·∫£ng 'clubs' trong b·∫£ng ƒëi·ªÅu khi·ªÉn Supabase c·ªßa b·∫°n.
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJtYnN4Y2Nyd3JrdGJqbG5lenB1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg2MjczNjQsImV4cCI6MjA2NDIwMzM2NH0.ydCqificftdtn1niRciFCifeuo8aX6SDGti-hCY5Z_Y'; // Your public anon key for Supabase
        const STRAVA_OAUTH_CALLBACK_URL = 'https://rmbsxccrwrktbjlnezpu.supabase.co/functions/v1/strava-oauth-callback';
        const FETCH_ACTIVITIES_API_URL = 'https://rmbsxccrwrktbjlnezpu.supabase.co/functions/v1/fetch-strava-activities';
        const GET_STATS_API_URL = 'https://rmbsxccrwrktbjlnezpu.supabase.co/functions/v1/get-user-activities';
        // New Edge Function URL for AI analysis
        const ANALYZE_ACTIVITIES_FUNCTION_URL = 'https://rmbsxccrwrktbjlnezpu.supabase.co/functions/v1/analyze-activities-with-gemini'; 
        const SETTINGS_VISIBILITY_KEY = 'app_settings_visible'; // Kh√≥a ƒë·ªÉ l∆∞u tr·∫°ng th√°i hi·ªÉn th·ªã c√†i ƒë·∫∑t trong localStorage

        // Add the application's global Strava Client ID for OAuth flow
        // You MUST replace 'YOUR_APP_STRAVA_CLIENT_ID' with your actual application's Client ID
        const APP_STRAVA_CLIENT_ID = '55949'; 
        // The Redirect URI must match what you configured in your Strava API Application settings
        const APP_STRAVA_REDIRECT_URI = 'https://quantrh.github.io/Strava/index1.html';


        // Global variables to store user status and activity data
        let currentRunnerCredentialId = null; // This will store the Supabase runner_credentials.id (UUID)
        let isAuthenticated = false; // Tracks if Strava is authenticated (for the *selected* runner)
        let userActivities = []; // New variable to store all loaded activities (for detailed stats)
        let weeklyStatsData = []; // Store weekly stats data globally (for bubble chart)
        let currentAthleteId = null; // Stores Strava athlete ID for API calls and for activities.user_id (of the currently logged-in Strava runner)
        let currentRunnerName = null; // Stores the name of the currently logged-in runner
        let currentAppUserId = null; // Stores Supabase Auth user ID (UUID)
        const ALL_ACTIVITY_TYPES = [
            'Run', 'Walk', 'Ride', 'Swim', 'Hike', 'NordicSki', 'AlpineSki', 'Workout', 'Yoga', 
            'WeightTraining', 'Elliptical', 'StairStepper', 'Rowing', 'Crossfit', 'Canoeing', 
            'Kayaking', 'StandUpPaddling', 'VirtualRide', 'VirtualRun', 'Wheelchair', 'Handcycle', 
            'RollerSki', 'IceSkate', 'Snowboard', 'Snowshoe', 'BackcountrySki', 'EMountainBikeRide', 
            'EBikeRide', 'MountainBikeRide', 'GravelRide', 'Velomobile', 'Kitesurf', 'Windsurf', 
            'RockClimbing', 'Alpinism', 'Badminton', 'Squash', 'TableTennis', 'Tennis', 'Volleyball', 
            'Surfing', 'Pilates', 'Golf', 'WaterSport', 'Soccer', 'Basketball'
        ].sort(); // Sort activity types alphabetically

        let allRunnerCredentials = []; // Store all fetched runner credentials for the current app user
        let allClubs = []; // NEW: Store all fetched clubs

        // Initialize Supabase client instance
        let supabaseClientInstance;

        // DOM elements
        const appUserStatus = document.getElementById('app-user-status');
        const appAuthSection = document.getElementById('app-auth-section');
        const loggedOutView = document.getElementById('logged-out-view');
        const loggedInView = document.getElementById('logged-in-view');
        const currentAppUserEmail = document.getElementById('current-app-user-email');
        const authForm = document.getElementById('auth-form');
        const authEmailInput = document.getElementById('auth-email');
        const authPasswordInput = document.getElementById('auth-password'); 
        const signupBtn = document.getElementById('signup-btn');
        const signinBtn = document.getElementById('signin-btn');
        const guestLoginBtn = document.getElementById('guest-login-btn');
        const signoutBtn = document.getElementById('signout-btn');
        const authMessage = document.getElementById('auth-message');

        const credentialManagementSection = document.getElementById('credential-management-section');
        const stravaAuthSection = document.getElementById('strava-auth-section');
        const detailedStatsSection = document.getElementById('detailed-stats-section'); // New DOM element

        const addCredentialBtn = document.getElementById('add-credential-btn');
        const credentialsList = document.getElementById('credentials-list');
        const noCredentialsMessage = document.getElementById('no-credentials-message');
        const loadingCredentials = document.getElementById('loading-credentials');
        const errorCredentials = document.getElementById('error-credentials');
        const credentialModal = document.getElementById('credential-modal');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const cancelModalBtn = document.getElementById('cancel-modal-btn');
        const modalTitle = document.getElementById('modal-title');
        const credentialForm = document.getElementById('credential-form');
        const runnerNameInput = document.getElementById('runner-name');
        const redirectUriInput = document.getElementById('redirect-uri');
        const credentialIdInput = document.getElementById('credential-id');
        const runnerSelect = document.getElementById('runner-select');
        const connectStravaBtn = document.getElementById('connect-strava-btn'); // This is now the <img> element
        const disconnectStravaBtn = document.getElementById('disconnect-strava-btn');
        const authStatus = document.getElementById('auth-status');
        const currentRunnerDisplay = document.getElementById('current-runner-display');
        const currentRunnerNameSpan = document.getElementById('current-runner-name');
        const fetchActivitiesBtn = document.getElementById('fetch-activities-btn');
        const viewStatsBtn = document.getElementById('view-stats-btn');
        const analyzeActivitiesBtn = document.getElementById('analyze-activities-btn');
        
        // Split data-section into two parts
        const dataSectionPart1 = document.getElementById('data-section-part1');
        const dataSectionPart2 = document.getElementById('data-section-part2');
        
        const userInfo = document.getElementById('user-info');
        const activitiesLimitInput = document.getElementById('activities-limit');
        const numRecentActivitiesInput = document.getElementById('num-recent-activities');
        const loadRecentActivitiesBtn = document.getElementById('load-recent-activities-btn');
        const recentActivitiesContainer = document.getElementById('recent-activities-container'); // Changed from recentActivitiesList
        const recentActivitiesStatus = document.getElementById('recent-activities-status');
        const statsSection = document.getElementById('stats-section');

        const recentActivitiesSummaryArea = document.getElementById('recent-activities-summary-area');
        const detailedRecentActivitiesCards = document.getElementById('detailed-recent-activities-cards');
        

        // New DOM elements for weekly activities modal
        const weeklyActivitiesModal = document.getElementById('weekly-activities-modal');
        const closeWeeklyActivitiesModalBtn = document.getElementById('close-weekly-activities-modal-btn');
        const weeklyActivitiesTitle = document.getElementById('weekly-activities-title');
        const weeklyActivitiesList = document.getElementById('weekly-activities-list');
        const weeklyActivitiesStatus = document.getElementById('weekly-activities-status');

        // Filter elements
        const multiSelectDisplayRecent = document.getElementById('multi-select-display-recent');
        const multiSelectOptionsRecent = document.getElementById('multi-select-options-recent');
        // Runner filter for recent activities
        const runnerRecentActivitiesFilter = document.getElementById('runner-recent-activities-filter');

        // NEW: Club filter DOM elements
        const runnerTeamSelect = document.getElementById('runner-team'); // Select element in credential modal
        const clubRecentActivitiesFilter = document.getElementById('club-recent-activities-filter');
        const clubStatsFilter = document.getElementById('club-stats-filter');

        let selectedActivityTypesRecent = [];
        let selectedActivityTypesStats = []; 
        let selectedRunnerIdForStats = ''; // Variable for stats runner filter
        let selectedClubIdForStats = ''; // NEW: Variable for stats club filter
        let selectedRunnerIdForRecentActivities = 'all'; // Default to 'all' for recent activities filter
        let selectedClubNameForRecentActivities = 'all'; // NEW: Default to 'all' for recent activities club filter


        // Date filter elements
        const startDateRecent = document.getElementById('start-date-recent');
        const endDateRecent = document.getElementById('end-date-recent');

        // New elements for detailed stats table
        const penaltyPerKmGt10Input = document.getElementById('penalty-per-km-gt10'); // Changed ID
        const penaltyPerKmLte10Input = document.getElementById('penalty-per-km-lte10'); // New input
        const targetKmPerWeekInput = document.getElementById('target-km-per-week');
        const detailedStatsTable = document.getElementById('detailed-stats-table'); // Reference to the whole table
        const detailedStatsStatus = document.getElementById('detailed-stats-status');

        // Collapsible elements
        const appAuthContent = document.getElementById('app-auth-content');
        const credentialManagementContent = document.getElementById('credential-management-content');
        const stravaAuthContent = document.getElementById('strava-auth-content');
        const instructionSection = document.getElementById('instruction-section');
        const instructionContent = document.getElementById('instruction-content');
        const dataSectionPart1Content = document.getElementById('data-section-part1-content'); // New content element for part1
        const dataSectionPart2Content = document.getElementById('data-section-part2-content'); // New content element for part2
        const detailedStatsContent = document.getElementById('detailed-stats-content'); // Content for detailed stats
        const statsContent = document.getElementById('stats-content'); // Content for weekly stats

        // DOM element for runner stats filter
        const runnerStatsFilter = document.getElementById('runner-stats-filter');

        // DOM elements for "Download Strava h·ªô" feature
        const downloadForOtherSection = document.getElementById('download-for-other-section'); // Reference to the new collapsible section
        const downloadForOtherContent = document.getElementById('download-for-other-content'); // Reference to the content within the new collapsible section
        const downloadRunnerSelect = document.getElementById('download-runner-select');
        const downloadActivitiesForOtherBtn = document.getElementById('download-activities-for-other-btn');
        const downloadForOtherStatus = document.getElementById('download-for-other-status');

        // LLM analysis DOM elements
        const llmAnalysisSection = document.getElementById('llm-analysis-section');
        const llmAnalysisContent = document.getElementById('llm-analysis-content');
        const llmAnalysisStatus = document.getElementById('llm-analysis-status');
        
        // Scroll to top button
        const scrollToTopBtn = document.getElementById('scroll-to-top-btn');

        // Th√™m c√°c DOM elements m·ªõi cho n√∫t ·∫©n/hi·ªán c√†i ƒë·∫∑t
        const toggleSettingsBtn = document.getElementById('toggle-settings-btn');
        const toggleSettingsText = document.getElementById('toggle-settings-text');

    // L∆ØU √ù: C√°c section appAuthSection, credentialManagementSection, stravaAuthSection ƒë√£ ƒë∆∞·ª£c khai b√°o ·ªü tr√™n.
    // B·∫°n kh√¥ng c·∫ßn khai b√°o l·∫°i ch√∫ng ·ªü ƒë√¢y.

        

        // --- Helper functions for UI and data transformation ---

       /**
 * Toggles the collapsible state of a section.
 * @param {HTMLElement} contentElement - The content div/tbody to collapse/expand.
 * @param {HTMLElement} toggleIcon - The icon element (SVG or span with text).
 * @param {boolean} [forceCollapse] - If true, force collapse. If false, force expand. If undefined, toggles.
 * @param {string} [stateKey] - Optional: A key to store the state in localStorage.
 */
function toggleCollapsible(contentElement, toggleIcon, forceCollapse, stateKey) { // Th√™m stateKey v√†o tham s·ªë
    const isCollapsed = contentElement.classList.contains('collapsed');

    let shouldCollapse;
    if (forceCollapse !== undefined) {
        shouldCollapse = forceCollapse;
    } else {
        shouldCollapse = !isCollapsed;
    }

    if (shouldCollapse) {
        contentElement.classList.add('collapsed');
        // Use Font Awesome classes for icons
        if (toggleIcon) { // Ensure toggleIcon exists before manipulating
            toggleIcon.classList.remove('fa-chevron-down');
            toggleIcon.classList.add('fa-chevron-right');
        }
        if (stateKey) { // <-- Th√™m d√≤ng n√†y ƒë·ªÉ l∆∞u tr·∫°ng th√°i
            localStorage.setItem(stateKey, 'collapsed');
        }
    } else {
        contentElement.classList.remove('collapsed');
        if (toggleIcon) { // Ensure toggleIcon exists before manipulating
            toggleIcon.classList.remove('fa-chevron-right');
            toggleIcon.classList.add('fa-chevron-down');
        }
        if (stateKey) { // <-- Th√™m d√≤ng n√†y ƒë·ªÉ l∆∞u tr·∫°ng th√°i
            localStorage.setItem(stateKey, 'expanded');
        }
    }
}

        /**
 * √Åp d·ª•ng tr·∫°ng th√°i hi·ªÉn th·ªã cho c√°c section c√†i ƒë·∫∑t v√† c·∫≠p nh·∫≠t n√∫t toggle.
 * @param {boolean} isVisible - True n·∫øu c√°c section n√™n hi·ªÉn th·ªã, false n·∫øu n√™n ·∫©n.
 */
function applySettingsVisibility(isVisible) {
    // C·∫≠p nh·∫≠t tr·∫°ng th√°i hi·ªÉn th·ªã c·ªßa 3 section c√†i ƒë·∫∑t ch√≠nh
    if (appAuthSection) {
        if (isVisible) {
            appAuthSection.classList.remove('hidden');
        } else {
            appAuthSection.classList.add('hidden');
        }
    }
    if (credentialManagementSection) {
        if (isVisible) {
            credentialManagementSection.classList.remove('hidden');
        } else {
            credentialManagementSection.classList.add('hidden');
        }
    }
    if (stravaAuthSection) {
        if (isVisible) {
            stravaAuthSection.classList.remove('hidden');
        } else {
            stravaAuthSection.classList.add('hidden');
        }
    }

    // C·∫≠p nh·∫≠t nh√£n n√∫t "Hi·ªán/·∫®n C√†i ƒë·∫∑t"
    if (toggleSettingsText) {
        if (isVisible) {
            toggleSettingsText.textContent = '·∫®n c√†i ƒë·∫∑t';
            toggleSettingsBtn.classList.remove('bg-gray-500'); // Thay ƒë·ªïi m√†u n·ªÅn khi hi·ªÉn th·ªã
            toggleSettingsBtn.classList.add('bg-gray-700');
        } else {
            toggleSettingsText.textContent = 'Hi·ªán c√†i ƒë·∫∑t';
            toggleSettingsBtn.classList.remove('bg-gray-700'); // Thay ƒë·ªïi m√†u n·ªÅn khi ·∫©n
            toggleSettingsBtn.classList.add('bg-gray-500');
        }
    }

    // L∆∞u tr·∫°ng th√°i v√†o localStorage
    localStorage.setItem(SETTINGS_VISIBILITY_KEY, isVisible.toString());
}

        
        /**
         * Populates the multi-select filter dropdowns.
         */
        function populateActivityTypeFilters() {
            const optionsContainer = document.getElementById('multi-select-options-recent');
            optionsContainer.innerHTML = ''; 
            ALL_ACTIVITY_TYPES.forEach(type => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'multi-select-option';
                optionDiv.textContent = type;
                optionDiv.dataset.value = type;
                optionsContainer.appendChild(optionDiv);
            });
        }

        /**
         * Updates the display of selected items in the multi-select.
         * @param {HTMLElement} displayElement - The element to show selected tags.
         * @param {string[]} selectedTypes - Array of selected activity types.
         * @param {HTMLElement} optionsContainer - The container for options to update their 'selected' class.
         */
        function updateMultiSelectDisplay(displayElement, selectedTypes, optionsContainer) {
            displayElement.innerHTML = '';
            if (selectedTypes.length === 0) {
                displayElement.innerHTML = '<span class="text-gray-500">Ch·ªçn lo·∫°i ho·∫°t ƒë·ªông</span>';
            } else {
                selectedTypes.forEach(type => {
                    const itemSpan = document.createElement('span');
                    itemSpan.className = 'multi-select-selected-item';
                    itemSpan.innerHTML = `${type} <span data-value="${type}" class="remove-item-btn">&times;</span>`;
                    displayElement.appendChild(itemSpan);
                });
            }

            Array.from(optionsContainer.children).forEach(optionDiv => {
                if (selectedTypes.includes(optionDiv.dataset.value)) {
                    optionDiv.classList.add('selected');
                } else {
                    optionDiv.classList.remove('selected');
                }
            });
        }

        /**
         * Toggles an activity type in the selected list.
         * @param {string} type - The activity type to toggle.
         * @param {string[]} selectedTypesArray - The array to modify (e.g., selectedActivityTypesRecent).
         * @param {HTMLElement} displayElement - The display element for this filter.
         * @param {HTMLElement} optionsContainer - The options container for this filter.
         */
        function toggleActivityType(type, selectedTypesArray, displayElement, optionsContainer) {
            const index = selectedTypesArray.indexOf(type);
            if (index > -1) {
                selectedTypesArray.splice(index, 1); // Remove if already exists
            } else {
                selectedTypesArray.push(type); // Add if not exists
                selectedTypesArray.sort(); // Keep sorted alphabetically
            }
            updateMultiSelectDisplay(displayElement, selectedTypesArray, optionsContainer);
        }

        // Event delegation for multi-select options
        document.addEventListener('click', (event) => {
            // Toggle options visibility
            if (event.target.closest('#multi-select-display-recent')) {
                document.getElementById('multi-select-options-recent').classList.toggle('hidden');
            } else {
                // Click outside to close options
                if (!event.target.closest('.multi-select-options')) {
                    document.getElementById('multi-select-options-recent').classList.add('hidden');
                }
            }

            // Handle option selection/deselection
            if (event.target.classList.contains('multi-select-option')) {
                const type = event.target.dataset.value;
                if (event.target.closest('#multi-select-options-recent')) {
                    toggleActivityType(type, selectedActivityTypesRecent, multiSelectDisplayRecent, document.getElementById('multi-select-options-recent'));
                }
            } else if (event.target.classList.contains('remove-item-btn')) {
                const type = event.target.dataset.value;
                if (event.target.closest('#multi-select-display-recent')) {
                    toggleActivityType(type, selectedActivityTypesRecent, multiSelectDisplayRecent, document.getElementById('multi-select-options-recent'));
                }
            }
        });


        /**
         * Formats duration from seconds to HH:MM:SS.
         * @param {number} seconds - Duration in seconds.
         * @returns {string} Formatted duration string.
         */
        function formatDuration(seconds) {
            if (typeof seconds !== 'number' || isNaN(seconds) || seconds < 0) return 'N/A';
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return [h, m, s].map(v => v < 10 ? "0" + v : v).filter((v, i) => v !== "00" || i > 0).join(":");
        }

/**
         * Render activity summary and "View Details" button.
         * @param {Array} activities - List of activity objects.
         */
        function renderActivitySummary(activities) {
            recentActivitiesSummaryArea.innerHTML = ''; // Clear previous summary

            if (!activities || activities.length === 0) {
                recentActivitiesSummaryArea.innerHTML = '<p class="text-gray-500">Kh√¥ng t√¨m th·∫•y ho·∫°t ƒë·ªông n√†o ph√π h·ª£p v·ªõi c√°c b·ªô l·ªçc ƒë√£ ch·ªçn.</p>';
                detailedRecentActivitiesCards.classList.add('hidden'); // Ensure detailed cards are hidden
                return;
            }

            const totalActivities = activities.length;
            let totalDistanceKm = 0;

            const distanceByRunner = new Map();
            const distanceByClub = new Map();

            activities.forEach(activity => {
                const distance = activity.distance / 1000; // Convert meters to kilometers
                totalDistanceKm += distance;

                const runner = allRunnerCredentials.find(rc => String(rc.athlete_id) === String(activity.user_id));
                const runnerName = runner ? runner.runner_name : `Runner ID: ${activity.user_id || 'Unknown'}`;
                const clubName = runner ? runner.running_team : 'Kh√¥ng r√µ CLB';

                // Sum distance by runner
                distanceByRunner.set(runnerName, (distanceByRunner.get(runnerName) || 0) + distance);

                // Sum distance by club
                distanceByClub.set(clubName, (distanceByClub.get(clubName) || 0) + distance);
            });

            let summaryHtml = `<p class="text-lg font-bold text-bidv-green mb-2">T·ªïng quan ho·∫°t ƒë·ªông (${totalActivities} ho·∫°t ƒë·ªông):</p>`;
            summaryHtml += `<p class="mb-2">T·ªïng qu√£ng ƒë∆∞·ªùng: <span class="font-bold text-xl">${totalDistanceKm.toFixed(2)} KM</span></p>`;

            summaryHtml += `<p class="font-semibold mt-4 mb-1">Qu√£ng ƒë∆∞·ªùng theo Runner:</p>`;
            summaryHtml += `<ul class="list-disc ml-6 text-sm">`;
            Array.from(distanceByRunner.entries()).sort((a, b) => b[1] - a[1]).forEach(([runner, dist]) => {
                summaryHtml += `<li>${runner}: ${dist.toFixed(2)} KM</li>`;
            });
            summaryHtml += `</ul>`;

            summaryHtml += `<p class="font-semibold mt-4 mb-1">Qu√£ng ƒë∆∞·ªùng theo C√¢u l·∫°c b·ªô:</p>`;
            summaryHtml += `<ul class="list-disc ml-6 text-sm">`;
            Array.from(distanceByClub.entries()).sort((a, b) => b[1] - a[1]).forEach(([club, dist]) => {
                summaryHtml += `<li>${club}: ${dist.toFixed(2)} KM</li>`;
            });
            summaryHtml += `</ul>`;

            summaryHtml += `
                <div class="mt-6 text-center">
                    <button id="view-detailed-activities-btn" class="btn-primary">
                        Xem chi ti·∫øt c√°c ho·∫°t ƒë·ªông
                    </button>
                </div>
            `;
            recentActivitiesSummaryArea.innerHTML = summaryHtml;

            // Attach event listener to the new button
            const viewDetailedActivitiesBtn = document.getElementById('view-detailed-activities-btn');
            if (viewDetailedActivitiesBtn) {
                viewDetailedActivitiesBtn.addEventListener('click', () => {
                    renderDetailedActivityCards(activities); // Render the detailed cards
                    detailedRecentActivitiesCards.classList.remove('hidden'); // Show the detailed cards container
                    viewDetailedActivitiesBtn.classList.add('hidden'); // Optionally hide the summary button after click
                    // Cu·ªôn xu·ªëng ƒë·ªÉ ng∆∞·ªùi d√πng th·∫•y c√°c ho·∫°t ƒë·ªông chi ti·∫øt
                    detailedRecentActivitiesCards.scrollIntoView({ behavior: 'smooth', block: 'start' });
                });
            }
        }


        /**
         * Render detailed activity cards in the dedicated container.
         * @param {Array} activities - List of activity objects.
         */
        function renderDetailedActivityCards(activities) {
            detailedRecentActivitiesCards.innerHTML = ''; // Clear previous cards

            if (!activities || activities.length === 0) {
                detailedRecentActivitiesCards.innerHTML = '<div class="card p-4 text-gray-500 text-center col-span-full">Kh√¥ng c√≥ ho·∫°t ƒë·ªông n√†o ƒë·ªÉ hi·ªÉn th·ªã chi ti·∫øt.</div>';
                return;
            }

            activities.forEach(activity => {
                const activityCard = document.createElement('div');
                activityCard.className = 'card p-4 text-sm space-y-1 border border-gray-200 rounded-lg shadow-sm';
                const runner = allRunnerCredentials.find(rc => String(rc.athlete_id) === String(activity.user_id));
                const runnerNameForDisplay = runner ? runner.runner_name : `Runner ID: ${activity.user_id || 'Unknown'}`;
                const runnerClubForDisplay = runner ? runner.running_team : 'N/A';

                activityCard.innerHTML = `
                    <p class="font-bold text-base text-bidv-green">${runnerNameForDisplay} <span class="text-gray-500 text-xs">(${runnerClubForDisplay})</span></p>
                    <p class="font-semibold">${activity.name} (${activity.type})</p>
                    <p>Ng√†y: ${new Date(activity.start_date).toLocaleString('vi-VN', { 
                        timeZone: 'Asia/Ho_Chi_Minh',
                        hour: '2-digit', 
                        minute: '2-digit', 
                        day: '2-digit', 
                        month: '2-digit', 
                        year: 'numeric' 
                    })}</p>
                    <p>Qu√£ng ƒë∆∞·ªùng: ${(activity.distance / 1000).toFixed(2)} km</p>
                    <p>Th·ªùi gian: ${formatDuration(activity.moving_time)}</p>
                    <p>Pace: ${formatPace(activity.average_speed)}</p>
                    <p>Nh·ªãp tim TB: ${activity.average_heartrate ? `${activity.average_heartrate.toFixed(0)} bpm` : 'N/A'}</p>
                    <p>ƒê·ªô cao tƒÉng: ${formatElevationGain(activity.total_elevation_gain)}</p>
                    ${activity.strava_activity_id ? `<button class="btn-primary mt-2 text-sm px-3 py-1 view-map-btn" style="font-weight: bold; text-decoration: underline; background-color: #FC5200; color: white;" data-activity-id="${activity.strava_activity_id}">View on Strava</button>` : ''}
                `;
                detailedRecentActivitiesCards.appendChild(activityCard);
            });

            document.querySelectorAll('#detailed-recent-activities-cards .view-map-btn').forEach(button => {
                button.onclick = (e) => {
                    const activityId = e.target.dataset.activityId;
                    if (activityId) {
                        window.open(`https://www.strava.com/activities/${activityId}`, '_blank');
                    }
                };
            });
        }
        
        /**
         * Converts average speed (m/s) to pace (min/km).
         * @param {number} metersPerSecond - Average speed in meters per second.
         * @returns {string} Formatted pace string (MM:SS /km) or 'N/A'.
         */
        function formatPace(metersPerSecond) {
            if (typeof metersPerSecond !== 'number' || isNaN(metersPerSecond) || metersPerSecond <= 0) return 'N/A';
            // 1 m/s = 3.6 km/h
            // Pace (min/km) = 60 / (speed in km/h)
            // Pace (min/km) = 60 / (metersPerSecond * 3.6)
            const kmPerHour = (metersPerSecond * 3.6); 
            if (kmPerHour === 0) return 'N/A'; // Avoid division by zero
            const minutesPerKm = 60 / kmPerHour; 
            const minutes = Math.floor(minutesPerKm);
            const seconds = Math.round((minutesPerKm - minutes) * 60);
            return `${minutes}:${String(seconds).padStart(2, '0')} /km`;
        }

        /**
         * Formats elevation gain in meters.
         * @param {number} meters - Elevation in meters.
         * @returns {string} Formatted string (e.g., "150 m").
         */
        function formatElevationGain(meters) {
            if (typeof meters !== 'number' || isNaN(meters)) return 'N/A';
            return `${meters.toFixed(0)} m`;
        }


        // --- Supabase App Authentication Functions ---

      /**
         * Updates the UI based on the current Supabase Authentication state.
         * @param {Object|null} user - The Supabase user object or null if logged out.
         */
        async function updateAppAuthUI(user) {
            // appAuthHeader v√† appAuthToggleIcon ƒë√£ ƒë∆∞·ª£c khai b√°o ·ªü ph·∫°m vi to√†n c·ª•c ho·∫∑c trong window.onload.
            // Kh√¥ng c·∫ßn ph·∫£i l·∫•y l·∫°i ·ªü ƒë√¢y n·∫øu ch√∫ng ƒë√£ c√≥ s·∫µn.

            if (user) {
                currentAppUserId = user.id;
                appUserStatus.textContent = `ƒê√£ ƒëƒÉng nh·∫≠p: ${user.email || 'Kh√°ch'}`;
                currentAppUserEmail.textContent = user.email || 'Kh√°ch';
                loggedOutView.classList.add('hidden');
                loggedInView.classList.remove('hidden');
                
                // Khi ng∆∞·ªùi d√πng ƒê√É ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng:
                // 1. Hi·ªÉn th·ªã t·∫•t c·∫£ c√°c section n·ªôi dung ch√≠nh (kh√¥ng li√™n quan ƒë·∫øn c√†i ƒë·∫∑t)
                if (dataSectionPart1) dataSectionPart1.classList.remove('hidden');
                if (dataSectionPart2) dataSectionPart2.classList.remove('hidden');
                if (statsSection) statsSection.classList.remove('hidden');
                if (detailedStatsSection) detailedStatsSection.classList.remove('hidden');
                if (instructionSection) instructionSection.classList.remove('hidden');
                if (llmAnalysisSection) llmAnalysisSection.classList.remove('hidden');

                // 2. ƒê·∫£m b·∫£o c√°c section c√†i ƒë·∫∑t c≈©ng ƒë∆∞·ª£c lo·∫°i b·ªè l·ªõp 'hidden' ·ªû ƒê√ÇY.
                // Tr·∫°ng th√°i cu·ªëi c√πng c·ªßa ch√∫ng (·∫©n hay hi·ªán) s·∫Ω ƒë∆∞·ª£c quy·∫øt ƒë·ªãnh b·ªüi
                // checkStravaAuthState() v√† h√†m applySettingsVisibility() sau ƒë√≥.
                if (appAuthSection) appAuthSection.classList.remove('hidden');
                if (credentialManagementSection) credentialManagementSection.classList.remove('hidden');
                if (stravaAuthSection) stravaAuthSection.classList.remove('hidden');

                // 3. Th·ª±c hi·ªán c√°c thao t√°c t·∫£i d·ªØ li·ªáu v√† c·∫≠p nh·∫≠t UI kh√°c
                // (Gi·ªØ nguy√™n c√°c d√≤ng n√†y t·ª´ m√£ c·ªßa b·∫°n)
                // C√°c section con b√™n trong (nh∆∞ dataSectionPart1Content, v.v.) s·∫Ω ƒë∆∞·ª£c thu g·ªçn m·∫∑c ƒë·ªãnh
                // ho·∫∑c theo tr·∫°ng th√°i ri√™ng c·ªßa ch√∫ng khi ch√∫ng ƒë∆∞·ª£c hi·ªÉn th·ªã.
                toggleCollapsible(credentialManagementContent, credentialManagementSection.querySelector('.toggle-icon'), true);
                toggleCollapsible(stravaAuthContent, stravaAuthSection.querySelector('.toggle-icon'), true);
                toggleCollapsible(dataSectionPart1Content, dataSectionPart1.querySelector('.toggle-icon'), true);
                toggleCollapsible(dataSectionPart2Content, dataSectionPart2.querySelector('.toggle-icon'), true);
                toggleCollapsible(detailedStatsContent, detailedStatsSection.querySelector('.toggle-icon'), true);
                toggleCollapsible(statsContent, statsSection.querySelector('.toggle-icon'), true);

                await fetchAndSetRunnerCredentials(); // T·∫£i d·ªØ li·ªáu runner
                await renderCredentialsUI(); // Render danh s√°ch runner
                await checkStravaAuthState(); // KI·ªÇM TRA TR·∫†NG TH√ÅI STRAVA V√Ä √ÅP D·ª§NG HI·ªÇN TH·ªä C√ÄI ƒê·∫∂T T·∫†I ƒê√ÇY
                populateRunnerStatsFilter();
                populateDownloadRunnerSelect();
                populateRunnerRecentActivitiesFilter();
                populateClubDropdowns();

            } else {
                currentAppUserId = null;
                appUserStatus.textContent = 'Ch∆∞a ƒëƒÉng nh·∫≠p';
                loggedOutView.classList.remove('hidden');
                loggedInView.classList.add('hidden');

                // Khi ng∆∞·ªùi d√πng CH∆ØA ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng:
                // 1. ·∫®n t·∫•t c·∫£ c√°c section n·ªôi dung ch√≠nh
                if (dataSectionPart1) dataSectionPart1.classList.add('hidden');
                if (dataSectionPart2) dataSectionPart2.classList.add('hidden');
                if (statsSection) statsSection.classList.add('hidden');
                if (detailedStatsSection) detailedStatsSection.classList.add('hidden');
                if (instructionSection) instructionSection.classList.add('hidden');
                if (llmAnalysisSection) llmAnalysisSection.classList.add('hidden');

                // 2. Section "ƒêƒÉng nh·∫≠p/ƒêƒÉng k√Ω ·ª®ng d·ª•ng" (appAuthSection) lu√¥n hi·ªÉn th·ªã.
                // C√°c section c√†i ƒë·∫∑t kh√°c (Credential Management, Strava Auth) s·∫Ω b·ªã ·∫©n.
                if (appAuthSection) appAuthSection.classList.remove('hidden');
                if (credentialManagementSection) credentialManagementSection.classList.add('hidden');
                if (stravaAuthSection) stravaAuthSection.classList.add('hidden');

                // 3. X√≥a tr·∫°ng th√°i phi√™n Strava v√† reset UI li√™n quan
                clearStravaSession(); 
                await fetchAndSetRunnerCredentials(); 
                await renderCredentialsUI();
                // Kh√¥ng c·∫ßn g·ªçi checkStravaAuthState() ·ªü ƒë√¢y v√¨ kh√¥ng c√≥ app user,
                // v√† c√°c section li√™n quan ƒë·∫øn Strava Auth ƒë√£ b·ªã ·∫©n ·ªü tr√™n.
                populateRunnerStatsFilter();
                populateDownloadRunnerSelect();
                populateRunnerRecentActivitiesFilter();
                populateClubDropdowns();

                // 4. ƒê·∫∑t tr·∫°ng th√°i ban ƒë·∫ßu c·ªßa n√∫t c√†i ƒë·∫∑t v√† c√°c section c√†i ƒë·∫∑t khi ƒêƒÇNG XU·∫§T.
                // M·∫∑c ƒë·ªãnh cho ph√©p hi·ªÉn th·ªã c√°c ph·∫ßn c√†i ƒë·∫∑t ƒë·ªÉ ng∆∞·ªùi d√πng c√≥ th·ªÉ ƒëƒÉng nh·∫≠p.
                // Tr·∫°ng th√°i n√†y s·∫Ω l∆∞u v√†o localStorage l√† "true" v√† n√∫t s·∫Ω ghi "·∫®n c√†i ƒë·∫∑t".
                applySettingsVisibility(true);
                
                // Quan tr·ªçng: Tho√°t s·ªõm kh·ªèi h√†m n·∫øu kh√¥ng c√≥ ng∆∞·ªùi d√πng ·ª©ng d·ª•ng ƒë·ªÉ tr√°nh
                // checkStravaAuthState() ch·∫°y v·ªõi tr·∫°ng th√°i kh√¥ng mong mu·ªën ho·∫∑c g√¢y l·ªói.
                return; 
            }
            // L∆ØU √ù: L·ªùi g·ªçi applySettingsVisibility() cu·ªëi c√πng ƒë√£ ƒë∆∞·ª£c lo·∫°i b·ªè kh·ªèi ƒë√¢y.
            // Quy·∫øt ƒë·ªãnh cu·ªëi c√πng v·ªÅ vi·ªác hi·ªÉn th·ªã/·∫©n c√°c section c√†i ƒë·∫∑t s·∫Ω ƒë∆∞·ª£c ƒë∆∞a ra b·ªüi
            // checkStravaAuthState() (khi ƒë√£ ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng) ho·∫∑c b·ªüi applySettingsVisibility(true)
            // (khi ch∆∞a ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng).
        }
        
        

        /**
         * Handles user sign-up or sign-in.
         * @param {Event} event - Form submission event.
         */
        async function handleAuth(event) {
            event.preventDefault();
            authMessage.textContent = '';
            const email = authEmailInput.value.trim();
            const password = authPasswordInput.value.trim();

            if (!email || !password) {
                showAlert('Vui l√≤ng nh·∫≠p Email v√† M·∫≠t kh·∫©u.');
                return;
            }

            try {
                if (event.submitter.id === 'signup-btn') {
                    const { data, error } = await supabaseClientInstance.auth.signUp({ email, password });
                    if (error) throw error;
                    showAlert('ƒêƒÉng k√Ω th√†nh c√¥ng! Vui l√≤ng ki·ªÉm tra email c·ªßa b·∫°n ƒë·ªÉ x√°c nh·∫≠n.');
                    authMessage.textContent = 'ƒêƒÉng k√Ω th√†nh c√¥ng! Vui l√≤ng ki·ªÉm tra email c·ªßa b·∫°n ƒë·ªÉ x√°c nh·∫≠n.';
                } else if (event.submitter.id === 'signin-btn') {
                    const { data, error } = await supabaseClientInstance.auth.signInWithPassword({ email, password });
                    if (error) throw error;
                    showAlert('ƒêƒÉng nh·∫≠p th√†nh c√¥ng!');
                    authMessage.textContent = ''; // Clear message on success
                }
            } catch (error) {
                console.error('L·ªói x√°c th·ª±c ·ª©ng d·ª•ng:', error.message);
                authMessage.textContent = `L·ªói: ${error.message}`;
                showAlert(`L·ªói x√°c th·ª±c: ${error.message}`);
            }
        }

        /**
         * Handles guest login (anonymous sign-in with Supabase).
         */
        async function handleGuestLogin() {
            try {
                const { data, error } = await supabaseClientInstance.auth.signInAnonymously();
                if (error) throw error;
                showAlert('ƒêƒÉng nh·∫≠p v·ªõi t∆∞ c√°ch Kh√°ch th√†nh c√¥ng!');
                authMessage.textContent = ''; // Clear message on success
            } catch (error) {
                console.error('L·ªói ƒëƒÉng nh·∫≠p kh√°ch:', error.message);
                authMessage.textContent = `L·ªói ƒëƒÉng nh·∫≠p kh√°ch: ${error.message}`;
                showAlert(`L·ªói ƒëƒÉng nh·∫≠p kh√°ch: ${error.message}`);
            }
        }

        /**
         * Handles user sign-out from the application.
         */
        async function handleSignOut() {
            try {
                const { error } = await supabaseClientInstance.auth.signOut();
                if (error) throw error;
                showAlert('ƒêƒÉng xu·∫•t ·ª©ng d·ª•ng th√†nh c√¥ng!');
                authMessage.textContent = ''; // Clear message on success
                clearStravaSession(); // Clear Strava session on app logout
                updateAppAuthUI(null); // Update UI to logged-out state
            } catch (error) {
                console.error('L·ªói ƒëƒÉng xu·∫•t ·ª©ng d·ª•ng:', error.message);
                showAlert(`L·ªói ƒëƒÉng xu·∫•t: ${error.message}`);
            }
        }


        // --- Credential Management Functions ---

        /**
         * Fetches runner credentials from Supabase and updates the global `allRunnerCredentials` array.
         */
        async function fetchAndSetRunnerCredentials() {
            if (!currentAppUserId) {
                allRunnerCredentials = []; // Clear global state if no app user
                console.log('fetchAndSetRunnerCredentials: No app user, clearing credentials.');
                return;
            }
            console.log('fetchAndSetRunnerCredentials: Attempting to fetch credentials for user:', currentAppUserId);
            loadingCredentials.classList.remove('hidden'); // Show loading state
            errorCredentials.classList.add('hidden'); // Hide previous errors
            try {
                const { data, error } = await supabaseClientInstance
                    .from('runner_credentials')
                    .select('*')
                   .order('runner_name', { ascending: true });
                if (error) throw error;
                allRunnerCredentials = data; // Update global variable
                console.log('fetchAndSetRunnerCredentials: Successfully fetched', data.length, 'credentials.');
            } catch (error) {
                console.error('Error fetching runner credentials:', error.message);
                errorCredentials.textContent = `L·ªói: ${error.message}`;
                errorCredentials.classList.remove('hidden');
                showAlert(`L·ªói khi t·∫£i th√¥ng tin runner: ${error.message}`);
                allRunnerCredentials = []; // Clear on error too
            } finally {
                loadingCredentials.classList.add('hidden'); // Hide loading state
            }
        }

        /**
         * Renders the runner credentials from the global `allRunnerCredentials` array into the UI.
         */
        async function renderCredentialsUI() {
            credentialsList.innerHTML = ''; // Always clear before rendering
            noCredentialsMessage.classList.add('hidden');
            runnerSelect.innerHTML = '<option value="">-- Ch·ªçn Runner --</option>'; // Clear existing options
            downloadRunnerSelect.innerHTML = '<option value="">-- Ch·ªçn Runner --</option>'; // Clear for new select
            runnerRecentActivitiesFilter.innerHTML = '<option value="all">T·∫•t c·∫£ Runner</option>'; // NEW: Clear for new select

            if (allRunnerCredentials.length === 0) {
                noCredentialsMessage.classList.remove('hidden');
                toggleCollapsible(credentialManagementContent, credentialManagementSection.querySelector('.toggle-icon'), false); // Expand if empty
            } else {
                noCredentialsMessage.classList.add('hidden');
                // Filter credentials to display only those owned by the current app user
                const ownedCredentials = allRunnerCredentials.filter(cred => cred.owner_uid === currentAppUserId);

                if (ownedCredentials.length === 0) {
                    noCredentialsMessage.classList.remove('hidden');
                    toggleCollapsible(credentialManagementContent, credentialManagementSection.querySelector('.toggle-icon'), false); // Expand if no owned credentials
                } else {
                    toggleCollapsible(credentialManagementContent, credentialManagementSection.querySelector('.toggle-icon'), true); // Collapse if there are owned credentials

                    ownedCredentials.forEach(cred => { // Loop through filtered (owned) credentials
                        const credDiv = document.createElement('div');
                        credDiv.className = 'bg-gray-50 p-4 rounded-lg border border-gray-200 flex flex-col sm:flex-row justify-between items-start sm:items-center gap-3';
                        
                        // Conditionally render Edit/Delete buttons (already ensured by owner_uid filter above)
                        const ownerButtons = `
                            <div class="flex flex-row gap-2 mt-2 sm:mt-0">
                                <button class="btn-primary btn-edit" data-id="${cred.id}">S·ª≠a</button>
                                <button class="btn-danger btn-delete" data-id="${cred.id}">X√≥a</button>
                            </div>
                        `;

                        credDiv.innerHTML = `
                            <div>
                                <p class="text-lg font-semibold text-gray-800">${cred.runner_name}</p>
                                ${cred.athlete_id ? `<p class="text-sm text-gray-600">Strava Athlete ID: <span class="font-mono">${cred.athlete_id}</span></p>` : `<p class="text-sm text-gray-600 text-red-500">Ch∆∞a k·∫øt n·ªëi Strava</p>`}
                            </div>
                            ${ownerButtons}
                        `;
                        credentialsList.appendChild(credDiv);
                    });
                }

                // Populate runner select dropdowns (these should still include ALL runners with athlete_id, owned by current user for data display)
                allRunnerCredentials.filter(cred => cred.owner_uid === currentAppUserId).forEach(cred => {
                    const option = document.createElement('option');
                    option.value = cred.id; // Use the Supabase credential ID as the value
                    option.textContent = cred.runner_name;
                    option.dataset.redirectUri = cred.redirect_uri; 
                    option.dataset.athleteId = cred.athlete_id || ''; 
                    runnerSelect.appendChild(option.cloneNode(true)); 
                    downloadRunnerSelect.appendChild(option.cloneNode(true)); 
                    
                    if (cred.athlete_id) { // Only add to recent activities filter if connected to Strava
                        const recentFilterOption = document.createElement('option');
                        recentFilterOption.value = String(cred.athlete_id);
                        recentFilterOption.textContent = cred.runner_name;
                        runnerRecentActivitiesFilter.appendChild(recentFilterOption);
                    }
                });
                
                document.querySelectorAll('.btn-edit').forEach(button => {
                    button.onclick = (e) => openCredentialModal(e.target.dataset.id);
                });
                document.querySelectorAll('.btn-delete').forEach(button => {
                    button.onclick = async (e) => {
                        const confirmed = await showConfirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a th√¥ng tin ƒëƒÉng nh·∫≠p n√†y kh√¥ng?'); // Using custom confirm
                        if (confirmed) {
                            await deleteCredential(e.target.dataset.id);
                        }
                    };
                });
            }
        }

        /**
         * Opens the modal for adding or editing runner credentials.
         * @param {string|null} id - ID of the credential to edit, or null for new.
         */
        async function openCredentialModal(id = null) {
            credentialForm.reset();
            credentialIdInput.value = '';
            modalTitle.textContent = 'Th√™m Runner m·ªõi'; 
            runnerNameInput.readOnly = false; // Ensure it's editable for new runner

            // Set default redirect URI to the fixed value
            redirectUriInput.value = APP_STRAVA_REDIRECT_URI; 

            // Populate clubs dropdown before setting value for edit mode
            await fetchClubs(); // Ensure clubs are loaded
            populateClubDropdowns(); // Populate the runnerTeamSelect

            if (id) {
                modalTitle.textContent = 'S·ª≠a th√¥ng tin Runner'; 
                try {
                    // Fetch all relevant columns for editing
                    const { data, error } = await supabaseClientInstance
                        .from('runner_credentials')
                        .select('runner_name, id, full_name, phone_number, runner_email, date_of_birth, weight_kg, shirt_size, running_team, gender')
                        .eq('id', id)
                        .single();

                    if (error) throw error;

                    runnerNameInput.value = data.runner_name;
                    document.getElementById('runner-full-name').value = data.full_name || '';
                    document.getElementById('runner-phone-number').value = data.phone_number || '';
                    document.getElementById('runner-email').value = data.runner_email || '';
                    document.getElementById('runner-date-of-birth').value = data.date_of_birth ? data.date_of-birth.split('T')[0] : ''; // Format for date input
                    document.getElementById('runner-weight-kg').value = data.weight_kg || '';
                    document.getElementById('runner-shirt-size').value = data.shirt_size || '';
                    runnerTeamSelect.value = data.running_team || ''; // Set value for the select
                    document.getElementById('runner-gender').value = data.gender || '';

                    credentialIdInput.value = data.id;
                    runnerNameInput.readOnly = false; // Make sure it's editable
                } catch (error) {
                    console.error('L·ªói khi l·∫•y th√¥ng tin ƒëƒÉng nh·∫≠p ƒë·ªÉ ch·ªânh s·ª≠a:', error.message);
                    showAlert(`L·ªói khi t·∫£i chi ti·∫øt runner: ${error.message}. B·∫°n ch·ªâ c√≥ th·ªÉ s·ª≠a runner c·ªßa m√¨nh.`);
                }
            }
            credentialModal.style.display = 'flex';
        }

        /**
         * Saves (adds or updates) runner credentials to Supabase.
         * For new runners, it initiates the Strava OAuth flow.
         * For existing runners, it only updates the name and other details.
         * @param {Event} event - Form submission event.
         */
        async function saveCredential(event) {
            event.preventDefault();

            if (!currentAppUserId) {
                showAlert('L·ªói: B·∫°n ph·∫£i ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng ƒë·ªÉ th√™m ho·∫∑c s·ª≠a Runner.');
                console.error('Attempted to save credential but app user is not authenticated.');
                return;
            }

            const id = credentialIdInput.value;
            const runnerName = runnerNameInput.value.trim();
            const redirectUri = redirectUriInput.value; // Use the fixed value

            // Get new field values
            const fullName = document.getElementById('runner-full-name').value.trim();
            const phoneNumber = document.getElementById('runner-phone-number').value.trim();
            const runnerEmail = document.getElementById('runner-email').value.trim();
            const dateOfBirth = document.getElementById('runner-date-of-birth').value; //YYYY-MM-DD format
            const weightKg = parseFloat(document.getElementById('runner-weight-kg').value);
            const shirtSize = document.getElementById('runner-shirt-size').value;
            const runningTeam = runnerTeamSelect.value; // Get value from the select dropdown
            const gender = document.getElementById('runner-gender').value;


            if (!runnerName) {
                showAlert('Vui l√≤ng nh·∫≠p T√™n Runner.');
                return;
            }
            // Validate new required fields
            if (!runnerEmail || !gender || !runningTeam) {
                showAlert('Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß Email Runner, Gi·ªõi t√≠nh v√† ƒê·ªôi ch·∫°y.');
                return;
            }


            try {
                if (id) {
                    // This is an EDIT operation (update existing runner details)
                    const { error: updateError } = await supabaseClientInstance
                        .from('runner_credentials')
                        .update({ 
                            runner_name: runnerName, 
                            full_name: fullName,
                            phone_number: phoneNumber,
                            runner_email: runnerEmail,
                            date_of_birth: dateOfBirth || null, // Allow null if not provided
                            weight_kg: isNaN(weightKg) ? null : weightKg, // Allow null if not a valid number
                            shirt_size: shirtSize || null, // Allow null if not selected
                            running_team: runningTeam,
                            gender: gender,
                        })
                        .eq('id', id)
                        .eq('owner_uid', currentAppUserId); // Ensure only owner can update

                    if (updateError) throw updateError;
                    showAlert('C·∫≠p nh·∫≠t th√¥ng tin runner th√†nh c√¥ng!');

                } else {
                    // This is an ADD operation (new runner, initiate OAuth)
                    // First, save a placeholder runner_credential in DB with name and owner_uid
                    // We need this ID to pass to the OAuth callback
                    const { data: insertData, error: insertError } = await supabaseClientInstance
                        .from('runner_credentials')
                        .insert([{
                            runner_name: runnerName,
                            owner_uid: currentAppUserId,
                            redirect_uri: redirectUri, // Save redirect_uri for consistent callback
                            full_name: fullName,
                            phone_number: phoneNumber,
                            runner_email: runnerEmail,
                            date_of_birth: dateOfBirth || null, 
                            weight_kg: isNaN(weightKg) ? null : weightKg, 
                            shirt_size: shirtSize || null, 
                            running_team: runningTeam,
                            gender: gender,
                            // access_token, refresh_token, athlete_id, expires_at will be null initially
                            // and populated by the strava-oauth-callback Edge Function
                        }])
                        .select('id') // Select the ID of the newly inserted row
                        .single();

                    if (insertError) throw insertError;
                    const newRunnerCredentialId = insertData.id;

                    showAlert('Th√™m Runner th√†nh c√¥ng! Chuy·ªÉn h∆∞·ªõng ƒë·∫øn Strava ƒë·ªÉ ·ªßy quy·ªÅn...');
                    credentialModal.style.display = 'none'; // Close modal immediately

                    // Store the newly created credential ID for the OAuth callback
                    localStorage.setItem('strava_runner_credential_id_pending', newRunnerCredentialId);
                    localStorage.setItem('strava_runner_name_pending', runnerName);

                    // Redirect to Strava for OAuth authorization using the APP's Client ID
                    const scope = 'activity:read_all';
                    const state = encodeURIComponent(JSON.stringify({ 
                        credentialId: newRunnerCredentialId // Pass the newly created DB ID
                    }));
                    const authUrl = `https://www.strava.com/oauth/authorize?client_id=${APP_STRAVA_CLIENT_ID}&response_type=code&redirect_uri=${encodeURIComponent(APP_STRAVA_REDIRECT_URI)}&approval_prompt=auto&scope=${scope}&state=${state}`;
                    
                    window.location.href = authUrl;
                    return; // Exit function after redirect
                }

                credentialModal.style.display = 'none';
                await fetchAndSetRunnerCredentials(); // Refresh the list data
                await renderCredentialsUI(); // Refresh the list UI
                populateRunnerStatsFilter(); // Refresh runner stats filter as well
                populateDownloadRunnerSelect(); // Refresh the new download runner select
                populateRunnerRecentActivitiesFilter(); // NEW: Refresh runner filter for recent activities
                checkStravaAuthState(); // Re-check Strava auth status to ensure UI is consistent
            } catch (error) {
                console.error('L·ªói khi l∆∞u th√¥ng tin ƒëƒÉng nh·∫≠p runner:', error.message);
                showAlert(`L·ªói khi l∆∞u th√¥ng tin runner: ${error.message}`);
            }
        }

        /**
         * Deletes a runner credential from Supabase.
         * @param {string} id - ID of the credential to delete.
         */
        async function deleteCredential(id) {
            if (!currentAppUserId) {
                showAlert('L·ªói: B·∫°n ph·∫£i ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng ƒë·ªÉ x√≥a Runner.');
                return;
            }
            try {
                const { error } = await supabaseClientInstance
                    .from('runner_credentials')
                    .delete()
                    .eq('id', id)
                    .eq('owner_uid', currentAppUserId); // Ensure only owner can delete
            
                if (error) throw error;

                showAlert('X√≥a th√¥ng tin runner th√†nh c√¥ng!');
                // If the deleted runner was the current logged-in one, log out
                if (currentRunnerCredentialId === id) {
                    clearStravaSession();
                    checkStravaAuthState(); // Reset Strava auth UI
                }
                await fetchAndSetRunnerCredentials(); // Refresh the list data
                await renderCredentialsUI(); // Refresh the list UI
                populateRunnerStatsFilter(); // Refresh runner stats filter as well
                populateDownloadRunnerSelect(); // Refresh the new download runner select
                populateRunnerRecentActivitiesFilter(); // NEW: Refresh runner filter for recent activities
            } catch (error) {
                console.error('L·ªói khi x√≥a th√¥ng tin ƒëƒÉng nh·∫≠p runner:', error.message);
                showAlert(`L·ªói khi x√≥a th√¥ng tin runner: ${error.message}`);
            }
        }


        // --- Strava Authentication & API Interaction ---

      /**
         * Checks the current Strava authentication status from localStorage and updates the UI.
         */
        async function checkStravaAuthState() {
            // This function confirms that saving the session to localStorage works as requested.
            currentRunnerCredentialId = localStorage.getItem('strava_runner_credential_id'); 
            isAuthenticated = localStorage.getItem('strava_authenticated') === 'true';
            currentAthleteId = localStorage.getItem('strava_athlete_id');
            currentRunnerName = localStorage.getItem('strava_runner_name');

            console.log('checkStravaAuthState - Checking Strava auth state from localStorage...');
            console.log('  isAuthenticated (Strava):', isAuthenticated);
            console.log('  currentRunnerCredentialId (Credential ID):', currentRunnerCredentialId);
            console.log('  currentAthleteId (Strava ID):', currentAthleteId);
            console.log('  currentRunnerName:', currentRunnerName);

            // C√°c bi·∫øn stravaAuthHeader v√† stravaAuthToggleIcon kh√¥ng c·∫ßn thi·∫øt ·ªü ƒë√¢y n·ªØa
            // v√¨ vi·ªác ·∫©n/hi·ªán to√†n b·ªô section cha s·∫Ω ƒë∆∞·ª£c qu·∫£n l√Ω b·ªüi applySettingsVisibility.

            if (isAuthenticated && currentRunnerCredentialId && currentAthleteId && currentRunnerName) {
                // ƒê·∫£m b·∫£o d·ªØ li·ªáu runner v√† clubs ƒë∆∞·ª£c t·∫£i v√† UI ƒë∆∞·ª£c c·∫≠p nh·∫≠t
                await fetchAndSetRunnerCredentials();
                await renderCredentialsUI(); 
                await fetchClubs();
                populateClubDropdowns();

                const expiresAt = localStorage.getItem('strava_expires_at');
                const now = Date.now();

                if (expiresAt && now < parseInt(expiresAt, 10)) {
                    // Tr·∫°ng th√°i: ƒê√£ ƒëƒÉng nh·∫≠p Strava th√†nh c√¥ng v√† token h·ª£p l·ªá
                    console.log('  Valid Strava token found. Logged into Strava.');
                    authStatus.textContent = 'ƒê√£ ƒëƒÉng nh·∫≠p v·ªõi Strava.';
                    currentRunnerNameSpan.textContent = currentRunnerName;
                    currentRunnerDisplay.classList.remove('hidden');
                    connectStravaBtn.style.display = 'none'; // ·∫®n n√∫t "Connect with Strava"
                    disconnectStravaBtn.classList.remove('hidden'); // Hi·ªÉn th·ªã n√∫t "ƒêƒÉng xu·∫•t Strava"
                    
                    // Hi·ªÉn th·ªã c√°c section n·ªôi dung ch√≠nh (ph·∫ßn n√†y ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω trong updateAppAuthUI)
                    // dataSectionPart1.classList.remove('hidden'); 
                    // dataSectionPart2.classList.remove('hidden'); 
                    // statsSection.classList.remove('hidden');
                    // detailedStatsSection.classList.remove('hidden'); 
                    // instructionSection.classList.remove('hidden'); 
                    // llmAnalysisSection.classList.remove('hidden'); 
                    userInfo.textContent = `Ch√†o m·ª´ng, Runner: ${currentRunnerName} (Strava ID: ${currentAthleteId})`; 
                    
                    // ·∫®N C√ÅC SECTION C√ÄI ƒê·∫∂T v√† ƒë·∫∑t n√∫t "Hi·ªán c√†i ƒë·∫∑t"
                    applySettingsVisibility(false); 

                } else {
                    // Tr·∫°ng th√°i: ƒê√£ ƒëƒÉng nh·∫≠p Strava nh∆∞ng token h·∫øt h·∫°n/kh√¥ng h·ª£p l·ªá
                    console.log('  Strava token has expired or is missing. Re-authentication may be needed.');
                    authStatus.textContent = 'Token Strava ƒë√£ h·∫øt h·∫°n, vui l√≤ng l√†m m·ªõi ho·∫∑c ƒëƒÉng nh·∫≠p l·∫°i.';
                    showAlert('Phi√™n Strava ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ƒëƒÉng xu·∫•t v√† ch·ªçn l·∫°i Runner ƒë·ªÉ k·∫øt n·ªëi.');
                    clearStravaSession(); // X√≥a phi√™n Strava c≈©
                    // KH√îNG G·ªåI checkStravaAuthState() ƒë·ªá quy ·ªü ƒë√¢y ƒë·ªÉ tr√°nh l·∫∑p v√¥ h·∫°n.
                    // Ch√∫ng ta s·∫Ω ƒë·∫∑t tr·∫°ng th√°i UI ngay l·∫≠p t·ª©c.
                    
                    // HI·ªÇN TH·ªä C√ÅC SECTION C√ÄI ƒê·∫∂T v√† ƒë·∫∑t n√∫t "·∫®n c√†i ƒë·∫∑t" (ƒë·ªÉ ng∆∞·ªùi d√πng c√≥ th·ªÉ k·∫øt n·ªëi l·∫°i)
                    applySettingsVisibility(true);

                    // Reset UI cho tr·∫°ng th√°i ch∆∞a ƒëƒÉng nh·∫≠p Strava
                    currentRunnerDisplay.classList.add('hidden');
                    connectStravaBtn.style.display = 'block'; 
                    disconnectStravaBtn.classList.add('hidden');
                    userInfo.textContent = ''; 
                    recentActivitiesContainer.innerHTML = '<div class="card p-4 text-gray-500 text-center col-span-full">Nh·∫•n "T·∫£i ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y" ƒë·ªÉ xem.</div>';
                    document.getElementById('bubble-chart-container').innerHTML = '<p class="text-gray-500 text-center">Nh·∫•n "Xem th·ªëng k√™ theo tu·∫ßn" ƒë·ªÉ hi·ªÉn th·ªã bi·ªÉu ƒë·ªì.</p>';
                    const table = document.getElementById('detailed-stats-table');
                    Array.from(table.children).forEach(child => {
                        if (child.tagName === 'TBODY') { 
                            table.removeChild(child);
                        }
                    });
                    const newTbody = document.createElement('tbody');
                    table.appendChild(newTbody);
                    detailedStatsStatus.textContent = 'Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã.';
                }
            } else {
                // Tr·∫°ng th√°i: Ch∆∞a ƒëƒÉng nh·∫≠p Strava ho·∫∑c kh√¥ng c√≥ th√¥ng tin phi√™n
                console.log('  Not logged into Strava or session info is missing.');
                clearStravaSession(); // ƒê·∫£m b·∫£o x√≥a m·ªçi th·ª© li√™n quan ƒë·∫øn Strava
                
                // T·∫£i l·∫°i c√°c th√¥ng tin runner v√† club (lu√¥n c·∫ßn thi·∫øt)
                await fetchAndSetRunnerCredentials(); 
                await renderCredentialsUI();
                await fetchClubs(); 
                populateClubDropdowns(); 

                authStatus.textContent = 'Vui l√≤ng ch·ªçn Runner v√† ƒëƒÉng nh·∫≠p v·ªõi Strava.';
                currentRunnerDisplay.classList.add('hidden');
                connectStravaBtn.style.display = 'block'; // Hi·ªÉn th·ªã n√∫t "Connect with Strava"
                disconnectStravaBtn.classList.add('hidden'); // ·∫®n n√∫t "ƒêƒÉng xu·∫•t Strava"
                
                // ·∫®n c√°c section n·ªôi dung ch√≠nh (ph·∫ßn n√†y ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω trong updateAppAuthUI)
                // dataSectionPart1.classList.add('hidden'); 
                // dataSectionPart2.classList.add('hidden'); 
                // statsSection.classList.add('hidden');
                // detailedStatsSection.classList.add('hidden'); 
                // instructionSection.classList.add('hidden'); 
                // llmAnalysisSection.classList.add('hidden'); 
                userInfo.textContent = ''; 
                recentActivitiesContainer.innerHTML = '<div class="card p-4 text-gray-500 text-center col-span-full">Nh·∫•n "T·∫£i ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y" ƒë·ªÉ xem.</div>';
                document.getElementById('bubble-chart-container').innerHTML = '<p class="text-gray-500 text-center">Nh·∫•n "Xem th·ªëng k√™ theo tu·∫ßn" ƒë·ªÉ hi·ªÉn th·ªã bi·ªÉu ƒë·ªì.</p>';
                const table = document.getElementById('detailed-stats-table');
                Array.from(table.children).forEach(child => {
                    if (child.tagName === 'TBODY') { 
                        table.removeChild(child);
                    }
                });
                const newTbody = document.createElement('tbody');
                table.appendChild(newTbody);
                detailedStatsStatus.textContent = 'Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã.';

                // HI·ªÇN TH·ªä C√ÅC SECTION C√ÄI ƒê·∫∂T v√† ƒë·∫∑t n√∫t "·∫®n c√†i ƒë·∫∑t"
                applySettingsVisibility(true);
            }
        }
        /**
         * Clears all Strava session data from local storage.
         * This logs the user out of Strava within the app.
         */
        function clearStravaSession() {
            console.log('clearStravaSession - Removing Strava session data from localStorage.');
            localStorage.removeItem('strava_access_token');
            localStorage.removeItem('strava_refresh_token');
            localStorage.removeItem('strava_expires_at');
            localStorage.removeItem('strava_athlete_id');
            localStorage.removeItem('strava_runner_name');
            localStorage.removeItem('strava_runner_credential_id');
            localStorage.removeItem('strava_authenticated');
            localStorage.removeItem('strava_runner_credential_id_pending');
            localStorage.removeItem('strava_runner_name_pending');
        }

        /**
         * Initiates the Strava OAuth authorization flow.
         */
        connectStravaBtn.addEventListener('click', async () => {
            if (!currentAppUserId) {
                showAlert('L·ªói: B·∫°n ph·∫£i ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng ƒë·ªÉ k·∫øt n·ªëi v·ªõi Strava.');
                return;
            }

            const selectedOption = runnerSelect.options[runnerSelect.selectedIndex];
            if (!selectedOption || !selectedOption.value) {
                showAlert('Vui l√≤ng ch·ªçn m·ªôt Runner t·ª´ danh s√°ch ƒë·ªÉ ƒëƒÉng nh·∫≠p Strava.');
                return;
            }

            const credentialId = selectedOption.value; // Supabase runner_credential ID (UUID)
            const runnerName = selectedOption.textContent;

            const selectedRunner = allRunnerCredentials.find(cred => cred.id === credentialId);
            if (selectedRunner && selectedRunner.athlete_id) {
                const confirmed = await showConfirm(`Runner "${runnerName}" ƒë√£ ƒë∆∞·ª£c k·∫øt n·ªëi v·ªõi Strava (ID: ${selectedRunner.athlete_id}). B·∫°n c√≥ mu·ªën k·∫øt n·ªëi l·∫°i kh√¥ng? ƒêi·ªÅu n√†y s·∫Ω c·∫≠p nh·∫≠t token m·ªõi.`);
                if (!confirmed) {
                    return; // User cancelled
                }
            }

            localStorage.setItem('strava_runner_credential_id_pending', credentialId);
            localStorage.setItem('strava_runner_name_pending', runnerName);
            
            const scope = 'activity:read_all';
            const state = encodeURIComponent(JSON.stringify({ 
                credentialId: credentialId
            }));

            const authUrl = `https://www.strava.com/oauth/authorize?client_id=${APP_STRAVA_CLIENT_ID}&response_type=code&redirect_uri=${encodeURIComponent(APP_STRAVA_REDIRECT_URI)}&approval_prompt=auto&scope=${scope}&state=${state}`;
            
            window.location.href = authUrl;
        });

        /**
         * Handles the Strava OAuth callback, exchanging code for tokens via Edge Function.
         */
        async function handleStravaCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const stateParam = urlParams.get('state'); 
            const errorParam = urlParams.get('error');

            if (errorParam) {
                showAlert(`L·ªói t·ª´ Strava: ${errorParam}. Vui l√≤ng th·ª≠ l·∫°i.`);
                console.error('Strava OAuth Error:', errorParam);
                window.history.replaceState({}, document.title, window.location.pathname);
                return;
            }

            if (code) { 
                authStatus.textContent = 'ƒêang x·ª≠ l√Ω k·∫øt n·ªëi Strava ...';
                let runnerCredentialId = null;
                let runnerNameForCallback = null;
                let ownerUidForCallback = null;

                if (stateParam) {
                    try {
                        const parsedState = JSON.parse(decodeURIComponent(stateParam));
                        runnerCredentialId = parsedState.credentialId;
                    } catch (e) {
                        console.error('L·ªói gi·∫£i m√£ tham s·ªë "state":', e);
                    }
                }

                if (!runnerCredentialId) {
                    runnerCredentialId = localStorage.getItem('strava_runner_credential_id_pending');
                    if (!runnerCredentialId) {
                        console.error('Kh√¥ng t√¨m th·∫•y runnerCredentialId trong state ho·∫∑c localStorage.');
                        showAlert('L·ªói: Th√¥ng tin phi√™n kh√¥ng h·ª£p l·ªá ho·∫∑c thi·∫øu Runner ID. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i Strava.');
                        window.history.replaceState({}, document.title, window.location.pathname);
                        return;
                    }
                }
                
                runnerNameForCallback = localStorage.getItem('strava_runner_name_pending');
                if (!runnerNameForCallback) {
                     console.error('Kh√¥ng t√¨m th·∫•y runnerName trong localStorage.');
                     const existingRunner = allRunnerCredentials.find(rc => rc.id === runnerCredentialId);
                     if (existingRunner) {
                         runnerNameForCallback = existingRunner.runner_name;
                     } else {
                         showAlert('L·ªói: Kh√¥ng t√¨m th·∫•y t√™n Runner. Vui l√≤ng th·ª≠ l·∫°i qu√° tr√¨nh k·∫øt n·ªëi.');
                         window.history.replaceState({}, document.title, window.location.pathname);
                         return;
                     }
                }

                const { data: { user }, error: authError } = await supabaseClientInstance.auth.getUser();
                if (authError || !user) {
                    showAlert('L·ªói: Kh√¥ng t√¨m th·∫•y phi√™n ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i ·ª©ng d·ª•ng.');
                    console.error('Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng ·ª©ng d·ª•ng khi x·ª≠ l√Ω callback Strava:', authError);
                    window.history.replaceState({}, document.title, window.location.pathname);
                    return;
                }
                ownerUidForCallback = user.id;

                try {
                    console.log(`[Client] Calling strava-oauth-callback Edge Function for runnerCredentialId: ${runnerCredentialId}`);
                    const response = await fetch(STRAVA_OAUTH_CALLBACK_URL, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${(await supabaseClientInstance.auth.getSession()).data.session?.access_token || ''}`
                        },
                        body: JSON.stringify({
                            code: code,
                            runnerCredentialId: runnerCredentialId,
                            client_id: APP_STRAVA_CLIENT_ID,
                            redirect_uri: APP_STRAVA_REDIRECT_URI,
                            runnerName: runnerNameForCallback, 
                            ownerUid: ownerUidForCallback 
                        }),
                    });

                    const result = await response.json();

                    if (response.ok && result.success) {
                        // Store tokens and athlete info from Edge Function response into localStorage
                        localStorage.setItem('strava_access_token', result.access_token);
                        localStorage.setItem('strava_refresh_token', result.refresh_token);
                        localStorage.setItem('strava_expires_at', result.expires_at);
                        localStorage.setItem('strava_athlete_id', result.athlete_id);
                        localStorage.setItem('strava_runner_name', result.runner_name); 
                        localStorage.setItem('strava_runner_credential_id', result.runnerCredentialId); 
                        localStorage.setItem('strava_authenticated', 'true'); 

                        showAlert('ƒêƒÉng nh·∫≠p Strava th√†nh c√¥ng! B·∫°n c√≥ th·ªÉ t·∫£i d·ªØ li·ªáu ho·∫°t ƒë·ªông ngay b√¢y gi·ªù.');
                        window.history.replaceState({}, document.title, window.location.pathname); // Clean URL
                        checkStravaAuthState(); // Update UI
                    } else {
                        console.error('[Client] Error from Edge Function:', result.error);
                        showAlert(`L·ªói ƒëƒÉng nh·∫≠p Strava: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`);
                        clearStravaSession();
                        checkStravaAuthState();
                        window.history.replaceState({}, document.title, window.location.pathname);
                    }
                } catch (err) {
                    console.error('L·ªói khi g·ªçi Edge Function strava-oauth-callback:', err);
                    showAlert(`L·ªói m·∫°ng ho·∫∑c m√°y ch·ªß khi x·ª≠ l√Ω ƒëƒÉng nh·∫≠p Strava: ${err.message}`);
                    clearStravaSession();
                    checkStravaAuthState();
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
            } else {
                console.log('Kh√¥ng c√≥ m√£ ·ªßy quy·ªÅn ho·∫∑c tham s·ªë "state" trong URL. Kh√¥ng c√≥ h√†nh ƒë·ªông n√†o ƒë∆∞·ª£c th·ª±c hi·ªán.');
            }
        }

        /**
         * Disconnects Strava account from the current runner.
         */
        disconnectStravaBtn.addEventListener('click', () => {
            clearStravaSession();
            checkStravaAuthState();
            showAlert('ƒê√£ ƒëƒÉng xu·∫•t Strava.');
        });


        // --- Data Fetching & Management ---

        /**
         * Handles the main "T·∫£i/C·∫≠p nh·∫≠t d·ªØ li·ªáu t·ª´ Strava" button click.
         */
        fetchActivitiesBtn.addEventListener('click', async () => {
            if (!currentAppUserId || !isAuthenticated || !currentRunnerCredentialId || !currentAthleteId) {
                showAlert('Vui l√≤ng ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng v√† k·∫øt n·ªëi v·ªõi Strava tr∆∞·ªõc khi th·ª±c hi·ªán ch·ª©c nƒÉng n√†y.');
                return;
            }

            const dataStatus = document.getElementById('data-status');
            dataStatus.textContent = 'ƒêang t·∫£i d·ªØ li·ªáu ho·∫°t ƒë·ªông t·ª´ Strava ...';

            const activitiesLimit = parseInt(activitiesLimitInput.value, 10);

            if (isNaN(activitiesLimit) || activitiesLimit <= 0 || activitiesLimit > 200) {
                showAlert('Vui l√≤ng nh·∫≠p s·ªë l∆∞·ª£ng ho·∫°t ƒë·ªông h·ª£p l·ªá (1-200). Strava ch·ªâ h·ªó tr·ª£ t·∫£i t·ªëi ƒëa 200 ho·∫°t ƒë·ªông.');
                dataStatus.textContent = '';
                return;
            }
            
            console.log('Fetching activities:');
            console.log('  currentRunnerCredentialId (Supabase Credential ID to send):', currentRunnerCredentialId);
            console.log('  currentAthleteId (Strava Athlete ID - for local logging):', currentAthleteId); 

            try {
                const { data: { session }, error: sessionError } = await supabaseClientInstance.auth.getSession();
                if (sessionError || !session?.access_token) {
                    showAlert('L·ªói: Kh√¥ng t√¨m th·∫•y phi√™n ƒëƒÉng nh·∫≠p Supabase. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.');
                    dataStatus.textContent = 'L·ªói x√°c th·ª±c: Kh√¥ng t√¨m th·∫•y phi√™n ƒëƒÉng nh·∫≠p.';
                    return;
                }

                const response = await fetch(FETCH_ACTIVITIES_API_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${session.access_token}`
                    },
                    body: JSON.stringify({ 
                        runnerCredentialId: currentRunnerCredentialId,
                        limit: activitiesLimit 
                    }),
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    dataStatus.textContent = `ƒê√£ t·∫£i v√† l∆∞u ${result.count} ho·∫°t ƒë·ªông th√†nh c√¥ng!`;
                    showAlert(`ƒê√£ t·∫£i v√† l∆∞u ${result.count} ho·∫°t ƒë·ªông th√†nh c√¥ng!`);
                    await loadRecentActivitiesBtn.click(); 
                } else {
                    dataStatus.textContent = `L·ªói khi t·∫£i ho·∫°t ƒë·ªông: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`;
                    showAlert(`L·ªói khi t·∫£i ho·∫°t ƒë·ªông: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`);
                }
            } catch (error) {
                console.error('L·ªói khi t·∫£i ho·∫°t ƒë·ªông:', error);
                dataStatus.textContent = 'L·ªói m·∫°ng ho·∫∑c m√°y ch·ªß khi t·∫£i ho·∫°t ƒë·ªông.';
                showAlert('L·ªói m·∫°ng ho·∫∑c m√°y ch·ªß khi t·∫£i ho·∫°t ƒë·ªông.');
            }
        });

        /**
         * Handles the new "Download Strava h·ªô" button click.
         */
        downloadActivitiesForOtherBtn.addEventListener('click', async () => {
            if (!currentAppUserId) {
                showAlert('Vui l√≤ng ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y.');
                return;
            }

            const selectedOption = downloadRunnerSelect.options[downloadRunnerSelect.selectedIndex];
            if (!selectedOption || !selectedOption.value) {
                showAlert('Vui l√≤ng ch·ªçn m·ªôt Runner t·ª´ danh s√°ch ƒë·ªÉ t·∫£i h·ªô.');
                return;
            }

            const runnerToDownloadId = selectedOption.value;
            const runnerToDownloadName = selectedOption.textContent;

            // Ensure the selected runner is owned by the current app user for "download h·ªô"
       //     const runnerForDownload = allRunnerCredentials.find(cred => cred.id === runnerToDownloadId);
       //     if (!runnerForDownload || runnerForDownload.owner_uid !== currentAppUserId) {
        //        showAlert('B·∫°n ch·ªâ c√≥ th·ªÉ t·∫£i d·ªØ li·ªáu cho c√°c runner do b·∫°n ƒëƒÉng k√Ω.');
        //        downloadForOtherStatus.textContent = 'Kh√¥ng c√≥ quy·ªÅn t·∫£i d·ªØ li·ªáu cho runner n√†y.';
        //        return;
        //    }


            const activitiesLimit = parseInt(activitiesLimitInput.value, 10);
            if (isNaN(activitiesLimit) || activitiesLimit <= 0 || activitiesLimit > 200) {
                showAlert('Vui l√≤ng nh·∫≠p s·ªë l∆∞·ª£ng ho·∫°t ƒë·ªông h·ª£p l·ªá (1-200) trong √¥ gi·ªõi h·∫°n ho·∫°t ƒë·ªông. Strava ch·ªâ h·ªó tr·ª£ t·∫£i t·ªëi ƒëa 200 ho·∫°t ƒë·ªông.');
                return;
            }

            downloadForOtherStatus.textContent = `ƒêang t·∫£i d·ªØ li·ªáu ho·∫°t ƒë·ªông cho ${runnerToDownloadName} t·ª´ Strava ...`;

            try {
                const { data: { session }, error: sessionError } = await supabaseClientInstance.auth.getSession();
                if (sessionError || !session?.access_token) {
                    showAlert('L·ªói: Kh√¥ng t√¨m th·∫•y phi√™n ƒëƒÉng nh·∫≠p Supabase. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.');
                    downloadForOtherStatus.textContent = 'L·ªói x√°c th·ª±c: Kh√¥ng t√¨m th·∫•y phi√™n ƒëƒÉng nh·∫≠p.';
                    return;
                }

                console.log(`[Download h·ªô] Calling fetch-strava-activities for runner: ${runnerToDownloadName} (Credential ID: ${runnerToDownloadId})`);

                const response = await fetch(FETCH_ACTIVITIES_API_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${session.access_token}`
                    },
                    body: JSON.stringify({ 
                        runnerCredentialId: runnerToDownloadId,
                        limit: activitiesLimit 
                    }),
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    downloadForOtherStatus.textContent = `ƒê√£ t·∫£i v√† l∆∞u ${result.count} ho·∫°t ƒë·ªông cho ${runnerToDownloadName} th√†nh c√¥ng!`;
                    showAlert(`ƒê√£ t·∫£i v√† l∆∞u ${result.count} ho·∫°t ƒë·ªông cho ${runnerToDownloadName} th√†nh c√¥ng!`);
                } else {
                    downloadForOtherStatus.textContent = `L·ªói khi t·∫£i ho·∫°t ƒë·ªông cho ${runnerToDownloadName}: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`;
                    showAlert(`L·ªói khi t·∫£i ho·∫°t ƒë·ªông cho ${runnerToDownloadName}: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`);
                }
            } catch (error) {
                console.error(`L·ªói khi t·∫£i ho·∫°t ƒë·ªông cho ${runnerToDownloadName}:`, error);
                downloadForOtherStatus.textContent = 'L·ªói m·∫°ng ho·∫∑c m√°y ch·ªß khi t·∫£i ho·∫°t ƒë·ªông.';
                showAlert('L·ªói m·∫°ng ho·∫∑c m√°y ch·ªß khi t·∫£i ho·∫°t ƒë·ªông.');
            }
        });

        /**
         * Populates the dropdown for "Download Strava h·ªô" with all saved runner credentials.
         */
        function populateDownloadRunnerSelect() {
            downloadRunnerSelect.innerHTML = '<option value="">-- Ch·ªçn Runner --</option>'; 
             // Populate with all runners who have an athlete_id (connected to Strava), regardless of app user owner.
            allRunnerCredentials.filter(cred => cred.athlete_id).forEach(cred => { // Thay ƒë·ªïi ƒëi·ªÅu ki·ªán l·ªçc
                const option = document.createElement('option');
                option.value = cred.id;
                option.textContent = cred.runner_name;
                downloadRunnerSelect.appendChild(option);
            });
        }

        /**
         * Populates the runner filter dropdown for recent activities.
         */
        function populateRunnerRecentActivitiesFilter() {
            runnerRecentActivitiesFilter.innerHTML = '<option value="all">T·∫•t c·∫£ Runner</option>'; 
            // Only populate with runners owned by the current app user and connected to Strava
          //  allRunnerCredentials.filter(cred => cred.athlete_id && cred.owner_uid === currentAppUserId).forEach(cred => {
          allRunnerCredentials.filter(cred => cred.athlete_id).forEach(cred => {
                const option = document.createElement('option');
                option.value = String(cred.athlete_id);
                option.textContent = cred.runner_name;
                runnerRecentActivitiesFilter.appendChild(option);
            });
            if (selectedRunnerIdForRecentActivities && 
                Array.from(runnerRecentActivitiesFilter.options).some(opt => opt.value === selectedRunnerIdForRecentActivities)) {
                runnerRecentActivitiesFilter.value = selectedRunnerIdForRecentActivities;
            } else {
                selectedRunnerIdForRecentActivities = 'all';
                runnerRecentActivitiesFilter.value = 'all';
            }
        }


        /**
         * Fetches all athlete IDs for the current logged-in app user from their runner credentials.
         * @returns {Promise<string[]>} An array of athlete IDs (as strings).
         */
        async function getAllAthleteIdsForCurrentUser() {
            if (!currentAppUserId) {
                console.warn('getAllAthleteIdsForCurrentUser: currentAppUserId is null. Cannot fetch runner credentials.');
                return [];
            }

            await fetchAndSetRunnerCredentials();

            const athleteIds = allRunnerCredentials
                .filter(cred => cred.athlete_id && cred.owner_uid === currentAppUserId) // Filter by owner_uid
                .map(cred => String(cred.athlete_id));

            console.log('getAllAthleteIdsForCurrentUser: Fetched athlete IDs for current app user:', athleteIds);
            return athleteIds;
        }

       loadRecentActivitiesBtn.addEventListener('click', async () => {
            if (!currentAppUserId) { 
                showAlert('Vui l√≤ng ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng ƒë·ªÉ th·ª±c hi·ªán ch·ª©c nƒÉng n√†y.');
                return;
            }

            recentActivitiesStatus.textContent = 'ƒêang t·∫£i ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y ...';
            // V√πng t√≥m t·∫Øt v√† v√πng chi ti·∫øt c·∫ßn ƒë∆∞·ª£c reset v√† ·∫©n ƒëi ban ƒë·∫ßu
            recentActivitiesSummaryArea.innerHTML = ''; 
            detailedRecentActivitiesCards.innerHTML = ''; 
            detailedRecentActivitiesCards.classList.add('hidden'); 

            // Filter runner credentials to include all connected runners (those with an athlete_id), regardless of app user owner.
            let runnerCredentialsToFilter = allRunnerCredentials.filter(cred => cred.athlete_id);
            
            if (selectedClubNameForRecentActivities !== 'all') {
                runnerCredentialsToFilter = runnerCredentialsToFilter.filter(
                    cred => cred.running_team === selectedClubNameForRecentActivities
                );
            }

            const selectedRunnerId = runnerRecentActivitiesFilter.value;
            let actualAthleteIdsToFilter = [];

            if (selectedRunnerId === 'all') {
                actualAthleteIdsToFilter = runnerCredentialsToFilter
                    .filter(cred => cred.athlete_id)
                    .map(cred => String(cred.athlete_id));
            } else {
                const specificRunner = runnerCredentialsToFilter.find(cred => String(cred.athlete_id) === selectedRunnerId);
                if (specificRunner) {
                    actualAthleteIdsToFilter = [selectedRunnerId];
                } else {
                    actualAthleteIdsToFilter = [];
                }
            }

            if (actualAthleteIdsToFilter.length === 0) {
                recentActivitiesSummaryArea.innerHTML = '<p class="card p-4 text-gray-500 text-center col-span-full">Kh√¥ng t√¨m th·∫•y ho·∫°t ƒë·ªông n√†o ph√π h·ª£p v·ªõi c√°c b·ªô l·ªçc ƒë√£ ch·ªçn. Vui l√≤ng th√™m v√† k·∫øt n·ªëi runner ho·∫∑c ƒëi·ªÅu ch·ªânh b·ªô l·ªçc.</p>';
                recentActivitiesStatus.textContent = 'Kh√¥ng c√≥ ho·∫°t ƒë·ªông n√†o ƒë·ªÉ hi·ªÉn th·ªã.';
                userActivities = [];
                renderDetailedStatsTable();
                return;
            }

            console.log('Loading recent activities for filtered athlete IDs:', actualAthleteIdsToFilter, 'and club:', selectedClubNameForRecentActivities);

            const numActivitiesToDisplay = parseInt(numRecentActivitiesInput.value, 10) || 10;
            const selectedTypes = selectedActivityTypesRecent;
            
            const startDateInput = startDateRecent.value;
            const endDateInput = endDateRecent.value;

            let filterStartDate = null;
            let filterEndDate = null;

            if (startDateInput) {
                const parts = startDateInput.split('-');
                const year = parseInt(parts[0]);
                const month = parseInt(parts[1]) - 1;
                const day = parseInt(parts[2]);
                const localStartDate = new Date(year, month, day);
                filterStartDate = localStartDate.toISOString();
            }

            if (endDateInput) {
                const parts = endDateInput.split('-');
                const year = parseInt(parts[0]);
                const month = parseInt(parts[1]) - 1;
                const day = parseInt(parts[2]);
                const localEndDate = new Date(year, month, day);
                localEndDate.setDate(localEndDate.getDate() + 1); 
                filterEndDate = localEndDate.toISOString();
            }

            try {
                let query = supabaseClientInstance
                    .from('activities')
                    .select('strava_activity_id, name, type, distance, moving_time, total_elevation_gain, start_date, average_speed, average_heartrate, user_id');
                    
                query = query.in('user_id', actualAthleteIdsToFilter); 

                if (selectedTypes.length > 0) {
                    query = query.in('type', selectedTypes); 
                }
                if (filterStartDate) {
                    query = query.gte('start_date', filterStartDate);
                }
                if (filterEndDate) {
                    query = query.lt('start_date', filterEndDate);
                }

                const { data, error } = await query
                    .order('start_date', { ascending: false })
                    .limit(numActivitiesToDisplay);

                if (error) {
                    console.error('L·ªói khi t·∫£i ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y t·ª´ Supabase:', error);
                    recentActivitiesStatus.textContent = `L·ªói khi t·∫£i ho·∫°t ƒë·ªông: ${error.message}`;
                    showAlert(`L·ªói khi t·∫£i ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y: ${error.message}`);
                    return; 
                }
                
                console.log('Data returned from Supabase for recent activities (all runners):', data);

                if (data && data.length > 0) {
                    userActivities = data; // Store globally
                    renderActivitySummary(userActivities); // G·ªåI H√ÄM RENDER T√ìM T·∫ÆT
                    recentActivitiesStatus.textContent = `ƒê√£ t·∫£i ${data.length} ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y cho c√°c runner ƒë√£ ch·ªçn.`;
                } else {
                    recentActivitiesSummaryArea.innerHTML = '<p class="card p-4 text-gray-500 text-center col-span-full">Kh√¥ng t√¨m th·∫•y ho·∫°t ƒë·ªông n√†o g·∫ßn ƒë√¢y cho c√°c runner ho·∫∑c v·ªõi b·ªô l·ªçc ƒë√£ ch·ªçn.</p>';
                    recentActivitiesStatus.textContent = 'Kh√¥ng c√≥ ho·∫°t ƒë·ªông n√†o ƒë·ªÉ hi·ªÉn th·ªã.';
                    userActivities = [];
                }
                renderDetailedStatsTable(); // Always update detailed stats table
            } catch (error) {
                console.error('L·ªói khi t·∫£i ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y t·ª´ Supabase:', error);
                recentActivitiesStatus.textContent = `L·ªói khi t·∫£i ho·∫°t ƒë·ªông: ${error.message}`;
                showAlert(`L·ªói khi t·∫£i ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y: ${error.message}`);
            }
        });
 // Event listener for "Xem th·ªëng k√™ theo tu·∫ßn" button
        viewStatsBtn.addEventListener('click', async () => {
            if (!currentAppUserId) { 
                showAlert('Vui l√≤ng ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng ƒë·ªÉ xem th·ªëng k√™.');
                return;
            }

            const chartStatus = document.getElementById('chart-status');
            chartStatus.textContent = 'ƒêang t·∫£i th·ªëng k√™ theo tu·∫ßn ...';
            weeklyStatsData = []; 

            let runnerCredentialsToFetch = allRunnerCredentials.filter(cred => cred.athlete_id);
            if (selectedClubIdForStats !== '') {
                runnerCredentialsToFetch = runnerCredentialsToFetch.filter(
                    cred => cred.running_team === selectedClubIdForStats
                );
            }
            if (selectedRunnerIdForStats !== '') {
                 runnerCredentialsToFetch = runnerCredentialsToFetch.filter(
                    cred => String(cred.athlete_id) === selectedRunnerIdForStats
                );
            }


            if (runnerCredentialsToFetch.length === 0) {
                chartStatus.textContent = 'Kh√¥ng t√¨m th·∫•y runner n√†o ƒë∆∞·ª£c k·∫øt n·ªëi v·ªõi t√†i kho·∫£n Strava ho·∫∑c ph√π h·ª£p v·ªõi b·ªô l·ªçc. Vui l√≤ng th√™m v√† k·∫øt n·ªëi runner.';
                document.getElementById('bubble-chart-container').innerHTML = '<p class="text-gray-500 text-center">Kh√¥ng c√≥ d·ªØ li·ªáu th·ªëng k√™ ƒë·ªÉ hi·ªÉn th·ªã bi·ªÉu ƒë·ªì.</p>';
                weeklyStatsData = [];
                renderDetailedStatsTable(); 
                return;
            }

            console.log('Fetching weekly stats for runners:', runnerCredentialsToFetch.map(r => r.runner_name), 'and club:', selectedClubIdForStats);

            try {
                const { data: { session }, error: sessionError } = await supabaseClientInstance.auth.getSession();
                const headers = { 'Content-Type': 'application/json' };
                if (session?.access_token) {
                    headers['Authorization'] = `Bearer ${session.access_token}`;
                } else {
                    showAlert('L·ªói: Kh√¥ng t√¨m th·∫•y phi√™n ƒëƒÉng nh·∫≠p. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i ƒë·ªÉ xem th·ªëng k√™.');
                    chartStatus.textContent = 'L·ªói x√°c th·ª±c: Kh√¥ng t√¨m th·∫•y phi√™n ƒëƒÉng nh·∫≠p.';
                    return;
                }

                const fetchPromises = runnerCredentialsToFetch.map(async (runner) => {
                    const runnerId = runner.id;
                    if (!runnerId) {
                        console.error(`Skipping fetch for runner ${runner.runner_name || 'Unknown'} due to missing or invalid credential ID.`);
                        return { weeklyStats: [], detailedActivities: [] };
                    }
                    const payload = { runnerCredentialId: runnerId };
                    console.log(`[viewStatsBtn] Sending payload to ${GET_STATS_API_URL}:`, payload);
                    try {
                        const response = await fetch(GET_STATS_API_URL, {
                            method: 'POST',
                            headers: headers, 
                            body: JSON.stringify(payload)
                        });

                        const result = await response.json();
                        if (response.ok && result.success) {
                            const enrichedWeeklyStats = result.weekly_stats.map(s => ({
                                ...s,
                                athlete_id: runner.athlete_id,
                                running_team: runner.running_team
                            }));
                            return { 
                                weeklyStats: enrichedWeeklyStats, 
                                detailedActivities: result.detailed_activities 
                            };
                        } else {
                            console.error(`L·ªói khi t·∫£i th·ªëng k√™ cho ${runner.runner_name} (credential ID: ${runnerId}):`, result.error || 'Kh√¥ng x√°c ƒë·ªãnh');
                            showAlert(`L·ªói khi t·∫£i th·ªëng k√™ cho ${runner.runner_name}: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`);
                            return { weeklyStats: [], detailedActivities: [] };
                        }
                    } catch (error) {
                        console.error(`L·ªói m·∫°ng/m√°y ch·ªß khi t·∫£i th·ªëng k√™ cho ${runner.runner_name} (credential ID: ${runnerId}):`, error);
                        showAlert(`L·ªói m·∫°ng/m√°y ch·ªß khi t·∫£i th·ªëng k√™ cho ${runner.runner_name}: ${error.message}`);
                        return { weeklyStats: [], detailedActivities: [] };
                    }
                });

                const allResults = await Promise.all(fetchPromises);

                allResults.forEach(res => {
                    weeklyStatsData.push(...res.weeklyStats);
                });

                chartStatus.textContent = `ƒê√£ t·∫£i th·ªëng k√™ cho ${runnerCredentialsToFetch.length} runner. T·ªïng c·ªông ${weeklyStatsData.length} tu·∫ßn.`;
                renderBubbleChart(weeklyStatsData); 
            } catch (error) {
                console.error('L·ªói chung khi t·∫£i th·ªëng k√™ theo tu·∫ßn:', error);
                chartStatus.textContent = 'L·ªói m·∫°ng ho·∫∑c m√°y ch·ªß khi t·∫£i th·ªëng k√™.';
                showAlert('L·ªói m·∫°ng ho·∫∑c m√°y ch·ªß khi t·∫£i th·ªëng k√™.');
            }
        });


        
        /**
         * Renders the detailed statistics table based on userActivities.
         */
        function renderDetailedStatsTable() {
            const table = document.getElementById('detailed-stats-table');
            let currentTbody = table.lastElementChild;
            while (currentTbody && currentTbody.tagName === 'TBODY') {
                table.removeChild(currentTbody);
                currentTbody = table.lastElementChild;
            }

            detailedStatsStatus.textContent = '';

            const activitiesToDisplay = userActivities; 

            if (!activitiesToDisplay || activitiesToDisplay.length === 0) {
                detailedStatsStatus.textContent = 'Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã.';
                return;
            }

            const penaltyPerKmGt10 = parseFloat(penaltyPerKmGt10Input.value) || 0;
            const penaltyPerKmLte10 = parseFloat(penaltyPerKmLte10Input.value) || 0;
            const targetKmPerWeek = parseFloat(targetKmPerWeekInput.value) || 0;

            const activitiesByAthlete = activitiesToDisplay.reduce((acc, activity) => {
                const athleteId = String(activity.user_id);
                if (!acc[athleteId]) {
                    acc[athleteId] = [];
                }
                acc[athleteId].push(activity);
                return acc;
            }, {});

            const runnerInfoMap = new Map();
            // Filter allRunnerCredentials by owner_uid for building the map
            allRunnerCredentials.filter(cred => cred.owner_uid === currentAppUserId && cred.athlete_id).forEach(cred => {
                runnerInfoMap.set(String(cred.athlete_id), {
                    name: cred.runner_name,
                    team: cred.running_team
                });
            });
            console.log('renderDetailedStatsTable: Runner info map:', runnerInfoMap); 
            console.log('renderDetailedStatsTable: Activities grouped by athlete (filtered):', activitiesByAthlete); 

            const sortedAthleteIds = Object.keys(activitiesByAthlete).sort((a, b) => {
                const nameA = runnerInfoMap.get(a)?.name || `Runner ID: ${a}`;
                const nameB = runnerInfoMap.get(b)?.name || `Runner ID: ${b}`; 
                return nameA.localeCompare(nameB);
            });

            sortedAthleteIds.forEach(athleteId => {
                const runnerName = runnerInfoMap.get(athleteId)?.name || `Runner ID: ${athleteId}`;
                const runnerTeam = runnerInfoMap.get(athleteId)?.team || 'N/A';
                console.log(`renderDetailedStatsTable: Processing runner: ${runnerName} (athleteId: ${athleteId}, team: ${runnerTeam})`);

                const runnerActivities = activitiesByAthlete[athleteId];
                let totalRunnerDistanceKm = 0;
                let totalRunnerTime = 0;

                runnerActivities.forEach(activity => {
                    totalRunnerDistanceKm += (activity.distance / 1000);
                    totalRunnerTime += activity.moving_time;
                });

                const summaryTbody = document.createElement('tbody');
                summaryTbody.className = 'runner-summary-group';

                const totalRow = summaryTbody.insertRow();
                totalRow.className = 'total-row';
                totalRow.innerHTML = `
                    <td colspan="3" class="font-bold text-lg text-bidv-green">
                        T·ªïng c·ªông cho ${runnerName} <span class="text-gray-500 text-base">(${runnerTeam})</span>
                        <i class="toggle-icon fas fa-chevron-right text-gray-600 detailed-stats-toggle-icon ml-2 cursor-pointer" data-target-id="detailed-activities-for-${athleteId}"></i>
                    </td>
                    <td>${totalRunnerDistanceKm.toFixed(2)}</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>${formatDuration(totalRunnerTime)}</td>
                `;
                const toggleIcon = totalRow.querySelector('.detailed-stats-toggle-icon');
                if (toggleIcon) {
                    toggleIcon.addEventListener('click', () => {
                        const targetId = toggleIcon.dataset.targetId;
                        const contentElement = document.getElementById(targetId);
                        toggleCollapsible(contentElement, toggleIcon);
                    });
                }

                const kmDifference = totalRunnerDistanceKm - targetKmPerWeek;
                
                let kmMessage = '';
                let amountMessage = '';
                if (kmDifference < 0) {
                    const deficitKm = Math.abs(kmDifference);
                    let penaltyRate = 0;
                    if (deficitKm <= 10) {
                        penaltyRate = penaltyPerKmLte10;
                    } else {
                        penaltyRate = penaltyPerKmGt10;
                    }
                    const penaltyAmount = deficitKm * penaltyRate;
                    kmMessage = `S·ªë KM thi·∫øu (M·ª•c ti√™u ${targetKmPerWeek}KM): <strong>${deficitKm.toFixed(2)} KM</strong>`;
                    amountMessage = `S·ªë ti·ªÅn ph·∫°t (Ph·∫°t ${penaltyRate}K/KM): <strong>${penaltyAmount.toLocaleString('vi-VN')} ngh√¨n VNƒê</strong>`;
                } else {
                    const surplusKm = kmDifference;
                    const bonusAmount = surplusKm * (penaltyPerKmGt10 || 0);
                    kmMessage = `S·ªë KM v∆∞·ª£t m·ª•c ti√™u (M·ª•c ti√™u ${targetKmPerWeek}KM): <strong>${surplusKm.toFixed(2)} KM</strong>`;
                    amountMessage = `Ti·ªÅn th∆∞·ªüng (Th∆∞·ªüng ${(penaltyPerKmGt10 || 0)}K/KM): <strong>${bonusAmount.toLocaleString('vi-VN')} ngh√¨n VNƒê</strong>`;
                }

                const summaryRow = summaryTbody.insertRow();
                summaryRow.className = kmDifference < 0 ? 'missing-row' : 'summary-row';
                summaryRow.innerHTML = `
                    <td colspan="4">${kmMessage}</td>
                    <td colspan="4">${amountMessage}</td>
                `;

                table.appendChild(summaryTbody);


                const detailedActivitiesTbody = document.createElement('tbody');
                detailedActivitiesTbody.id = `detailed-activities-for-${athleteId}`;
                detailedActivitiesTbody.className = 'collapsible-content';
                detailedActivitiesTbody.classList.add('collapsed');

                runnerActivities.sort((a, b) => new Date(b.start_date) - new Date(a.start_date));

                runnerActivities.forEach(activity => {
                    const distanceKm = (activity.distance / 1000);
                    const row = detailedActivitiesTbody.insertRow();
                    row.innerHTML = `
                        <td></td>
                        <td>${new Date(activity.start_date).toLocaleDateString('vi-VN')}</td>
                        <td>${activity.type}</td>
                        <td>${distanceKm.toFixed(2)}</td>
                        <td>${formatPace(activity.average_speed)}</td>
                        <td>${activity.average_heartrate ? `${activity.average_heartrate.toFixed(0)}` : 'N/A'}</td>
                        <td>${formatElevationGain(activity.total_elevation_gain)}</td>
                        <td>${formatDuration(activity.moving_time)}</td>
                    `;
                });
                
                table.appendChild(detailedActivitiesTbody);

                const spacerTbody = document.createElement('tbody');
                spacerTbody.innerHTML = `<tr class="h-4 bg-gray-100"><td colspan="8"></td></tr>`;
                table.appendChild(spacerTbody);
            });

            detailedStatsStatus.textContent = '';
            if (sortedAthleteIds.length === 0) {
                detailedStatsStatus.textContent = 'Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã.';
            }
        }

        /**
         * Fetches clubs from Supabase and updates the global `allClubs` array.
         * @returns {Promise<Object[]>} Array of club objects.
         */
        async function fetchClubs() {
            if (!supabaseClientInstance) {
                console.error('Supabase client is not initialized for fetching clubs.');
                return [];
            }
            try {
                const { data, error } = await supabaseClientInstance
                    .from('clubs')
                    .select('*')
                    .order('name', { ascending: true });
                if (error) throw error;
                allClubs = data;
                console.log('Fetched clubs:', allClubs);
                return allClubs;
            } catch (error) {
                // ƒê√¢y l√† n∆°i l·ªói "Invalid API key" th∆∞·ªùng xu·∫•t hi·ªán n·∫øu kh√≥a kh√¥ng ƒë√∫ng
                // ho·∫∑c ch√≠nh s√°ch RLS tr√™n b·∫£ng 'clubs' kh√¥ng cho ph√©p 'select'.
                console.error('Error fetching clubs:', error.message);
                showAlert(`L·ªói khi t·∫£i danh s√°ch c√¢u l·∫°c b·ªô: ${error.message}. Vui l√≤ng ki·ªÉm tra API Key v√† ch√≠nh s√°ch RLS tr√™n b·∫£ng 'clubs' trong Supabase.`);
                allClubs = [];
                return [];
            }
        }

        /**
         * Populates the club filter dropdowns and the runner-team select in the modal.
         */
        function populateClubDropdowns() {
            runnerTeamSelect.innerHTML = '<option value="">-- Ch·ªçn ƒë·ªôi ch·∫°y --</option>';
            allClubs.forEach(club => {
                const option = document.createElement('option');
                option.value = club.name;
                option.textContent = club.name;
                runnerTeamSelect.appendChild(option);
            });

            clubRecentActivitiesFilter.innerHTML = '<option value="all">T·∫•t c·∫£ C√¢u l·∫°c b·ªô</option>';
            allClubs.forEach(club => {
                const option = document.createElement('option');
                option.value = club.name;
                option.textContent = club.name;
                clubRecentActivitiesFilter.appendChild(option);
            });
            if (Array.from(clubRecentActivitiesFilter.options).some(opt => opt.value === selectedClubNameForRecentActivities)) {
                clubRecentActivitiesFilter.value = selectedClubNameForRecentActivities;
            } else {
                selectedClubNameForRecentActivities = 'all';
                clubRecentActivitiesFilter.value = 'all';
            }


            clubStatsFilter.innerHTML = '<option value="">T·∫•t c·∫£ C√¢u l·∫°c b·ªô</option>'; 
            allClubs.forEach(club => {
                const option = document.createElement('option');
                option.value = club.name;
                option.textContent = club.name;
                clubStatsFilter.appendChild(option);
            });
            if (Array.from(clubStatsFilter.options).some(opt => opt.value === selectedClubIdForStats)) {
                clubStatsFilter.value = selectedClubIdForStats;
            } else {
                selectedClubIdForStats = '';
                clubStatsFilter.value = '';
            }
        }


        /**
         * Populates the runner filter dropdown for the stats section.
         */
        function populateRunnerStatsFilter() {
            runnerStatsFilter.innerHTML = '<option value="">T·∫•t c·∫£ Runner</option>';
            
            // Filter runners by owner_uid first
          //  let filteredRunners = allRunnerCredentials.filter(cred => cred.owner_uid === currentAppUserId);
         let filteredRunners = allRunnerCredentials.filter(cred => cred.athlete_id);
            if (selectedClubIdForStats !== '') {
                filteredRunners = filteredRunners.filter(cred => cred.running_team === selectedClubIdForStats);
            }

            filteredRunners.forEach(cred => {
                if (cred.athlete_id) {
                    const option = document.createElement('option');
                    option.value = String(cred.athlete_id);
                    option.textContent = cred.runner_name;
                    runnerStatsFilter.appendChild(option);
                }
            });
            if (selectedRunnerIdForStats && 
                Array.from(runnerStatsFilter.options).some(opt => opt.value === selectedRunnerIdForStats)) {
                runnerStatsFilter.value = selectedRunnerIdForStats;
            } else {
                selectedRunnerIdForStats = '';
                runnerStatsFilter.value = '';
            }
        }

        /**
         * Converts an ISO week string (YYYY-WNN) to a Date object, representing the start of that week (Monday).
         * @param {string} w - The ISO week string (e.g., "2023-W01").
         * @returns {Date} A Date object for the Monday of the given ISO week.
         */
        function getDateFromISOWeek(w) {
            const year = parseInt(w.substring(0, 4), 10);
            const week = parseInt(w.substring(6), 10);
            const date = new Date(year, 0, 1 + (week - 1) * 7);
            date.setDate(date.getDate() + (1 - date.getDay() + (date.getDay() === 0 ? -6 : 1))); 
            return date;
        }

        /**
         * Fetches and displays detailed activities for a specific week and athlete ID.
         * @param {string} isoWeek - The ISO week string (e.g., "2023-W01").
         * @param {string} athleteId - The Strava athlete ID.
         */
        async function fetchActivitiesForWeek(isoWeek, athleteId) {
            weeklyActivitiesList.innerHTML = '';
            weeklyActivitiesStatus.textContent = 'ƒêang t·∫£i ho·∫°t ƒë·ªông cho tu·∫ßn n√†y...';
            weeklyActivitiesModal.style.display = 'flex';

            try {
                const runner = allRunnerCredentials.find(rc => String(rc.athlete_id) === String(athleteId));
                if (!runner) {
                    weeklyActivitiesStatus.textContent = 'Kh√¥ng t√¨m th·∫•y th√¥ng tin runner.';
                    showAlert('Kh√¥ng t√¨m th·∫•y th√¥ng tin runner cho Athlete ID n√†y.');
                    weeklyActivitiesModal.style.display = 'none'; // Close modal on error
                    return;
                }

                // Explicitly check ownership for viewing detailed activities
         //       if (runner.owner_uid !== currentAppUserId) {
         //           showAlert('B·∫°n kh√¥ng c√≥ quy·ªÅn xem ho·∫°t ƒë·ªông c·ªßa runner n√†y.');
         //           weeklyActivitiesStatus.textContent = 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p.';
         //           weeklyActivitiesModal.style.display = 'none'; // Close modal on unauthorized access
         //           return;
         //       }

                const { data: { session }, error: sessionError } = await supabaseClientInstance.auth.getSession();
                const headers = { 'Content-Type': 'application/json' };
                if (session?.access_token) {
                    headers['Authorization'] = `Bearer ${session.access_token}`;
                } else {
                    weeklyActivitiesStatus.textContent = 'L·ªói x√°c th·ª±c: Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.';
                    showAlert('L·ªói: Kh√¥ng t√¨m th·∫•y phi√™n ƒëƒÉng nh·∫≠p. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i ƒë·ªÉ xem chi ti·∫øt ho·∫°t ƒë·ªông.');
                    weeklyActivitiesModal.style.display = 'none'; // Close modal on error
                    return;
                }

                const payload = { 
                    runnerCredentialId: runner.id,
                    isoWeek: isoWeek
                };

                const response = await fetch(GET_STATS_API_URL, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (response.ok && result.success && result.detailed_activities) {
                    const activitiesInWeek = result.detailed_activities.filter(act => 
                        String(act.user_id) === String(athleteId) && 
                        getISOWeekString(new Date(act.start_date)) === isoWeek
                    );

                    if (activitiesInWeek.length > 0) {
                        activitiesInWeek.sort((a, b) => new Date(b.start_date) - new Date(a.start_date));
                        activitiesInWeek.forEach(activity => {
                            const li = document.createElement('li');
                            li.className = 'border-b last:border-b-0 py-2';
                            li.innerHTML = `
                                <p class="font-semibold">${activity.name} (${activity.type})</p>
                                <p class="text-sm text-gray-600">Ng√†y: ${new Date(activity.start_date).toLocaleDateString('vi-VN')}</p>
                                <p class="text-sm text-gray-600">Qu√£ng ƒë∆∞·ªùng: ${(activity.distance / 1000).toFixed(2)} km</p>
                                <p class="text-sm text-gray-600">Th·ªùi gian: ${formatDuration(activity.moving_time)}</p>
                                <p class="text-sm text-gray-600">Pace: ${formatPace(activity.average_speed)}</p>
                                ${activity.strava_activity_id ? `<button class="btn-primary mt-2 text-xs px-2 py-1 view-map-btn" data-activity-id="${activity.strava_activity_id}">Xem b·∫£n ƒë·ªì</button>` : ''}
                            `;
                            weeklyActivitiesList.appendChild(li);
                        });
                        weeklyActivitiesStatus.textContent = `ƒê√£ t·∫£i ${activitiesInWeek.length} ho·∫°t ƒë·ªông cho tu·∫ßn n√†y.`;
                        document.querySelectorAll('#weekly-activities-modal .view-map-btn').forEach(button => {
                            button.onclick = (e) => {
                                const activityId = e.target.dataset.activityId;
                                if (activityId) {
                                    window.open(`https://www.strava.com/activities/${activityId}`, '_blank');
                                }
                            };
                        });
                    } else {
                        weeklyActivitiesStatus.textContent = 'Kh√¥ng t√¨m th·∫•y ho·∫°t ƒë·ªông n√†o cho tu·∫ßn n√†y.';
                    }
                } else {
                    console.error('L·ªói khi t·∫£i ho·∫°t ƒë·ªông chi ti·∫øt cho tu·∫ßn:', result.error || 'Kh√¥ng x√°c ƒë·ªãnh');
                    weeklyActivitiesStatus.textContent = `L·ªói: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`;
                    showAlert(`L·ªói khi t·∫£i ho·∫°t ƒë·ªông chi ti·∫øt: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`);
                }
            } catch (error) {
                console.error('L·ªói m·∫°ng ho·∫∑c m√°y ch·ªß khi t·∫£i ho·∫°t ƒë·ªông chi ti·∫øt:', error);
                weeklyActivitiesStatus.textContent = 'L·ªói m·∫°ng ho·∫∑c m√°y ch·ªß khi t·∫£i ho·∫°t ƒë·ªông.';
                showAlert(`L·ªói m·∫°ng ho·∫∑c m√°y ch·ªß khi t·∫£i ho·∫°t ƒë·ªông: ${error.message}`);
            }
        }

/**
 * Helper to get ISO week string (YYYY-WNN) from a Date object, adjusted for Vietnam timezone.
 * This function ensures that the week calculation aligns with Vietnam local time (UTC+7),
 * regardless of the user's browser timezone settings, by explicitly converting the UTC date
 * to its Vietnam timezone components before calculating the ISO week.
 * @param {Date|string} d - The Date object or ISO 8601 string (assumed to be UTC from Supabase).
 * @returns {string} ISO week string (YYYY-WNN). Returns null if input is invalid.
 */
function getISOWeekString(d) {
    let activityDateUtc;

    // Ensure we have a valid Date object, assuming string inputs are UTC ISO 8601
    if (typeof d === 'string') {
        activityDateUtc = new Date(d);
    } else if (d instanceof Date) {
        activityDateUtc = d;
    } else {
        console.error("Invalid date input for getISOWeekString:", d);
        return null;
    }

    // Check for invalid date
    if (isNaN(activityDateUtc.getTime())) {
        console.error("Invalid Date object after parsing in getISOWeekString:", d);
        return null;
    }

    // Use Intl.DateTimeFormat to get date components as perceived in 'Asia/Ho_Chi_Minh'
    // This is the most robust way to get timezone-specific date parts in vanilla JS.
    const formatter = new Intl.DateTimeFormat('en-US', {
        year: 'numeric',
        month: 'numeric',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric',
        timeZone: 'Asia/Ho_Chi_Minh',
        hour12: false // Ensure 24-hour format for consistency
    });

    const parts = formatter.formatToParts(activityDateUtc);
    let year, month, day, hour = 0, minute = 0, second = 0;

    parts.forEach(p => {
        switch (p.type) {
            case 'year': year = parseInt(p.value); break;
            case 'month': month = parseInt(p.value); break;
            case 'day': day = parseInt(p.value); break;
            case 'hour': hour = parseInt(p.value); break;
            case 'minute': minute = parseInt(p.value); break;
            case 'second': second = parseInt(p.value); break;
        }
    });

    // Construct a new Date object using Date.UTC() from the Vietnam-aligned components.
    // This creates a UTC date whose *UTC properties* (like getUTCDay, getUTCFullYear)
    // will now correctly reflect the date and day of the week in Vietnam.
    const vietnamAlignedUtcDate = new Date(Date.UTC(year, month - 1, day, hour, minute, second));

    // Set to the start of the day in UTC for the Vietnam-aligned date
    vietnamAlignedUtcDate.setUTCHours(0, 0, 0, 0);

    // ISO week calculation logic (ISO 8601 defines weeks starting on Monday)
    // getUTCDay() returns 0 for Sunday, 1 for Monday, ..., 6 for Saturday.
    // We map Sunday (0) to 7 for consistent calculation.
    const dayOfVietnamWeekUtc = vietnamAlignedUtcDate.getUTCDay() || 7; 

    // Adjust the date to the nearest Thursday of its week (in Vietnam time).
    // Thursday is chosen because it's always in the same ISO week as the week's Monday.
    vietnamAlignedUtcDate.setUTCDate(vietnamAlignedUtcDate.getUTCDate() + 4 - dayOfVietnamWeekUtc);

    // Get the year of the ISO week. This might be different from the actual year
    // if the first week of the new year falls into the end of the previous year, or vice-versa.
    const isoWeekYear = vietnamAlignedUtcDate.getUTCFullYear();

    // Get the first day of that ISO year (January 1st UTC of the ISO year)
    const yearStart = new Date(Date.UTC(isoWeekYear, 0, 1));

    // Calculate the ISO week number:
    // (Difference in milliseconds between the Vietnam-aligned Thursday and the start of its ISO year + 1 day) / milliseconds in 7 days
    const weekNo = Math.ceil((((vietnamAlignedUtcDate - yearStart) / 86400000) + 1) / 7);

    // Return the ISO week string in YYYY-WNN format
    return `${isoWeekYear}-W${String(weekNo).padStart(2, '0')}`;
}

        
        // Function to draw the bubble chart
        function renderBubbleChart(data) {
            console.log('renderBubbleChart: Input data:', data);

          const monthlyDataMap = new Map();
            // Filter data to include all connected runners (those with an athlete_id), regardless of app user owner.
            let filteredData = data.filter(d => {
                const runner = allRunnerCredentials.find(c => String(c.athlete_id) === String(d.athlete_id));
                // B·ªè ƒëi·ªÅu ki·ªán l·ªçc theo owner_uid ƒë·ªÉ hi·ªÉn th·ªã t·∫•t c·∫£ d·ªØ li·ªáu
                return runner; // Ch·ªâ c·∫ßn ƒë·∫£m b·∫£o runner t·ªìn t·∫°i (t·ª©c l√† ƒë√£ k·∫øt n·ªëi Strava)
            });

            if (selectedRunnerIdForStats !== '') { 
                filteredData = filteredData.filter(d => String(d.athlete_id) === selectedRunnerIdForStats);
            }
            if (selectedClubIdForStats !== '') {
                filteredData = filteredData.filter(d => {
                    const runner = allRunnerCredentials.find(rc => String(rc.athlete_id) === String(d.athlete_id));
                    return runner && runner.running_team === selectedClubIdForStats;
                });
            }

            if (filteredData.length === 0) {
                document.getElementById('bubble-chart-container').innerHTML = '<p class="text-gray-500 text-center">Kh√¥ng c√≥ d·ªØ li·ªáu th·ªëng k√™ ƒë·ªÉ hi·ªÉn th·ªã bi·ªÉu ƒë·ªì cho c√°c b·ªô l·ªçc ƒë√£ ch·ªçn.</p>';
                console.log('renderBubbleChart: No monthly data to draw chart for selected filters.');
                return;
            }

            filteredData.forEach(d => {
                const dateInWeek = getDateFromISOWeek(d.week);
                const monthYear = dateInWeek.getFullYear() + '-' + String(dateInWeek.getMonth() + 1).padStart(2, '0');
                const monthTotalDistance = d.totalDistance;

                if (!monthlyDataMap.has(monthYear)) {
                    monthlyDataMap.set(monthYear, { month: monthYear, weeks: [], totalMonthlyDistance: 0 });
                }
                monthlyDataMap.get(monthYear).weeks.push(d);
                monthlyDataMap.get(monthYear).totalMonthlyDistance += d.totalDistance;
            });

            const monthlyData = Array.from(monthlyDataMap.values()).sort((a, b) => b.month.localeCompare(a.month));

            const container = document.getElementById('bubble-chart-container');
            container.innerHTML = ''; 

            if (!monthlyData || monthlyData.length === 0) {
                container.innerHTML = '<p class="text-gray-500 text-center">Kh√¥ng c√≥ d·ªØ li·ªáu th·ªëng k√™ ƒë·ªÉ hi·ªÉn th·ªã bi·ªÉu ƒë·ªì. Vui l√≤ng t·∫£i d·ªØ li·ªáu t·ª´ Strava ho·∫∑c ch·ªçn b·ªô l·ªçc kh√°c.</p>';
                console.log('renderBubbleChart: No monthly data to draw chart.');
                return;
            }

            const width = container.clientWidth;
            const monthBandHeight = width < 768 ? 120 : 180;
            const topPaddingForChart = width < 768 ? 70 : 100;

            const totalSvgContentHeight = (monthlyData.length * monthBandHeight) + topPaddingForChart;
            const svgHeight = Math.max(container.clientHeight, totalSvgContentHeight);

            console.log(`renderBubbleChart: SVG dimensions - Width: ${width}, Height: ${svgHeight}`);
            if (width <= 0 || svgHeight <= 0) {
                console.error('renderBubbleChart Error: Invalid chart dimensions. Width or Height <= 0.');
                container.innerHTML = '<p class="text-red-500">L·ªói: K√≠ch th∆∞·ªõc bi·ªÉu ƒë·ªì kh√¥ng h·ª£p l·ªá. Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c ƒë·∫£m b·∫£o khung ch·ª©a hi·ªÉn th·ªã.</p>';
                return;
            }


            const svg = d3.select(container)
                .append("svg")
                .attr("width", width)
                .attr("height", svgHeight)
                .attr("viewBox", `0 0 ${width} ${svgHeight}`)
                .attr("preserveAspectRatio", "xMidYMid meet");

            const maxDistance = d3.max(filteredData, d => d.totalDistance);
            const minDistance = d3.min(filteredData, d => d.totalDistance);

            console.log(`renderBubbleChart: Min Distance: ${minDistance}, Max Distance: ${maxDistance}`);
            
            const maxRadius = width < 768 ? 30 : 60;
            const minRadius = width < 768 ? 8 : 15;

            const radiusScale = d3.scaleSqrt()
                .domain([0, maxDistance || 1])
                .range([minRadius, maxRadius]);

            const colorScale = d3.scaleSequential(d3.interpolateViridis)
                .domain([maxDistance || 1, minDistance || 0]);


            const bubbleHorizontalPadding = width < 768 ? 10 : 20;
            const bubbleVerticalOffset = monthBandHeight / 2;

            let currentYOffset = topPaddingForChart;

            let tooltip = d3.select("body").select(".tooltip");
            if (tooltip.empty()) {
                tooltip = d3.select("body").append("div")
                    .attr("class", "tooltip");
            }

            monthlyData.forEach((monthObj) => {
                const monthGroup = svg.append("g")
                    .attr("transform", `translate(0, ${currentYOffset})`);

                const monthDisplay = `Th√°ng ${monthObj.month.substring(5)}/${monthObj.month.substring(0, 4)}`;
                const totalMonthlyKm = (monthObj.totalMonthlyDistance / 1000).toFixed(1);

                monthGroup.append("text")
                    .attr("x", 20)
                    .attr("y", 25)
                    .attr("font-size", width < 768 ? "1rem" : "1.2rem")
                    .attr("font-weight", "bold")
                    .attr("fill", "#555")
                    .text(`${monthDisplay} (${totalMonthlyKm}KM)`);

                monthObj.weeks.sort((a, b) => a.week.localeCompare(b.week));

                let currentX = 20;

                const positionedWeeks = monthObj.weeks.map(d => {
                    const r = radiusScale(d.totalDistance);
                    const cx = currentX + r;
                    currentX += (r * 2) + bubbleHorizontalPadding;
                    return { ...d, r, cx, cy: bubbleVerticalOffset + (width < 768 ? 0 : 10) };
                });

                console.log('renderBubbleChart: positionedWeeks for month', monthObj.month, ':', positionedWeeks);

                monthGroup.selectAll(".bubble")
                    .data(positionedWeeks)
                    .enter().append("circle")
                    .attr("class", "bubble")
                    .attr("cx", d => d.cx)
                    .attr("cy", d => d.cy)
                    .attr("r", d => d.r)
                    .attr("fill", d => colorScale(d.totalDistance))
                    .attr("stroke-width", 2)
                    .on("click", function(event, d) {
                        fetchActivitiesForWeek(d.week, d.athlete_id); 
                        weeklyActivitiesTitle.textContent = `Ho·∫°t ƒë·ªông c·ªßa ${allRunnerCredentials.find(rc => String(rc.athlete_id) === String(d.athlete_id))?.runner_name || `Runner ID: ${d.athlete_id}`} trong tu·∫ßn ${d.week.split('-W')[1]} (${d.week.split('-W')[0]}):`;
                    });

                monthGroup.selectAll(".bubble-text")
                    .data(positionedWeeks)
                    .enter().append("text")
                    .attr("class", "bubble-text")
                    .attr("x", d => d.cx)
                    .attr("y", d => d.cy)
                    .text(d => d.r > (width < 768 ? 15 : 25) ? `${(d.totalDistance / 1000).toFixed(1)}km` : '')
                    .attr("dy", "0.35em")
                    .attr("fill", "white")
                    .attr("pointer-events", "none");

                currentYOffset += monthBandHeight;
            });
        }

        /**
         * Handles the "Analyze Activities (AI)" button click.
         */
        analyzeActivitiesBtn.addEventListener('click', async () => {
            if (!currentAppUserId) {
                showAlert('Vui l√≤ng ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng ph√¢n t√≠ch AI.');
                return;
            }
            if (userActivities.length === 0) {
                showAlert('Kh√¥ng c√≥ ho·∫°t ƒë·ªông n√†o ƒë·ªÉ ph√¢n t√≠ch. Vui l√≤ng t·∫£i ho·∫°t ƒë·ªông t·ª´ Strava tr∆∞·ªõc.');
                return;
            }

            llmAnalysisSection.classList.remove('hidden');
            llmAnalysisContent.innerHTML = '<div class="loader"></div> ƒêang ph√¢n t√≠ch ho·∫°t ƒë·ªông c·ªßa b·∫°n v·ªõi AI...';
            llmAnalysisStatus.textContent = '';

            llmAnalysisSection.scrollIntoView({ behavior: 'smooth', block: 'start' });

            try {
                // B·∫ÆT ƒê·∫¶U ƒêO·∫†N M√É ƒê√É S·ª¨A ƒê·ªîI ƒê·ªÇ L·∫§Y/L√ÄM M·ªöI SESSION
                // B∆∞·ªõc 1: C·ªë g·∫Øng l√†m m·ªõi session ƒë·ªÉ ƒë·∫£m b·∫£o ch√∫ng ta c√≥ token m·ªõi nh·∫•t
                const { data: { session: refreshedSession }, error: refreshError } = await supabaseClientInstance.auth.refreshSession();

                let currentSession = refreshedSession;
                let sessionError = refreshError;

                // B∆∞·ªõc 2: N·∫øu l√†m m·ªõi th·∫•t b·∫°i ho·∫∑c kh√¥ng c√≥ session m·ªõi,
                // th·ª≠ l·∫•y session hi·ªán t·∫°i tr·ª±c ti·∫øp (c√≥ th·ªÉ ƒë√£ ƒë∆∞·ª£c refresh t·ª± ƒë·ªông ho·∫∑c l√† session c√≤n hi·ªáu l·ª±c)
                if (sessionError || !currentSession?.access_token) {
                    const { data: { session: directSession }, error: directError } = await supabaseClientInstance.auth.getSession();
                    currentSession = directSession;
                    sessionError = directError; // C·∫≠p nh·∫≠t l·ªói n·∫øu c√≥
                }

                // B∆∞·ªõc 3: Ki·ªÉm tra xem ch√∫ng ta c√≥ m·ªôt session h·ª£p l·ªá ƒë·ªÉ s·ª≠ d·ª•ng hay kh√¥ng
                if (sessionError || !currentSession?.access_token) {
                    console.error("L·ªói khi l·∫•y/l√†m m·ªõi session Supabase:", sessionError);
                    showAlert('L·ªói: Kh√¥ng t√¨m th·∫•y phi√™n ƒëƒÉng nh·∫≠p ho·∫∑c phi√™n ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i ƒë·ªÉ ph√¢n t√≠ch AI.');
                    llmAnalysisContent.innerHTML = '<p class="text-red-500">L·ªói x√°c th·ª±c: Kh√¥ng t√¨m th·∫•y phi√™n ƒëƒÉng nh·∫≠p ho·∫∑c phi√™n ƒë√£ h·∫øt h·∫°n.</p>';
                    return;
                }
                // K·∫æT TH√öC ƒêO·∫†N M√É ƒê√É S·ª¨A ƒê·ªîI ƒê·ªÇ L·∫§Y/L√ÄM M·ªöI SESSION

                const activitiesForLLM = userActivities.map(activity => ({
                    id: activity.strava_activity_id,
                    name: activity.name,
                    type: activity.type,
                    distance_m: activity.distance,
                    moving_time_s: activity.moving_time,
                    elevation_gain_m: activity.total_elevation_gain,
                    start_date: activity.start_date,
                    average_speed_mps: activity.average_speed,
                    average_heartrate_bpm: activity.average_heartrate,
                    runner_id: activity.user_id
                }));
                
                const response = await fetch(ANALYZE_ACTIVITIES_FUNCTION_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${currentSession.access_token}` // S·ª¨ D·ª§NG currentSession.access_token
                    },
                    body: JSON.stringify({ 
                        activities: activitiesForLLM,
                        clientTimezone: Intl.DateTimeFormat().resolvedOptions().timeZone || 'Asia/Ho_Chi_Minh' 
                    })
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    let analysisContent = result.analysis;
                    if (typeof analysisContent === 'string') {
                        try {
                            const parsedAnalysis = JSON.parse(analysisContent);
                            if (parsedAnalysis.analysis) {
                                analysisContent = parsedAnalysis.analysis;
                            }
                        } catch (e) {
                            console.warn("Analysis content was a string but not a JSON object, using as-is.");
                        }
                    }

                    if (analysisContent) {
                       const msRegex = /(\d+\.?\d*)\s*(m\/s|mps)/g; // ƒê√£ s·ª≠a ƒë·ªÉ nh·∫≠n di·ªán c·∫£ "m/s" v√† "mps"
                    analysisContent = analysisContent.replace(msRegex, (match, value) => {
                        const speedInMs = parseFloat(value);
                        if (!isNaN(speedInMs)) {
                            return formatPace(speedInMs);
                        }
                        return match;
                    });

                        llmAnalysisContent.innerHTML = marked.parse(analysisContent); 
                        llmAnalysisStatus.textContent = 'Ph√¢n t√≠ch AI ho√†n t·∫•t.';
                    } else {
                        llmAnalysisContent.innerHTML = `<p class="text-red-500">Kh√¥ng th·ªÉ nh·∫≠n ƒë∆∞·ª£c n·ªôi dung ph√¢n t√≠ch t·ª´ AI.</p>`;
                        llmAnalysisStatus.textContent = 'L·ªói: N·ªôi dung ph√¢n t√≠ch tr·ªëng.';
                    }
                } else {
                    llmAnalysisContent.innerHTML = `<p class="text-red-500">Kh√¥ng th·ªÉ nh·∫≠n ƒë∆∞·ª£c ph√¢n t√≠ch t·ª´ AI. L·ªói: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}. Vui l√≤ng th·ª≠ l·∫°i.</p>`;
                    llmAnalysisStatus.textContent = 'L·ªói khi nh·∫≠n ph√¢n t√≠ch t·ª´ AI.';
                    console.error('L·ªói t·ª´ Edge Function ho·∫∑c c·∫•u tr√∫c ph·∫£n h·ªìi AI kh√¥ng mong ƒë·ª£i:', result);
                }

            } catch (error) {
                console.error('L·ªói khi g·ªçi Edge Function ph√¢n t√≠ch AI:', error);
                llmAnalysisContent.innerHTML = `<p class="text-red-500">L·ªói m·∫°ng ho·∫∑c m√°y ch·ªß khi ph√¢n t√≠ch AI: ${error.message}</p>`;
                llmAnalysisStatus.textContent = 'L·ªói trong qu√° tr√¨nh ph√¢n t√≠ch AI.';
            }
        });


        // When the page loads
        window.onload = async () => {
            if (typeof window.supabase === 'undefined') {
                showAlert('L·ªói: Th∆∞ vi·ªán Supabase kh√¥ng ƒë∆∞·ª£c t·∫£i. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi internet ho·∫∑c URL CDN.');
                console.error('Th∆∞ vi·ªán Supabase kh√¥ng ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a. Vui l√≤ng ki·ªÉm tra th·∫ª script CDN Supabase.');
                return;
            }
            supabaseClientInstance = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            
            console.log('Supabase URL:', SUPABASE_URL);
            console.log('Supabase Anon Key (first 10 chars):', SUPABASE_ANON_KEY.substring(0, 10) + '...');

            // Supabase Auth Listener
            supabaseClientInstance.auth.onAuthStateChange((event, session) => {
                console.log('Supabase Auth state changed:', event, session);
                updateAppAuthUI(session?.user || null);
            });

            // Set up event listeners for app authentication forms
            authForm.addEventListener('submit', handleAuth);
        //    guestLoginBtn.addEventListener('click', handleGuestLogin);
            signoutBtn.addEventListener('click', handleSignOut);


            // Set up event listeners for credential management
            addCredentialBtn.addEventListener('click', () => openCredentialModal());
            closeModalBtn.addEventListener('click', () => credentialModal.style.display = 'none');
            cancelModalBtn.addEventListener('click', () => credentialModal.style.display = 'none');
            credentialForm.addEventListener('submit', saveCredential);
            
            // Set up event listener for Strava disconnect button
            disconnectStravaBtn.addEventListener('click', () => {
                clearStravaSession();
                checkStravaAuthState();
                showAlert('ƒê√£ ƒëƒÉng xu·∫•t Strava.');
            });

            // Set up event listener for weekly activities modal close button
            closeWeeklyActivitiesModalBtn.addEventListener('click', () => weeklyActivitiesModal.style.display = 'none');

            // Handle initial Strava OAuth callback if any
            await handleStravaCallback(); 

            // Auto-fill date filters
            const today = new Date();
            const endDate = today.toISOString().split('T')[0];
            endDateRecent.value = endDate;

            const sevenDaysAgo = new Date(today);
            sevenDaysAgo.setDate(today.getDate() - 7);
            const startDate = sevenDaysAgo.toISOString().split('T')[0];
            startDateRecent.value = startDate;

            // Add resize event listener to redraw the chart
            window.addEventListener('resize', () => {
                if (weeklyStatsData && weeklyStatsData.length > 0) {
                    renderBubbleChart(weeklyStatsData);
                }
            });

            // Initialize activity type filters
            populateActivityTypeFilters();
            updateMultiSelectDisplay(multiSelectDisplayRecent, selectedActivityTypesRecent, document.getElementById('multi-select-options-recent'));
            
            runnerRecentActivitiesFilter.addEventListener('change', () => {
                selectedRunnerIdForRecentActivities = runnerRecentActivitiesFilter.value;
                loadRecentActivitiesBtn.click();
            });
            clubRecentActivitiesFilter.addEventListener('change', () => {
                selectedClubNameForRecentActivities = clubRecentActivitiesFilter.value;
                loadRecentActivitiesBtn.click();
            });


           document.querySelectorAll('.collapsible-header').forEach(header => {
                header.addEventListener('click', () => {
                    const targetId = header.dataset.target;
                    const contentElement = document.getElementById(targetId);
                    const toggleIcon = header.querySelector('.toggle-icon');
                    const stateKey = header.dataset.stateKey; // <-- TH√äM D√íNG N√ÄY: L·∫•y gi√° tr·ªã data-state-key
                    toggleCollapsible(contentElement, toggleIcon, undefined, stateKey); // <-- S·ª¨A D√íNG N√ÄY: Truy·ªÅn stateKey v√†o
                });
            });
            toggleCollapsible(downloadForOtherContent, downloadForOtherSection.querySelector('.toggle-icon'), true);


            penaltyPerKmGt10Input.addEventListener('input', renderDetailedStatsTable); 
            penaltyPerKmLte10Input.addEventListener('input', renderDetailedStatsTable); 
            targetKmPerWeekInput.addEventListener('input', renderDetailedStatsTable);

            startDateRecent.addEventListener('change', () => loadRecentActivitiesBtn.click());
            endDateRecent.addEventListener('change', () => loadRecentActivitiesBtn.click());

            runnerStatsFilter.addEventListener('change', () => {
                selectedRunnerIdForStats = runnerStatsFilter.value;
                if (weeklyStatsData.length > 0) {
                    renderBubbleChart(weeklyStatsData);
                }
            });
            clubStatsFilter.addEventListener('change', () => {
                selectedClubIdForStats = clubStatsFilter.value;
                populateRunnerStatsFilter(); 
                if (weeklyStatsData.length > 0) {
                    renderBubbleChart(weeklyStatsData);
                }
            });

            // Initial collapse instruction section
            toggleCollapsible(instructionContent, instructionSection.querySelector('.toggle-icon'), true);
            
            // Scroll-to-top button logic
            window.onscroll = function() {
                if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                    scrollToTopBtn.style.display = "block";
                } else {
                    scrollToTopBtn.style.display = "none";
                }
            };
            scrollToTopBtn.addEventListener('click', () => {
                window.scrollTo({top: 0, behavior: 'smooth'});
            });

    // Danh s√°ch c√°c section c·∫ßn kh√¥i ph·ª•c tr·∫°ng th√°i
    const sectionsToRestoreState = [
        'data-section-part1',
        'data-section-part2',
        'detailed-stats-section',
        'stats-section',
        'app-auth-section', // ƒê√£ c√≥ data-state-key
        'credential-management-section', // ƒê√£ c√≥ data-state-key
        'strava-auth-section', // ƒê√£ c√≥ data-state-key
        'download-for-other-section', // ƒê√£ c√≥ data-state-key
        'instruction-section' // ƒê√£ c√≥ data-state-key
    ];

    sectionsToRestoreState.forEach(sectionId => {
        const header = document.getElementById(sectionId)?.querySelector('.collapsible-header');
        const content = document.getElementById(header?.dataset.target);
        const toggleIcon = header?.querySelector('.toggle-icon');
        const stateKey = header?.dataset.stateKey;

        const sectionsToRestoreState = [
        'data-section-part1',
        'data-section-part2',
        'detailed-stats-section',
        'stats-section'
    ];

         sectionsToRestoreState.forEach(sectionId => {
        const header = document.getElementById(sectionId)?.querySelector('.collapsible-header');
        const content = document.getElementById(header?.dataset.target);
        const toggleIcon = header?.querySelector('.toggle-icon');
        const stateKey = header?.dataset.stateKey;

        console.log(`--- ƒêang ki·ªÉm tra section: ${sectionId} ---`);
        console.log(`  Header t√¨m th·∫•y:`, header ? true : false);
        console.log(`  data-target c·ªßa header:`, header?.dataset.target);
        console.log(`  Content element t√¨m th·∫•y (id: ${header?.dataset.target}):`, content ? true : false); // <-- R·∫•t quan tr·ªçng
        console.log(`  Toggle Icon t√¨m th·∫•y:`, toggleIcon ? true : false);
        console.log(`  State Key t√¨m th·∫•y:`, stateKey);

        if (header && content && toggleIcon && stateKey) {
            const savedState = localStorage.getItem(stateKey);
            console.log(`  Tr·∫°ng th√°i ƒë√£ l∆∞u cho <span class="math-inline">\{stateKey\} t·ª´ Local Storage\: "</span>{savedState}"`);
            const isCollapsed = savedState === 'collapsed';
            console.log(`  isCollapsed s·∫Ω l√†: ${isCollapsed}`);
            toggleCollapsible(content, toggleIcon, isCollapsed, stateKey);
            console.log(`  ƒê√£ g·ªçi toggleCollapsible cho ${sectionId}`);
        } else {
            console.warn(`  C·∫£nh b√°o: Kh√¥ng th·ªÉ kh√¥i ph·ª•c tr·∫°ng th√°i cho ${sectionId}. Thi·∫øu m·ªôt trong c√°c ph·∫ßn t·ª≠ (header, content, toggleIcon, ho·∫∑c stateKey).`);
        }
        console.log(`----------------------------------------`);
    });
        
        if (header && content && toggleIcon && stateKey) {
            const savedState = localStorage.getItem(stateKey);
            // M·∫∑c ƒë·ªãnh l√† 'expanded' n·∫øu kh√¥ng c√≥ tr·∫°ng th√°i l∆∞u
            const isCollapsed = savedState === 'collapsed'; 
            // √Åp d·ª•ng tr·∫°ng th√°i. forceCollapse l√† true n·∫øu mu·ªën thu g·ªçn, false n·∫øu mu·ªën m·ªü r·ªông.
            toggleCollapsible(content, toggleIcon, isCollapsed, stateKey);
        }
    });




            
            // Trigger initial load of recent activities and detailed stats after all setup
            // This is triggered by onAuthStateChange now
        
        // ... (c√°c ƒëo·∫°n m√£ kh√°c trong window.onload) ...

    // L·∫Øng nghe s·ª± ki·ªán click cho n√∫t "Hi·ªán/·∫®n C√†i ƒë·∫∑t"
    if (toggleSettingsBtn) { // ƒê·∫£m b·∫£o n√∫t t·ªìn t·∫°i
        toggleSettingsBtn.addEventListener('click', () => {
            // L·∫•y tr·∫°ng th√°i hi·ªán t·∫°i t·ª´ localStorage ho·∫∑c m·∫∑c ƒë·ªãnh l√† true (hi·ªán)
            const currentVisibility = localStorage.getItem(SETTINGS_VISIBILITY_KEY) === 'true';
            // ƒê·∫£o ng∆∞·ª£c tr·∫°ng th√°i v√† √°p d·ª•ng
            applySettingsVisibility(!currentVisibility);
        });
    }
}; // ƒê√¢y l√† d·∫•u ƒë√≥ng ngo·∫∑c nh·ªçn c·ªßa window.onload
        
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>·ª®ng d·ª•ng Qu·∫£n l√Ω Th√†nh t√≠ch Ch·∫°y b·ªô - FOR RUNNER LOVER</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* Define BIDV brand colors */
        :root {
            --bidv-green: #006b68;
            --bidv-yellow: #FFC62F;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Adjust primary button to BIDV green */
        .btn-primary {
            background-color: var(--bidv-green);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn-primary:hover {
            background-color: #005a57; /* Darker green on hover */
        }

        /* Adjust secondary button to BIDV yellow */
        .btn-secondary {
            background-color: var(--bidv-yellow);
            color: #333;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn-secondary:hover {
            background-color: #e6b32a; /* Darker yellow on hover */
        }

        .btn-danger {
            @apply bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600 transition duration-300 ease-in-out shadow-md;
        }

        .form-input {
            @apply w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-orange-500;
        }
        
        /* Custom styles for multi-select */
        .multi-select-container {
            position: relative;
        }

        .multi-select-selected-items {
            @apply w-full p-2 border border-gray-300 rounded-md bg-white cursor-pointer flex flex-wrap gap-1;
            min-height: 42px; /* Ensure consistent height */
            align-items: center;
        }

        .multi-select-selected-item {
            @apply bg-gray-200 text-gray-700 text-xs px-2 py-1 rounded-full flex items-center gap-1;
        }

        .multi-select-selected-item span {
            cursor: pointer;
            font-weight: bold;
        }

        .multi-select-options {
            @apply absolute w-full border border-gray-300 rounded-md bg-white shadow-lg z-10;
            max-height: 200px;
            overflow-y: auto;
        }

        .multi-select-option {
            @apply p-2 cursor-pointer hover:bg-gray-100;
        }

        .multi-select-option.selected {
            @apply bg-blue-100 font-semibold;
        }

        .card {
            background-color: white;
            border-radius: 0.75rem;
            padding: 1.5rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none; /* Hidden by default */
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.75rem;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            position: relative;
        }
        .close-button {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 1.5rem;
            cursor: pointer;
            color: #9ca3af;
        }

        /* Styling for the bubble chart container */
        #bubble-chart-container {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: hidden; /* Hide horizontal overflow */
            overflow-y: auto; /* Allow vertical scrolling */
            background-color: #f9fafb; /* Light background for chart */
            border-radius: 0.5rem;
            min-height: 300px;
        }

        .bubble {
            stroke: var(--bidv-green);
            stroke-width: 2px;
            fill-opacity: 0.7;
            cursor: pointer;
            transition: fill-opacity 0.3s ease;
        }

        .bubble:hover {
            fill-opacity: 1;
        }

        .bubble-text {
            font-size: 0.8rem;
            text-anchor: middle;
            fill: white;
            pointer-events: none; /* Allow clicks to pass through text to bubble */
        }

        .tooltip {
            position: absolute;
            text-align: center;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 0.5rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.9rem;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            .flex-wrap > .btn-primary, .flex-wrap > .btn-secondary {
                flex-basis: 100%; /* Full width for buttons on small screens */
            }
        }

        /* Loading spinner for LLM analysis */
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid var(--bidv-green); /* BIDV Green */
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Collapsible Section Styles */
        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding-bottom: 1rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid #eee;
        }

        .collapsible-header h2 {
            margin-bottom: 0;
        }

        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            max-height: 1000px; /* Large enough to show content */
        }

        .collapsible-content.collapsed {
            max-height: 0;
        }

        .toggle-icon {
            transition: transform 0.3s ease-out;
        }

        .toggle-icon.rotate {
            transform: rotate(90deg);
        }

        /* Table styles */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }
        .data-table th, .data-table td {
            border: 1px solid #e2e8f0;
            padding: 0.75rem;
            text-align: left;
        }
        .data-table th {
            background-color: var(--bidv-green);
            color: white;
            font-weight: bold;
            font-size: 0.875rem;
            text-transform: uppercase;
        }
        .data-table tbody tr:nth-child(even) {
            background-color: #f8fafc;
        }
        .data-table tbody tr:hover {
            background-color: #f0f2f5;
        }
        .data-table .total-row {
            background-color: #e0f2f1; /* Light green for total rows */
            font-weight: bold;
        }
        .data-table .summary-row {
            background-color: #d1e7dd; /* Slightly darker green for summary */
            font-weight: bold;
        }
        .data-table .missing-row {
            background-color: #fee2e2; /* Light red for missing info */
            color: #ef4444;
            font-weight: bold;
        }

        /* Date picker styles */
        input[type="date"]::-webkit-calendar-picker-indicator {
            background: transparent;
            bottom: 0;
            color: transparent;
            cursor: pointer;
            height: auto;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            width: auto;
        }
        input[type="date"] {
            position: relative;
        }
        input[type="date"]::-webkit-inner-spin-button,
        input[type="date"]::-webkit-clear-button {
            display: none;
        }
    </style>
</head>
<body>
    <header class="bg-bidv-green p-4 shadow-md">
        <div class="container flex justify-between items-center">
            <div class="flex items-center space-x-4">
                <img src="https://placehold.co/50x50/006B68/FFC62F?text=BIDV" alt="Logo BIDV Running Club" class="h-12 w-auto rounded-md">
                <h1 class="text-2xl font-bold text-bidv-yellow">üèÉ‚Äç‚ôÇÔ∏è‚Äç‚û°Ô∏èRunning Lovers with AI‚ú®</h1>
            </div>
            <nav>
                <span id="app-user-status" class="text-white text-sm"></span>
            </nav>
        </div>
    </header>

    <main class="flex-grow container py-8">
        <!-- Application Authentication Section (Supabase Auth) -->
        <section id="app-auth-section" class="card mb-8">
            <div class="collapsible-header" data-target="app-auth-content">
                <h2 class="text-xl font-semibold">ƒêƒÉng nh·∫≠p/ƒêƒÉng k√Ω ·ª®ng d·ª•ng</h2>
                <svg class="toggle-icon w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
            </div>
            <div id="app-auth-content" class="collapsible-content">
                <div id="logged-out-view">
                    <form id="auth-form" class="space-y-4 mb-4">
                        <div>
                            <label for="auth-email" class="block text-gray-700 text-sm font-bold mb-2">Email:</label>
                            <input type="email" id="auth-email" class="form-input" placeholder="example@email.com" required>
                        </div>
                        <div>
                            <label for="auth-password" class="block text-gray-700 text-sm font-bold mb-2">M·∫≠t kh·∫©u:</label>
                            <input type="password" id="auth-password" class="form-input" placeholder="M·∫≠t kh·∫©u c·ªßa b·∫°n" required>
                        </div>
                        <div class="flex justify-end gap-2">
                            <button type="submit" id="signup-btn" class="btn-secondary">ƒêƒÉng k√Ω</button>
                            <button type="submit" id="signin-btn" class="btn-primary">ƒêƒÉng nh·∫≠p</button>
                        </div>
                    </form>
                    <div class="text-center">
                        <p class="text-sm text-gray-600 mb-2">Ho·∫∑c:</p>
                        <button id="guest-login-btn" class="btn-secondary">Ti·∫øp t·ª•c v·ªõi t∆∞ c√°ch Kh√°ch</button>
                    </div>
                    <div id="auth-message" class="mt-4 text-sm text-center text-red-500"></div>
                </div>
                <div id="logged-in-view" class="hidden text-center">
                    <p class="mb-4 text-lg font-medium">Ch√†o m·ª´ng, <span id="current-app-user-email"></span>!</p>
                    <button id="signout-btn" class="btn-danger">ƒêƒÉng xu·∫•t ·ª®ng d·ª•ng</button>
                </div>
            </div>
        </section>

        <!-- Credential Management Section -->
        <section class="card mb-8 hidden" id="credential-management-section">
            <div class="collapsible-header" data-target="credential-management-content">
                <h2 class="text-xl font-semibold">Qu·∫£n l√Ω Runner (Th√¥ng tin ƒëƒÉng nh·∫≠p Strava)</h2>
                <div class="flex items-center gap-2">
                    <button id="add-credential-btn" class="btn-primary text-sm px-3 py-1">Th√™m Runner m·ªõi</button>
                    <svg class="toggle-icon w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                </div>
            </div>
            <div id="credential-management-content" class="collapsible-content">
                <div id="credentials-list" class="space-y-4">
                    <!-- Credentials will be loaded here -->
                    <p class="text-gray-500 text-center" id="no-credentials-message">Kh√¥ng c√≥ runner n√†o ƒë∆∞·ª£c l∆∞u.</p>
                </div>
                <p id="loading-credentials" class="text-gray-500 text-center hidden">ƒêang t·∫£i th√¥ng tin runner...</p>
                <p id="error-credentials" class="text-red-500 text-center hidden">L·ªói khi t·∫£i th√¥ng tin runner.</p>
            </div>
        </section>

        <!-- Strava Login Section (Adjusted) -->
        <section id="strava-auth-section" class="card mb-8 text-center hidden">
            <div class="collapsible-header" data-target="strava-auth-content">
                <h2 class="text-xl font-semibold">K·∫øt n·ªëi t√†i kho·∫£n Strava c·ªßa b·∫°n</h2>
                <svg class="toggle-icon w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
            </div>
            <div id="strava-auth-content" class="collapsible-content">
                <p class="mb-6">ƒê·ªÉ theo d√µi th√†nh t√≠ch ch·∫°y b·ªô, vui l√≤ng ch·ªçn m·ªôt runner v√† k·∫øt n·ªëi v·ªõi Strava.</p>
                
                <div class="mb-4">
                    <label for="runner-select" class="block text-gray-700 text-sm font-bold mb-2">Ch·ªçn Runner ƒë·ªÉ ƒëƒÉng nh·∫≠p:</label>
                    <select id="runner-select" class="form-input">
                        <option value="">-- Ch·ªçn Runner --</option>
                    </select>
                    <p class="text-xs text-gray-500 mt-1">Ch·ªçn runner ƒë√£ th√™m ·ªü tr√™n ƒë·ªÉ k·∫øt n·ªëi v·ªõi Strava.</p>
                </div>

                <button id="connect-strava-btn" class="btn-primary">
                    ƒêƒÉng nh·∫≠p v·ªõi Strava
                </button>
                <button id="disconnect-strava-btn" class="btn-secondary hidden ml-4">
                    ƒêƒÉng xu·∫•t Strava
                </button>
                <div id="auth-status" class="mt-4 text-sm text-gray-600"></div>
                <p id="current-runner-display" class="mt-2 text-center text-sm text-gray-600 hidden">ƒêang ƒëƒÉng nh·∫≠p v·ªõi: <span class="font-semibold" id="current-runner-name"></span></p>
            </div>
        </section>

        <!-- Activity Data & Visualization Section -->
        <section id="data-section" class="card mb-8 hidden">
            <h2 class="text-xl font-semibold mb-4">D·ªØ li·ªáu th√†nh t√≠ch ch·∫°y b·ªô</h2>
            <p id="user-info" class="mb-4 text-lg font-medium"></p>
            <div class="mb-4">
                <label for="activities-limit" class="block text-gray-700 text-sm font-bold mb-2">S·ªë l∆∞·ª£ng ho·∫°t ƒë·ªông mu·ªën t·∫£i t·ª´ Strava (m·∫∑c ƒë·ªãnh 60):</label>
                <input type="number" id="activities-limit" class="form-input" value="60" min="1" step="1">
            </div>

            <!-- Activity Type Filter for Recent Activities -->
            <div class="mb-4">
                <label for="activity-type-filter-recent" class="block text-gray-700 text-sm font-bold mb-2">L·ªçc theo lo·∫°i ho·∫°t ƒë·ªông:</label>
                <div class="multi-select-container">
                    <div id="multi-select-display-recent" class="multi-select-selected-items">
                        <span class="text-gray-500">Ch·ªçn lo·∫°i ho·∫°t ƒë·ªông</span>
                    </div>
                    <div id="multi-select-options-recent" class="multi-select-options hidden">
                        <!-- Options will be populated by JS -->
                    </div>
                </div>
            </div>

            <!-- Date Range Filter for Recent Activities -->
            <div class="mb-4 flex gap-4">
                <div class="flex-1">
                    <label for="start-date-recent" class="block text-gray-700 text-sm font-bold mb-2">T·ª´ ng√†y:</label>
                    <input type="date" id="start-date-recent" class="form-input">
                </div>
                <div class="flex-1">
                    <label for="end-date-recent" class="block text-gray-700 text-sm font-bold mb-2">ƒê·∫øn ng√†y:</label>
                    <input type="date" id="end-date-recent" class="form-input">
                </div>
            </div>

            <div class="flex flex-wrap gap-4 mb-6">
                <button id="fetch-activities-btn" class="btn-primary">
                    T·∫£i/C·∫≠p nh·∫≠t d·ªØ li·ªáu t·ª´ Strava
                </button>
                <button id="view-stats-btn" class="btn-secondary">
                    Xem th·ªëng k√™ theo tu·∫ßn
                </button>
                <button id="analyze-activities-btn" class="btn-primary">
                    ‚ú® Ph√¢n t√≠ch ho·∫°t ƒë·ªông (AI)
                </button>
            </div>
            <div id="data-status" class="mt-4 text-sm text-gray-600"></div>

            <div id="activities-list-section" class="mt-6 border-t pt-4">
                <h3 class="text-lg font-semibold mb-3">C√°c ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y:</h3>
                <div class="mb-4">
                    <label for="num-recent-activities" class="block text-gray-700 text-sm font-bold mb-2">S·ªë l∆∞·ª£ng ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y mu·ªën hi·ªÉn th·ªã (m·∫∑c ƒë·ªãnh 10):</label>
                    <input type="number" id="num-recent-activities" class="form-input" value="10" min="1" step="1">
                </div>
                <button id="load-recent-activities-btn" class="btn-secondary mb-4">
                    T·∫£i ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y
                </button>
                <ul id="recent-activities" class="space-y-2 text-sm">
                    <li class="text-gray-500">Nh·∫•n "T·∫£i ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y" ƒë·ªÉ xem.</li>
                </ul>
                <div id="recent-activities-status" class="mt-2 text-sm text-gray-600"></div>
            </div>

            <div id="llm-analysis-section" class="mt-6 border-t pt-4 hidden">
                <h3 class="text-lg font-semibold mb-3">Ph√¢n t√≠ch ho·∫°t ƒë·ªông c·ªßa b·∫°n:</h3>
                <div id="llm-analysis-content" class="bg-gray-100 p-4 rounded-md text-sm">
                    <p class="text-gray-500">Nh·∫•n "‚ú® Ph√¢n t√≠ch ho·∫°t ƒë·ªông (AI)" ƒë·ªÉ nh·∫≠n ph√¢n t√≠ch t·ª´ AI.</p>
                </div>
                <div id="llm-analysis-status" class="mt-2 text-sm text-gray-600"></div>
            </div>

        </section>

        <section id="stats-section" class="card hidden">
            <h2 class="text-xl font-semibold mb-4">Th·ªëng k√™ th√†nh t√≠ch theo tu·∫ßn</h2>
             <!-- Activity Type Filter for Stats -->
            <div class="mb-4">
                <label for="activity-type-filter-stats" class="block text-gray-700 text-sm font-bold mb-2">L·ªçc theo lo·∫°i ho·∫°t ƒë·ªông cho th·ªëng k√™:</label>
                <div class="multi-select-container">
                    <div id="multi-select-display-stats" class="multi-select-selected-items">
                        <span class="text-gray-500">Ch·ªçn lo·∫°i ho·∫°t ƒë·ªông</span>
                    </div>
                    <div id="multi-select-options-stats" class="multi-select-options hidden">
                        <!-- Options will be populated by JS -->
                    </div>
                </div>
            </div>

            <!-- Date Range Filter for Stats -->
            <div class="mb-4 flex gap-4">
                <div class="flex-1">
                    <label for="start-date-stats" class="block text-gray-700 text-sm font-bold mb-2">T·ª´ ng√†y:</label>
                    <input type="date" id="start-date-stats" class="form-input">
                </div>
                <div class="flex-1">
                    <label for="end-date-stats" class="block text-gray-700 text-sm font-bold mb-2">ƒê·∫øn ng√†y:</label>
                    <input type="date" id="end-date-stats" class="form-input">
                </div>
            </div>

            <div id="bubble-chart-container">
                <p class="text-gray-500 text-center">Nh·∫•n "Xem th·ªëng k√™ theo tu·∫ßn" ƒë·ªÉ hi·ªÉn th·ªã bi·ªÉu ƒë·ªì.</p>
            </div>
            <div id="chart-status" class="mt-4 text-sm text-gray-600"></div>

            <h3 class="text-xl font-semibold mt-8 mb-4">Th·ªëng k√™ chi ti·∫øt & Ti·ªÅn ph·∫°t/Th∆∞·ªüng</h3>
            <div class="mb-4 flex gap-4 items-end">
                <div class="flex-1">
                    <label for="penalty-per-km" class="block text-gray-700 text-sm font-bold mb-2">S·ªë ti·ªÅn ph·∫°t 1KM (ngh√¨n VNƒê):</label>
                    <input type="number" id="penalty-per-km" class="form-input" value="30" min="0" step="1">
                </div>
                <div class="flex-1">
                    <label for="target-km-per-week" class="block text-gray-700 text-sm font-bold mb-2">S·ªë KM m·ªôt tu·∫ßn (KM):</label>
                    <input type="number" id="target-km-per-week" class="form-input" value="25" min="0" step="1">
                </div>
            </div>
            <div id="detailed-stats-table-container" class="overflow-x-auto">
                <table id="detailed-stats-table" class="data-table">
                    <thead>
                        <tr>
                            <th>T√™n Runner</th>
                            <th>Ng√†y ch·∫°y</th>
                            <th>Lo·∫°i ho·∫°t ƒë·ªông</th>
                            <th>Qu√£ng ƒë∆∞·ªùng (KM)</th>
                            <th>Pace</th>
                            <th>Nh·ªãp tim TB</th>
                            <th>ƒê·ªô cao tƒÉng</th>
                            <th>Th·ªùi gian ch·∫°y</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Detailed activities and summary rows will be inserted here -->
                    </tbody>
                </table>
                <p id="detailed-stats-status" class="mt-4 text-sm text-gray-600 text-center">Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã.</p>
            </div>
        </section>

        <!-- Instruction Section -->
        <section id="instruction-section" class="card mb-8">
            <div class="collapsible-header" data-target="instruction-content">
                <h2 class="text-xl font-semibold">H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng ·ª©ng d·ª•ng</h2>
                <svg class="toggle-icon w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
            </div>
            <div id="instruction-content" class="collapsible-content">
                <div class="space-y-4 text-gray-700 max-h-96 overflow-y-auto pr-2">
                    <p>Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi ·ª®ng d·ª•ng Qu·∫£n l√Ω Th√†nh t√≠ch Ch·∫°y b·ªô - FOR RUNNER LOVER!</p>
                    <h3 class="font-bold text-lg text-bidv-green">1. ƒêƒÉng nh·∫≠p/ƒêƒÉng k√Ω ·ª®ng d·ª•ng:</h3>
                    <ul class="list-disc ml-6 space-y-1">
                        <li>B·∫°n c√≥ th·ªÉ ƒëƒÉng k√Ω t√†i kho·∫£n m·ªõi b·∫±ng Email v√† M·∫≠t kh·∫©u.</li>
                        <li>ƒêƒÉng nh·∫≠p n·∫øu ƒë√£ c√≥ t√†i kho·∫£n.</li>
                        <li>Ho·∫∑c ch·ªçn "Ti·∫øp t·ª•c v·ªõi t∆∞ c√°ch Kh√°ch" ƒë·ªÉ s·ª≠ d·ª•ng c√°c ch·ª©c nƒÉng c∆° b·∫£n m√† kh√¥ng c·∫ßn ƒëƒÉng k√Ω.</li>
                    </ul>
                    <h3 class="font-bold text-lg text-bidv-green">2. Qu·∫£n l√Ω Runner (Th√¥ng tin ƒëƒÉng nh·∫≠p Strava):</h3>
                    <ul class="list-disc ml-6 space-y-1">
                        <li>Sau khi ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng, b·∫°n c√≥ th·ªÉ th√™m th√¥ng tin ƒëƒÉng nh·∫≠p Strava (Client ID, Client Secret, Refresh Token) cho c√°c Runner kh√°c nhau (v√≠ d·ª•: t√†i kho·∫£n c√° nh√¢n, t√†i kho·∫£n c·ªßa b·∫°n b√®/gia ƒë√¨nh).</li>
                        <li>Nh·∫•n "Th√™m Runner m·ªõi" ƒë·ªÉ m·ªü c·ª≠a s·ªï nh·∫≠p th√¥ng tin.</li>
                        <li>B·∫°n c√≥ th·ªÉ s·ª≠a ho·∫∑c x√≥a th√¥ng tin Runner ƒë√£ l∆∞u.</li>
                        <li>L∆∞u √Ω: "Redirect URI" l√† c·ªë ƒë·ªãnh v√† kh√¥ng c·∫ßn thay ƒë·ªïi.</li>
                    </ul>
                    <h3 class="font-bold text-lg text-bidv-green">3. K·∫øt n·ªëi t√†i kho·∫£n Strava c·ªßa b·∫°n:</h3>
                    <ul class="list-disc ml-6 space-y-1">
                        <li>Ch·ªçn m·ªôt Runner t·ª´ danh s√°ch b·∫°n ƒë√£ th√™m.</li>
                        <li>Nh·∫•n "ƒêƒÉng nh·∫≠p v·ªõi Strava" ƒë·ªÉ ƒë∆∞·ª£c chuy·ªÉn h∆∞·ªõng ƒë·∫øn trang ·ªßy quy·ªÅn c·ªßa Strava. Vui l√≤ng c·∫•p quy·ªÅn `activity:read_all`.</li>
                        <li>Sau khi c·∫•p quy·ªÅn, b·∫°n s·∫Ω ƒë∆∞·ª£c chuy·ªÉn h∆∞·ªõng v·ªÅ ·ª©ng d·ª•ng v√† t√†i kho·∫£n Strava c·ªßa Runner ƒë√£ ch·ªçn s·∫Ω ƒë∆∞·ª£c k·∫øt n·ªëi.</li>
                        <li>S·ª≠ d·ª•ng "ƒêƒÉng xu·∫•t Strava" ƒë·ªÉ ng·∫Øt k·∫øt n·ªëi.</li>
                    </ul>
                    <h3 class="font-bold text-lg text-bidv-green">4. D·ªØ li·ªáu th√†nh t√≠ch ch·∫°y b·ªô:</h3>
                    <ul class="list-disc ml-6 space-y-1">
                        <li><strong>T·∫£i/C·∫≠p nh·∫≠t d·ªØ li·ªáu t·ª´ Strava:</strong> T·∫£i c√°c ho·∫°t ƒë·ªông ch·∫°y b·ªô t·ª´ t√†i kho·∫£n Strava ƒëang k·∫øt n·ªëi v·ªÅ c∆° s·ªü d·ªØ li·ªáu c·ªßa ·ª©ng d·ª•ng. B·∫°n c√≥ th·ªÉ gi·ªõi h·∫°n s·ªë l∆∞·ª£ng ho·∫°t ƒë·ªông mu·ªën t·∫£i.</li>
                        <li><strong>L·ªçc theo lo·∫°i ho·∫°t ƒë·ªông:</strong> Ch·ªçn m·ªôt ho·∫∑c nhi·ªÅu lo·∫°i ho·∫°t ƒë·ªông (v√≠ d·ª•: Run, Ride, Swim) ƒë·ªÉ l·ªçc d·ªØ li·ªáu hi·ªÉn th·ªã.</li>
                        <li><strong>L·ªçc theo th·ªùi gian "T·ª´ ng√†y ƒë·∫øn ng√†y":</strong> Ch·ªçn kho·∫£ng th·ªùi gian ƒë·ªÉ l·ªçc c√°c ho·∫°t ƒë·ªông.</li>
                        <li><strong>C√°c ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y:</strong> Hi·ªÉn th·ªã danh s√°ch c√°c ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y nh·∫•t ƒë√£ ƒë∆∞·ª£c t·∫£i v·ªÅ, c√≥ th·ªÉ t√πy ch·ªânh s·ªë l∆∞·ª£ng hi·ªÉn th·ªã.</li>
                        <li><strong>Ph√¢n t√≠ch ho·∫°t ƒë·ªông (AI):</strong> S·ª≠ d·ª•ng AI ƒë·ªÉ ph√¢n t√≠ch c√°c ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y c·ªßa b·∫°n, ƒë∆∞a ra c√°i nh√¨n t·ªïng quan v·ªÅ hi·ªáu su·∫•t. Ph√¢n t√≠ch n√†y s·∫Ω t√≠nh ƒë·∫øn c√°c b·ªô l·ªçc hi·ªán c√≥.</li>
                    </ul>
                    <h3 class="font-bold text-lg text-bidv-green">5. Th·ªëng k√™ th√†nh t√≠ch theo tu·∫ßn:</h3>
                    <ul class="list-disc ml-6 space-y-1">
                        <li>Hi·ªÉn th·ªã bi·ªÉu ƒë·ªì bong b√≥ng th·ªëng k√™ t·ªïng qu√£ng ƒë∆∞·ªùng ch·∫°y theo tu·∫ßn. K√≠ch th∆∞·ªõc bong b√≥ng t∆∞∆°ng ·ª©ng v·ªõi qu√£ng ƒë∆∞·ªùng.</li>
                        <li>Click v√†o bong b√≥ng ƒë·ªÉ xem chi ti·∫øt c√°c ho·∫°t ƒë·ªông trong tu·∫ßn ƒë√≥.</li>
                        <li>Bi·ªÉu ƒë·ªì c≈©ng c√≥ th·ªÉ ƒë∆∞·ª£c l·ªçc theo lo·∫°i ho·∫°t ƒë·ªông v√† kho·∫£ng th·ªùi gian.</li>
                    </ul>
                    <h3 class="font-bold text-lg text-bidv-green">6. Th·ªëng k√™ chi ti·∫øt & Ti·ªÅn ph·∫°t/Th∆∞·ªüng:</h3>
                    <ul class="list-disc ml-6 space-y-1">
                        <li>Khu v·ª±c n√†y cho ph√©p b·∫°n theo d√µi chi ti·∫øt t·ª´ng ho·∫°t ƒë·ªông v√† t√≠nh to√°n c√°c kho·∫£n "ti·ªÅn ph·∫°t" n·∫øu kh√¥ng ƒë·∫°t m·ª•c ti√™u KM h√†ng tu·∫ßn.</li>
                        <li>Nh·∫≠p "S·ªë ti·ªÅn ph·∫°t 1KM" v√† "S·ªë KM m·ªôt tu·∫ßn" theo m·ª•c ti√™u c·ªßa b·∫°n.</li>
                        <li>B·∫£ng s·∫Ω t·ª± ƒë·ªông c·∫≠p nh·∫≠t ƒë·ªÉ hi·ªÉn th·ªã th√¥ng tin chi ti·∫øt t·ª´ng ho·∫°t ƒë·ªông ƒë√£ l·ªçc v√† t√≠nh to√°n t·ªïng k·∫øt cho t·ª´ng runner, bao g·ªìm s·ªë KM thi·∫øu v√† s·ªë ti·ªÅn thi·∫øu.</li>
                    </ul>
                    <p class="mt-4">Ch√∫c b·∫°n c√≥ nh·ªØng tr·∫£i nghi·ªám tuy·ªát v·ªùi v·ªõi ·ª©ng d·ª•ng!</p>
                </div>
            </div>
        </section>

    </main>

    <footer class="bg-bidv-green text-white p-4 text-center text-sm">
        <div class="container" style="color: var(--bidv-yellow);">
            &copy; 2025 Tr∆∞∆°ng H·ªìng Qu√¢n - BIDV Running Club. All rights reserved (Dev by AIs - Gemini, GPT).
        </div>
    </footer>

    <!-- Credential Modal -->
    <div id="credential-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="close-modal-btn">&times;</span>
            <h3 id="modal-title" class="text-2xl font-bold mb-4 text-gray-800">Th√™m th√¥ng tin ƒëƒÉng nh·∫≠p Runner</h3>
            <form id="credential-form" class="space-y-4">
                <div>
                    <label for="runner-name" class="block text-gray-700 text-sm font-bold mb-2">T√™n Runner:</label>
                    <input type="text" id="runner-name" class="form-input" placeholder="V√≠ d·ª•: MyRunningAccount" required>
                </div>
                <div>
                    <label for="client-id" class="block text-gray-700 text-sm font-bold mb-2">Client ID:</label>
                    <input type="text" id="client-id" class="form-input" placeholder="Nh·∫≠p Strava Client ID" required>
                </div>
                <div>
                    <label for="client-secret" class="block text-gray-700 text-sm font-bold mb-2">Client Secret:</label>
                    <input type="password" id="client-secret" class="form-input" placeholder="Nh·∫≠p Strava Client Secret" required>
                </div>
                <div>
                    <label for="refresh-token" class="block text-gray-700 text-sm font-bold mb-2">Refresh Token:</label>
                    <input type="password" id="refresh-token" class="form-input" placeholder="Nh·∫≠p Strava Refresh Token" required>
                </div>
                <div>
                    <label for="redirect-uri" class="block text-gray-700 text-sm font-bold mb-2">Redirect URI:</label>
                    <!-- Updated: Value is now fixed and input is readonly -->
                    <input type="text" id="redirect-uri" class="form-input" value="https://quantrh.github.io/Strava/index1.html" readonly required>
                </div>
                <input type="hidden" id="credential-id">
                <div class="flex justify-end gap-2 mt-6">
                    <button type="button" id="cancel-modal-btn" class="btn-secondary">H·ªßy</button>
                    <button type="submit" class="btn-primary">L∆∞u th√¥ng tin</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Weekly Activities Modal -->
    <div id="weekly-activities-modal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <span class="close-button" id="close-weekly-activities-modal-btn">&times;</span>
            <h3 id="weekly-activities-title" class="text-2xl font-bold mb-4 text-gray-800">Ho·∫°t ƒë·ªông trong tu·∫ßn:</h3>
            <div class="max-h-96 overflow-y-auto border rounded-md p-2">
                <ul id="weekly-activities-list" class="space-y-2 text-sm">
                    <!-- Activities will be loaded here -->
                </ul>
            </div>
            <p id="weekly-activities-status" class="mt-4 text-sm text-gray-600"></p>
        </div>
    </div>

    <!-- Custom Alert/Confirm Modals -->
    <div id="custom-alert" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full text-center">
            <p id="alert-message" class="mb-4 text-lg"></p>
            <button id="alert-ok-btn" class="btn-primary">OK</button>
        </div>
    </div>

    <div id="custom-confirm-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full text-center">
            <p id="confirm-message" class="mb-4 text-lg"></p>
            <div class="flex justify-center gap-4">
                <button id="confirm-cancel-btn" class="btn-secondary">H·ªßy</button>
                <button id="confirm-ok-btn" class="btn-danger">ƒê·ªìng √Ω</button>
            </div>
        </div>
    </div>

    <script>
        // Function to display custom alert instead of alert()
        function showAlert(message) {
            const customAlert = document.getElementById('custom-alert');
            const alertMessage = document.getElementById('alert-message');
            const alertOkBtn = document.getElementById('alert-ok-btn');

            alertMessage.textContent = message;
            customAlert.classList.remove('hidden');

            alertOkBtn.onclick = () => {
                customAlert.classList.add('hidden');
            };
        }

        // Function to display custom confirm dialog instead of window.confirm()
        function showConfirm(message) {
            return new Promise((resolve) => {
                const customConfirm = document.getElementById('custom-confirm-modal');
                const confirmMessage = document.getElementById('confirm-message');
                const confirmOkBtn = document.getElementById('confirm-ok-btn');
                const confirmCancelBtn = document.getElementById('confirm-cancel-btn');

                confirmMessage.textContent = message;
                customConfirm.classList.remove('hidden');

                const cleanup = () => {
                    customConfirm.classList.add('hidden');
                    confirmOkBtn.onclick = null;
                    confirmCancelBtn.onclick = null;
                };

                confirmOkBtn.onclick = () => {
                    cleanup();
                    resolve(true);
                };
                confirmCancelBtn.onclick = () => {
                    cleanup();
                    resolve(false);
                };
            });
        }

        // Your Supabase configuration
        const SUPABASE_URL = 'https://rmbsxccrwrktbjlnezpu.supabase.co'; // Your Supabase project URL
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJtYnN4Y2Nyd3JrdGJqbG5lenB1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg2MjczNjQsImV4cCI6MjA2NDIwMzM2NH0.ydCqificftdtn1niRciFCifeuo8aX6SDGti-hCY5Z_Y'; // Your public anon key for Supabase
        const STRAVA_OAUTH_CALLBACK_URL = 'https://rmbsxccrwrktbjlnezpu.supabase.co/functions/v1/strava-oauth-callback';
        const FETCH_ACTIVITIES_API_URL = 'https://rmbsxccrwrktbjlnezpu.supabase.co/functions/v1/fetch-strava-activities';
        const GET_STATS_API_URL = 'https://rmbsxccrwrktbjlnezpu.supabase.co/functions/v1/get-user-activities';
        // New Edge Function URL for AI analysis
        const ANALYZE_ACTIVITIES_FUNCTION_URL = 'https://rmbsxccrwrktbjlnezpu.supabase.co/functions/v1/analyze-activities-with-gemini'; 


        // Global variables to store user status and activity data
        let currentRunnerCredentialId = null; // This will store the Supabase runner_credentials.id (UUID)
        let isAuthenticated = false; // Tracks if Strava is authenticated
        let userActivities = []; // New variable to store all loaded activities
        let weeklyStatsData = []; // Store weekly stats data globally
        let currentAthleteId = null; // Stores Strava athlete ID for API calls and for activities.user_id
        let currentRunnerName = null; // Stores the name of the currently logged-in runner
        let currentAppUserId = null; // Stores Supabase Auth user ID (UUID)
        const ALL_ACTIVITY_TYPES = [
            'Run', 'Walk', 'Ride', 'Swim', 'Hike', 'NordicSki', 'AlpineSki', 'Workout', 'Yoga', 
            'WeightTraining', 'Elliptical', 'StairStepper', 'Rowing', 'Crossfit', 'Canoeing', 
            'Kayaking', 'StandUpPaddling', 'VirtualRide', 'VirtualRun', 'Wheelchair', 'Handcycle', 
            'RollerSki', 'IceSkate', 'Snowboard', 'Snowshoe', 'BackcountrySki', 'EMountainBikeRide', 
            'EBikeRide', 'MountainBikeRide', 'GravelRide', 'Velomobile', 'Kitesurf', 'Windsurf', 
            'RockClimbing', 'Alpinism', 'Badminton', 'Squash', 'TableTennis', 'Tennis', 'Volleyball', 
            'Surfing', 'Pilates', 'Golf', 'WaterSport', 'Soccer', 'Basketball'
        ].sort(); // Sort activity types alphabetically

        let allRunnerCredentials = []; // Store all fetched runner credentials

        // Initialize Supabase client instance
        let supabaseClientInstance;

        // DOM elements
        const appUserStatus = document.getElementById('app-user-status');
        const appAuthSection = document.getElementById('app-auth-section');
        const loggedOutView = document.getElementById('logged-out-view');
        const loggedInView = document.getElementById('logged-in-view');
        const currentAppUserEmail = document.getElementById('current-app-user-email');
        const authForm = document.getElementById('auth-form');
        const authEmailInput = document.getElementById('auth-email');
        const authPasswordInput = document.getElementById('auth-password'); 
        const signupBtn = document.getElementById('signup-btn');
        const signinBtn = document.getElementById('signin-btn');
        const guestLoginBtn = document.getElementById('guest-login-btn');
        const signoutBtn = document.getElementById('signout-btn');
        const authMessage = document.getElementById('auth-message');

        const credentialManagementSection = document.getElementById('credential-management-section');
        const stravaAuthSection = document.getElementById('strava-auth-section');

        const addCredentialBtn = document.getElementById('add-credential-btn');
        const credentialsList = document.getElementById('credentials-list');
        const noCredentialsMessage = document.getElementById('no-credentials-message');
        const loadingCredentials = document.getElementById('loading-credentials');
        const errorCredentials = document.getElementById('error-credentials');
        const credentialModal = document.getElementById('credential-modal');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const cancelModalBtn = document.getElementById('cancel-modal-btn');
        const modalTitle = document.getElementById('modal-title');
        const credentialForm = document.getElementById('credential-form');
        const runnerNameInput = document.getElementById('runner-name');
        const clientIdInput = document.getElementById('client-id');
        const clientSecretInput = document.getElementById('client-secret');
        const refreshTokenInput = document.getElementById('refresh-token');
        const redirectUriInput = document.getElementById('redirect-uri');
        const credentialIdInput = document.getElementById('credential-id');
        const runnerSelect = document.getElementById('runner-select');
        const connectStravaBtn = document.getElementById('connect-strava-btn');
        const disconnectStravaBtn = document.getElementById('disconnect-strava-btn');
        const authStatus = document.getElementById('auth-status');
        const currentRunnerDisplay = document.getElementById('current-runner-display');
        const currentRunnerNameSpan = document.getElementById('current-runner-name');
        const fetchActivitiesBtn = document.getElementById('fetch-activities-btn');
        const viewStatsBtn = document.getElementById('view-stats-btn');
        const analyzeActivitiesBtn = document.getElementById('analyze-activities-btn');
        const dataSection = document.getElementById('data-section');
        const userInfo = document.getElementById('user-info');
        const activitiesLimitInput = document.getElementById('activities-limit');
        const numRecentActivitiesInput = document.getElementById('num-recent-activities');
        const loadRecentActivitiesBtn = document.getElementById('load-recent-activities-btn');
        const recentActivitiesList = document.getElementById('recent-activities');
        const recentActivitiesStatus = document.getElementById('recent-activities-status');
        const statsSection = document.getElementById('stats-section');

        // New DOM elements for weekly activities modal
        const weeklyActivitiesModal = document.getElementById('weekly-activities-modal');
        const closeWeeklyActivitiesModalBtn = document.getElementById('close-weekly-activities-modal-btn');
        const weeklyActivitiesTitle = document.getElementById('weekly-activities-title');
        const weeklyActivitiesList = document.getElementById('weekly-activities-list');
        const weeklyActivitiesStatus = document.getElementById('weekly-activities-status');

        // Filter elements
        const multiSelectDisplayRecent = document.getElementById('multi-select-display-recent');
        const multiSelectOptionsRecent = document.getElementById('multi-select-options-recent');
        const multiSelectDisplayStats = document.getElementById('multi-select-display-stats');
        const multiSelectOptionsStats = document.getElementById('multi-select-options-stats');

        let selectedActivityTypesRecent = [];
        let selectedActivityTypesStats = [];

        // Date filter elements
        const startDateRecent = document.getElementById('start-date-recent');
        const endDateRecent = document.getElementById('end-date-recent');
        const startDateStats = document.getElementById('start-date-stats');
        const endDateStats = document.getElementById('end-date-stats');

        // New elements for detailed stats table
        const penaltyPerKmInput = document.getElementById('penalty-per-km');
        const targetKmPerWeekInput = document.getElementById('target-km-per-week');
        const detailedStatsTableBody = document.querySelector('#detailed-stats-table tbody');
        const detailedStatsStatus = document.getElementById('detailed-stats-status');

        // Collapsible elements
        const appAuthContent = document.getElementById('app-auth-content');
        const credentialManagementContent = document.getElementById('credential-management-content');
        const stravaAuthContent = document.getElementById('strava-auth-content');
        const instructionSection = document.getElementById('instruction-section');
        const instructionContent = document.getElementById('instruction-content');


        // --- Helper functions for UI and data transformation ---

        /**
         * Toggles the collapsible state of a section.
         * @param {HTMLElement} contentElement - The content div to collapse/expand.
         * @param {HTMLElement} toggleIcon - The icon to rotate.
         * @param {boolean} [collapse=true] - Force collapse or expand. If undefined, toggles.
         */
        function toggleCollapsible(contentElement, toggleIcon, collapse) {
            const isCollapsed = contentElement.classList.contains('collapsed');
            if (collapse === true && !isCollapsed) {
                contentElement.classList.add('collapsed');
                toggleIcon.classList.remove('rotate');
            } else if (collapse === false && isCollapsed) {
                contentElement.classList.remove('collapsed');
                toggleIcon.classList.add('rotate');
            } else if (collapse === undefined) { // Toggle
                contentElement.classList.toggle('collapsed');
                toggleIcon.classList.toggle('rotate');
            }
        }

        /**
         * Populates the multi-select filter dropdowns.
         */
        function populateActivityTypeFilters() {
            [multiSelectOptionsRecent, multiSelectOptionsStats].forEach(optionsContainer => {
                optionsContainer.innerHTML = ''; // Clear existing options
                ALL_ACTIVITY_TYPES.forEach(type => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'multi-select-option';
                    optionDiv.textContent = type;
                    optionDiv.dataset.value = type;
                    optionsContainer.appendChild(optionDiv);
                });
            });
        }

        /**
         * Updates the display of selected items in the multi-select.
         * @param {HTMLElement} displayElement - The element to show selected tags.
         * @param {string[]} selectedTypes - Array of selected activity types.
         * @param {HTMLElement} optionsContainer - The container for options to update their 'selected' class.
         */
        function updateMultiSelectDisplay(displayElement, selectedTypes, optionsContainer) {
            displayElement.innerHTML = '';
            if (selectedTypes.length === 0) {
                displayElement.innerHTML = '<span class="text-gray-500">Ch·ªçn lo·∫°i ho·∫°t ƒë·ªông</span>';
            } else {
                selectedTypes.forEach(type => {
                    const itemSpan = document.createElement('span');
                    itemSpan.className = 'multi-select-selected-item';
                    itemSpan.innerHTML = `${type} <span data-value="${type}" class="remove-item-btn">&times;</span>`;
                    displayElement.appendChild(itemSpan);
                });
            }

            // Update selected class on options
            Array.from(optionsContainer.children).forEach(optionDiv => {
                if (selectedTypes.includes(optionDiv.dataset.value)) {
                    optionDiv.classList.add('selected');
                } else {
                    optionDiv.classList.remove('selected');
                }
            });
        }

        /**
         * Toggles an activity type in the selected list.
         * @param {string} type - The activity type to toggle.
         * @param {string[]} selectedTypesArray - The array to modify (e.g., selectedActivityTypesRecent).
         * @param {HTMLElement} displayElement - The display element for this filter.
         * @param {HTMLElement} optionsContainer - The options container for this filter.
         */
        function toggleActivityType(type, selectedTypesArray, displayElement, optionsContainer) {
            const index = selectedTypesArray.indexOf(type);
            if (index > -1) {
                selectedTypesArray.splice(index, 1); // Remove if already exists
            } else {
                selectedTypesArray.push(type); // Add if not exists
                selectedTypesArray.sort(); // Keep sorted alphabetically
            }
            updateMultiSelectDisplay(displayElement, selectedTypesArray, optionsContainer);
        }

        // Event delegation for multi-select options
        document.addEventListener('click', (event) => {
            // Toggle options visibility
            if (event.target.closest('#multi-select-display-recent')) {
                multiSelectOptionsRecent.classList.toggle('hidden');
                multiSelectOptionsStats.classList.add('hidden'); // Close other
            } else if (event.target.closest('#multi-select-display-stats')) {
                multiSelectOptionsStats.classList.toggle('hidden');
                multiSelectOptionsRecent.classList.add('hidden'); // Close other
            } else {
                // Click outside to close options
                if (!event.target.closest('.multi-select-options')) {
                    multiSelectOptionsRecent.classList.add('hidden');
                    multiSelectOptionsStats.classList.add('hidden');
                }
            }

            // Handle option selection/deselection
            if (event.target.classList.contains('multi-select-option')) {
                const type = event.target.dataset.value;
                if (event.target.closest('#multi-select-options-recent')) {
                    toggleActivityType(type, selectedActivityTypesRecent, multiSelectDisplayRecent, multiSelectOptionsRecent);
                } else if (event.target.closest('#multi-select-options-stats')) {
                    toggleActivityType(type, selectedActivityTypesStats, multiSelectDisplayStats, multiSelectOptionsStats);
                }
            } else if (event.target.classList.contains('remove-item-btn')) {
                const type = event.target.dataset.value;
                if (event.target.closest('#multi-select-display-recent')) {
                    toggleActivityType(type, selectedActivityTypesRecent, multiSelectDisplayRecent, multiSelectOptionsRecent);
                } else if (event.target.closest('#multi-select-display-stats')) {
                    toggleActivityType(type, selectedActivityTypesStats, multiSelectDisplayStats, multiSelectOptionsStats);
                }
            }
        });


        /**
         * Formats duration from seconds to HH:MM:SS.
         * @param {number} seconds - Duration in seconds.
         * @returns {string} Formatted duration string.
         */
        function formatDuration(seconds) {
            if (typeof seconds !== 'number' || isNaN(seconds) || seconds < 0) return 'N/A';
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return [h, m, s].map(v => v < 10 ? "0" + v : v).filter((v, i) => v !== "00" || i > 0).join(":");
        }

        /**
         * Converts average speed (m/s) to pace (min/km).
         * @param {number} metersPerSecond - Average speed in meters per second.
         * @returns {string} Formatted pace string (MM:SS /km) or 'N/A'.
         */
        function formatPace(metersPerSecond) {
            if (typeof metersPerSecond !== 'number' || isNaN(metersPerSecond) || metersPerSecond <= 0) return 'N/A';
            const kmPerHour = (metersPerSecond * 3.6); // km/h
            const minutesPerKm = 60 / kmPerHour; // min/km
            const minutes = Math.floor(minutesPerKm);
            const seconds = Math.round((minutesPerKm - minutes) * 60);
            return `${minutes}:${String(seconds).padStart(2, '0')} /km`;
        }

        /**
         * Formats elevation gain in meters.
         * @param {number} meters - Elevation in meters.
         * @returns {string} Formatted string (e.g., "150 m").
         */
        function formatElevationGain(meters) {
            if (typeof meters !== 'number' || isNaN(meters)) return 'N/A';
            return `${meters.toFixed(0)} m`;
        }


        // --- Supabase App Authentication Functions ---

        /**
         * Updates the UI based on the current Supabase Authentication state.
         * @param {Object|null} user - The Supabase user object or null if logged out.
         */
        async function updateAppAuthUI(user) {
            const appAuthHeader = appAuthSection.querySelector('.collapsible-header');
            const appAuthToggleIcon = appAuthHeader.querySelector('.toggle-icon');

            if (user) {
                currentAppUserId = user.id;
                appUserStatus.textContent = `ƒê√£ ƒëƒÉng nh·∫≠p: ${user.email || 'Kh√°ch'}`;
                currentAppUserEmail.textContent = user.email || 'Kh√°ch';
                loggedOutView.classList.add('hidden');
                loggedInView.classList.remove('hidden');
                
                // Show sections dependent on app authentication
                credentialManagementSection.classList.remove('hidden');
                stravaAuthSection.classList.remove('hidden');
                dataSection.classList.remove('hidden');
                statsSection.classList.remove('hidden');
                instructionSection.classList.remove('hidden'); // Show instruction section

                // Collapse app auth section if logged in
                toggleCollapsible(appAuthContent, appAuthToggleIcon, true); 

                // Re-fetch credentials and check Strava auth state after app user is authenticated
                await displayCredentials();
                await checkStravaAuthState();

            } else {
                currentAppUserId = null;
                appUserStatus.textContent = 'Ch∆∞a ƒëƒÉng nh·∫≠p';
                loggedOutView.classList.remove('hidden');
                loggedInView.classList.add('hidden');

                // Expand app auth section if logged out
                toggleCollapsible(appAuthContent, appAuthToggleIcon, false);

                // Hide sections dependent on app authentication
                credentialManagementSection.classList.add('hidden');
                stravaAuthSection.classList.add('hidden');
                dataSection.classList.add('hidden');
                statsSection.classList.add('hidden');
                instructionSection.classList.add('hidden'); // Hide instruction section

                clearStravaSession(); // Clear Strava session if app user logs out
                await displayCredentials(); // Clear credentials list
                checkStravaAuthState(); // Reset Strava UI
            }
        }

        /**
         * Handles user sign-up or sign-in.
         * @param {Event} event - Form submission event.
         */
        async function handleAuth(event) {
            event.preventDefault();
            authMessage.textContent = '';
            const email = authEmailInput.value.trim();
            const password = authPasswordInput.value.trim();

            if (!email || !password) {
                showAlert('Vui l√≤ng nh·∫≠p Email v√† M·∫≠t kh·∫©u.');
                return;
            }

            try {
                if (event.submitter.id === 'signup-btn') {
                    const { data, error } = await supabaseClientInstance.auth.signUp({ email, password });
                    if (error) throw error;
                    showAlert('ƒêƒÉng k√Ω th√†nh c√¥ng! Vui l√≤ng ki·ªÉm tra email c·ªßa b·∫°n ƒë·ªÉ x√°c nh·∫≠n.');
                    authMessage.textContent = 'ƒêƒÉng k√Ω th√†nh c√¥ng! Vui l√≤ng ki·ªÉm tra email c·ªßa b·∫°n ƒë·ªÉ x√°c nh·∫≠n.';
                } else if (event.submitter.id === 'signin-btn') {
                    const { data, error } = await supabaseClientInstance.auth.signInWithPassword({ email, password });
                    if (error) throw error;
                    showAlert('ƒêƒÉng nh·∫≠p th√†nh c√¥ng!');
                    authMessage.textContent = ''; // Clear message on success
                }
            } catch (error) {
                console.error('L·ªói x√°c th·ª±c ·ª©ng d·ª•ng:', error.message);
                authMessage.textContent = `L·ªói: ${error.message}`;
                showAlert(`L·ªói x√°c th·ª±c: ${error.message}`);
            }
        }

        /**
         * Handles guest login (anonymous sign-in with Supabase).
         */
        async function handleGuestLogin() {
            try {
                const { data, error } = await supabaseClientInstance.auth.signInAnonymously();
                if (error) throw error;
                showAlert('ƒêƒÉng nh·∫≠p v·ªõi t∆∞ c√°ch Kh√°ch th√†nh c√¥ng!');
                authMessage.textContent = ''; // Clear message on success
            } catch (error) {
                console.error('L·ªói ƒëƒÉng nh·∫≠p kh√°ch:', error.message);
                authMessage.textContent = `L·ªói ƒëƒÉng nh·∫≠p kh√°ch: ${error.message}`;
                showAlert(`L·ªói ƒëƒÉng nh·∫≠p kh√°ch: ${error.message}`);
            }
        }

        /**
         * Handles user sign-out from the application.
         */
        async function handleSignOut() {
            try {
                const { error } = await supabaseClientInstance.auth.signOut();
                if (error) throw error;
                showAlert('ƒêƒÉng xu·∫•t ·ª©ng d·ª•ng th√†nh c√¥ng!');
                authMessage.textContent = ''; // Clear message on success
                clearStravaSession(); // Clear Strava session on app logout
                updateAppAuthUI(null); // Update UI to logged-out state
            } catch (error) {
                console.error('L·ªói ƒëƒÉng xu·∫•t ·ª©ng d·ª•ng:', error.message);
                showAlert(`L·ªói ƒëƒÉng xu·∫•t: ${error.message}`);
            }
        }


        // --- Credential Management Functions ---

        /**
         * Fetches and displays runner credentials from Supabase for the current Supabase authenticated user.
         * Populates the credentials list and the runner selection dropdown.
         */
        async function displayCredentials() {
            if (!currentAppUserId) {
                console.log('App user not authenticated, cannot display credentials. Clearing list.');
                credentialsList.innerHTML = '';
                noCredentialsMessage.classList.remove('hidden');
                runnerSelect.innerHTML = '<option value="">-- Ch·ªçn Runner --</option>';
                loadingCredentials.classList.add('hidden');
                // Ensure the credential section is expanded if no credentials
                toggleCollapsible(credentialManagementContent, credentialManagementSection.querySelector('.toggle-icon'), false);
                return;
            }

            console.log('displayCredentials: Attempting to fetch credentials for user:', currentAppUserId); 
            loadingCredentials.classList.remove('hidden');
            errorCredentials.classList.add('hidden');
            credentialsList.innerHTML = ''; // Ensure list is cleared before populating
            noCredentialsMessage.classList.add('hidden');
            runnerSelect.innerHTML = '<option value="">-- Ch·ªçn Runner --</option>'; // Clear existing options

            try {
                const { data, error } = await supabaseClientInstance
                    .from('runner_credentials')
                    .select('*')
                    .eq('owner_uid', currentAppUserId)
                    .order('runner_name', { ascending: true });

                if (error) throw error;

                console.log('displayCredentials: Fetched data from Supabase:', data); 
                allRunnerCredentials = data; // Store fetched credentials globally to avoid re-fetching

                if (data.length === 0) {
                    noCredentialsMessage.classList.remove('hidden');
                    // Expand credential section if no credentials
                    toggleCollapsible(credentialManagementContent, credentialManagementSection.querySelector('.toggle-icon'), false);
                } else {
                    noCredentialsMessage.classList.add('hidden');
                    // Collapse credential section if credentials exist
                    toggleCollapsible(credentialManagementContent, credentialManagementSection.querySelector('.toggle-icon'), true);

                    data.forEach(cred => {
                        // Display credential details (only once per credential)
                        const credDiv = document.createElement('div');
                        credDiv.className = 'bg-gray-50 p-4 rounded-lg border border-gray-200 flex flex-col sm:flex-row justify-between items-start sm:items-center gap-3';
                        credDiv.innerHTML = `
                            <div>
                                <p class="text-lg font-semibold text-gray-800">${cred.runner_name}</p>
                                <p class="text-sm text-gray-600">Client ID: <span class="font-mono">${cred.client_id.substring(0, 4)}...${cred.client_id.substring(cred.client_id.length - 4)}</span></p>
                                <p class="text-sm text-gray-600">Refresh Token: <span class="font-mono">${cred.refresh_token.substring(0, 4)}...${cred.refresh_token.substring(cred.refresh_token.length - 4)}</span></p>
                                ${cred.athlete_id ? `<p class="text-sm text-gray-600">Athlete ID: <span class="font-mono">${cred.athlete_id}</span></p>` : ''}
                            </div>
                            <div class="flex flex-row gap-2 mt-2 sm:mt-0">
                                <button class="btn-secondary btn-edit" data-id="${cred.id}">S·ª≠a</button>
                                <button class="btn-danger btn-delete" data-id="${cred.id}">X√≥a</button>
                            </div>
                        `;
                        credentialsList.appendChild(credDiv);

                        // Populate runner select dropdown
                        const option = document.createElement('option');
                        option.value = cred.id; // Use the Supabase credential ID as the value
                        option.textContent = cred.runner_name;
                        option.dataset.clientId = cred.client_id; // Store client ID for OAuth flow
                        option.dataset.clientSecret = cred.client_secret; // Store client secret for OAuth flow
                        option.dataset.refreshToken = cred.refresh_token; // Store refresh token for OAuth flow
                        option.dataset.redirectUri = cred.redirect_uri; // Store redirect URI
                        option.dataset.athleteId = cred.athlete_id || ''; // Store athlete ID
                        runnerSelect.appendChild(option);
                    });
                    
                    document.querySelectorAll('.btn-edit').forEach(button => {
                        button.onclick = (e) => openCredentialModal(e.target.dataset.id);
                    });
                    document.querySelectorAll('.btn-delete').forEach(button => {
                        button.onclick = async (e) => {
                            const confirmed = await showConfirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a th√¥ng tin ƒëƒÉng nh·∫≠p n√†y kh√¥ng?'); // Using custom confirm
                            if (confirmed) {
                                await deleteCredential(e.target.dataset.id);
                            }
                        };
                    });
                }
            }
            catch (error) {
                console.error('L·ªói khi l·∫•y th√¥ng tin ƒëƒÉng nh·∫≠p runner:', error.message);
                errorCredentials.textContent = `L·ªói: ${error.message}`;
                errorCredentials.classList.remove('hidden');
                showAlert(`L·ªói khi t·∫£i th√¥ng tin runner: ${error.message}`);
            }
            finally {
                loadingCredentials.classList.add('hidden');
                console.log('displayCredentials: Finished rendering.'); 
            }
        }

        /**
         * Opens the modal for adding or editing runner credentials.
         * @param {string|null} id - ID of the credential to edit, or null for new.
         */
        async function openCredentialModal(id = null) {
            credentialForm.reset();
            credentialIdInput.value = '';
            modalTitle.textContent = 'Th√™m th√¥ng tin ƒëƒÉng nh·∫≠p Runner';
            // Set default redirect URI to the fixed value
            redirectUriInput.value = 'https://quantrh.github.io/Strava/index1.html'; 

            if (id) {
                modalTitle.textContent = 'S·ª≠a th√¥ng tin ƒëƒÉng nh·∫≠p Runner';
                try {
                    // Fetch only credentials owned by the current app user for editing
                    const { data, error } = await supabaseClientInstance
                        .from('runner_credentials')
                        .select('*')
                        .eq('id', id)
                        .eq('owner_uid', currentAppUserId) // Verify ownership
                        .single();

                    if (error) throw error;

                    runnerNameInput.value = data.runner_name;
                    clientIdInput.value = data.client_id;
                    clientSecretInput.value = data.client_secret; 
                    refreshTokenInput.value = data.refresh_token; 
                    // No need to update redirectUriInput.value here as it's fixed and readonly
                    credentialIdInput.value = data.id;
                } catch (error) {
                    console.error('L·ªói khi l·∫•y th√¥ng tin ƒëƒÉng nh·∫≠p ƒë·ªÉ ch·ªânh s·ª≠a:', error.message);
                    showAlert(`L·ªói khi t·∫£i chi ti·∫øt runner: ${error.message}. B·∫°n ch·ªâ c√≥ th·ªÉ s·ª≠a runner c·ªßa m√¨nh.`);
                }
            }
            credentialModal.style.display = 'flex';
        }

        /**
         * Saves (adds or updates) runner credentials to Supabase.
         * @param {Event} event - Form submission event.
         */
        async function saveCredential(event) {
            event.preventDefault();

            if (!currentAppUserId) {
                showAlert('L·ªói: B·∫°n ph·∫£i ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng ƒë·ªÉ th√™m ho·∫∑c s·ª≠a Runner.');
                console.error('Attempted to save credential but app user is not authenticated.');
                return;
            }

            const id = credentialIdInput.value;
            const runnerName = runnerNameInput.value.trim();
            const clientId = clientIdInput.value.trim();
            const clientSecret = clientSecretInput.value.trim();
            const refreshToken = refreshTokenInput.value.trim();
            // Redirect URI is now fixed and read-only, so get it directly from the input's value
            const redirectUri = redirectUriInput.value; 

            if (!runnerName || !clientId || !clientSecret || !refreshToken || !redirectUri) {
                showAlert('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß t·∫•t c·∫£ c√°c tr∆∞·ªùng b·∫Øt bu·ªôc.');
                return;
            }

            const newCredential = {
                runner_name: runnerName,
                client_id: clientId,
                client_secret: clientSecret,
                refresh_token: refreshToken,
                redirect_uri: redirectUri, // Use the fixed value
                owner_uid: currentAppUserId // G√°n owner_uid l√† ID c·ªßa ng∆∞·ªùi d√πng ·ª©ng d·ª•ng hi·ªán t·∫°i
                // athlete_id will be set during OAuth callback
            };

            try {
                let error = null;
                if (id) {
                    const { error: updateError } = await supabaseClientInstance
                        .from('runner_credentials')
                        .update(newCredential)
                        .eq('id', id)
                        .eq('owner_uid', currentAppUserId); // ƒê·∫£m b·∫£o ch·ªâ c·∫≠p nh·∫≠t c·ªßa ch√≠nh m√¨nh
                    error = updateError;
                    showAlert('C·∫≠p nh·∫≠t th√¥ng tin runner th√†nh c√¥ng!');
                } else {
                    const { error: insertError } = await supabaseClientInstance
                        .from('runner_credentials')
                        .insert([newCredential]);
                    error = insertError;
                    showAlert('Th√™m runner m·ªõi th√†nh c√¥ng!');
                }

                if (error) throw error;

                credentialModal.style.display = 'none';
                await displayCredentials(); // Refresh the list and dropdown
            } catch (error) {
                console.error('L·ªói khi l∆∞u th√¥ng tin ƒëƒÉng nh·∫≠p runner:', error.message);
                showAlert(`L·ªói khi l∆∞u th√¥ng tin runner: ${error.message}`);
            }
        }

        /**
         * Deletes a runner credential from Supabase.
         * @param {string} id - ID of the credential to delete.
         */
        async function deleteCredential(id) {
            if (!currentAppUserId) {
                showAlert('L·ªói: B·∫°n ph·∫£i ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng ƒë·ªÉ x√≥a Runner.');
                return;
            }
            try {
                const { error } = await supabaseClientInstance
                    .from('runner_credentials')
                    .delete()
                    .eq('id', id)
                    .eq('owner_uid', currentAppUserId); // ƒê·∫£m b·∫£o ch·ªâ x√≥a c·ªßa ch√≠nh m√¨nh

                if (error) throw error;

                showAlert('X√≥a th√¥ng tin runner th√†nh c√¥ng!');
                // If the deleted runner was the current logged-in one, log out
                if (currentRunnerCredentialId === id) {
                    clearStravaSession();
                    checkStravaAuthState(); // Reset Strava auth UI
                }
                await displayCredentials(); // Refresh the list and dropdown
            } catch (error) {
                console.error('L·ªói khi x√≥a th√¥ng tin ƒëƒÉng nh·∫≠p runner:', error.message);
                showAlert(`L·ªói khi x√≥a th√¥ng tin runner: ${error.message}`);
            }
        }


        // --- Strava Authentication & API Interaction ---

        /**
         * Checks the current Strava authentication status and updates the UI.
         */
        async function checkStravaAuthState() {
            currentRunnerCredentialId = localStorage.getItem('strava_runner_credential_id'); 
            isAuthenticated = localStorage.getItem('strava_authenticated') === 'true';
            currentAthleteId = localStorage.getItem('strava_athlete_id'); // Strava athlete ID for API calls and for activities.user_id
            currentRunnerName = localStorage.getItem('strava_runner_name'); // Runner name (string)

            console.log('checkStravaAuthState - Ki·ªÉm tra tr·∫°ng th√°i x√°c th·ª±c Strava ...');
            console.log('  isAuthenticated (Strava):', isAuthenticated);
            console.log('  currentRunnerCredentialId (Credential ID):', currentRunnerCredentialId);
            console.log('  currentAthleteId (Strava ID):', currentAthleteId);
            console.log('  currentRunnerName:', currentRunnerName);

            const stravaAuthHeader = stravaAuthSection.querySelector('.collapsible-header');
            const stravaAuthToggleIcon = stravaAuthHeader.querySelector('.toggle-icon');


            if (isAuthenticated && currentRunnerCredentialId && currentAthleteId && currentRunnerName) {
                const expiresAt = localStorage.getItem('strava_expires_at');
                const refreshToken = localStorage.getItem('strava_refresh_token');

                const now = Date.now();
                if (expiresAt && now < parseInt(expiresAt, 10)) {
                    console.log('  Token Strava h·ª£p l·ªá. ƒê√£ ƒëƒÉng nh·∫≠p Strava.');
                    authStatus.textContent = 'ƒê√£ ƒëƒÉng nh·∫≠p v·ªõi Strava.';
                    currentRunnerNameSpan.textContent = currentRunnerName;
                    currentRunnerDisplay.classList.remove('hidden');
                    connectStravaBtn.classList.add('hidden');
                    disconnectStravaBtn.classList.remove('hidden');
                    dataSection.classList.remove('hidden');
                    statsSection.classList.remove('hidden');
                    userInfo.textContent = `Ch√†o m·ª´ng, Runner: ${currentRunnerName} (Strava ID: ${currentAthleteId})`; 
                    
                    // Select the logged-in runner in the dropdown
                    runnerSelect.value = currentRunnerCredentialId;

                    // Collapse strava auth section if connected
                    toggleCollapsible(stravaAuthContent, stravaAuthToggleIcon, true);

                } else {
                    console.log('  Token Strava ƒë√£ h·∫øt h·∫°n ho·∫∑c kh√¥ng c√≥. ƒêang th·ª≠ l√†m m·ªõi ...');
                    authStatus.textContent = 'Token Strava ƒë√£ h·∫øt h·∫°n, ƒëang l√†m m·ªõi ...';
                    try {
                        const success = await refreshTokenCall(refreshToken, currentRunnerCredentialId); // Pass credential ID
                        if (success) {
                            showAlert('Token Strava ƒë√£ ƒë∆∞·ª£c l√†m m·ªõi th√†nh c√¥ng!');
                            checkStravaAuthState(); // Re-check state after refresh
                        } else {
                            throw new Error('L√†m m·ªõi token Strava th·∫•t b·∫°i. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.');
                        }
                    } catch (err) {
                        console.error('L·ªói l√†m m·ªõi token Strava:', err);
                        showAlert(`L·ªói l√†m m·ªõi token Strava: ${err.message}. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.`);
                        clearStravaSession();
                        checkStravaAuthState();
                    }
                }
            } else {
                console.log('  Ch∆∞a ƒëƒÉng nh·∫≠p Strava ho·∫∑c thi·∫øu th√¥ng tin phi√™n.');
                clearStravaSession(); // Ensure all related items are cleared
                authStatus.textContent = 'Vui l√≤ng ch·ªçn Runner v√† ƒëƒÉng nh·∫≠p v·ªõi Strava.';
                currentRunnerDisplay.classList.add('hidden');
                connectStravaBtn.classList.remove('hidden');
                disconnectStravaBtn.classList.add('hidden');
                dataSection.classList.add('hidden');
                statsSection.classList.add('hidden');
                userInfo.textContent = ''; // Clear user info
                // Reset content if not authenticated
                recentActivitiesList.innerHTML = '<li class="text-gray-500">Nh·∫•n "T·∫£i ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y" ƒë·ªÉ xem.</li>';
                document.getElementById('bubble-chart-container').innerHTML = '<p class="text-gray-500 text-center">Nh·∫•n "Xem th·ªëng k√™ theo tu·∫ßn" ƒë·ªÉ hi·ªÉn th·ªã bi·ªÉu ƒë·ªì.</p>';
                detailedStatsTableBody.innerHTML = '';
                detailedStatsStatus.textContent = 'Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã.';

                // Expand strava auth section if not connected
                toggleCollapsible(stravaAuthContent, stravaAuthToggleIcon, false);
            }
        }

        /**
         * Clears all Strava session data from local storage.
         * This logs the user out of Strava within the app.
         */
        function clearStravaSession() {
            console.log('clearStravaSession - ƒêang x√≥a d·ªØ li·ªáu phi√™n Strava kh·ªèi localStorage.');
            localStorage.removeItem('strava_access_token');
            localStorage.removeItem('strava_refresh_token');
            localStorage.removeItem('strava_expires_at');
            localStorage.removeItem('strava_athlete_id');
            localStorage.removeItem('strava_runner_name');
            localStorage.removeItem('strava_runner_credential_id'); // Clear the credential ID used for login
            localStorage.removeItem('strava_client_id_pending'); // Clear pending state
            localStorage.removeItem('strava_redirect_uri_pending'); // Clear pending state
            localStorage.removeItem('strava_runner_name_pending'); // Clear pending state
        }

        /**
         * Refreshes the Strava access token using the refresh token.
         * @param {string} refreshToken - The current refresh token.
         * @param {string} credentialId - The Supabase UUID of the runner credential.
         * @returns {Promise<boolean>} True if refresh successful, false otherwise.
         */
        async function refreshTokenCall(refreshToken, credentialId) {
            console.log('refreshTokenCall - ƒêang g·ªçi API l√†m m·ªõi token ...');
            try {
                // Fetch client_id and client_secret for the given credentialId from Supabase
                const { data: credData, error: credError } = await supabaseClientInstance
                    .from('runner_credentials')
                    .select('client_id, client_secret')
                    .eq('id', credentialId)
                    .eq('owner_uid', currentAppUserId) // ƒê·∫£m b·∫£o ch·ªâ l√†m m·ªõi c·ªßa ch√≠nh m√¨nh
                    .single();

                if (credError || !credData) {
                    throw new Error(`Kh√¥ng t√¨m th·∫•y th√¥ng tin ƒëƒÉng nh·∫≠p ph√π h·ª£p cho ID ${credentialId} ƒë·ªÉ l√†m m·ªõi token.`);
                }

                const response = await fetch('https://www.strava.com/oauth/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        client_id: credData.client_id,
                        client_secret: credData.client_secret,
                        refresh_token: refreshToken,
                        grant_type: 'refresh_token'
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`L√†m m·ªõi token th·∫•t b·∫°i: ${errorData.message || response.statusText}`);
                }

                const data = await response.json();
                localStorage.setItem('strava_access_token', data.access_token);
                localStorage.setItem('strava_refresh_token', data.refresh_token);
                localStorage.setItem('strava_expires_at', data.expires_at * 1000);
                // Also update the athlete_id in runner_credentials if it changed or wasn't set
                await supabaseClientInstance
                    .from('runner_credentials')
                    .update({ athlete_id: data.athlete.id })
                    .eq('id', credentialId);

                return true;
            } catch (error) {
                console.error('L·ªói khi l√†m m·ªõi token Strava:', error.message);
                return false;
            }
        }

        /**
         * Initiates the Strava OAuth authorization flow.
         */
        connectStravaBtn.addEventListener('click', () => {
            if (!currentAppUserId) {
                showAlert('L·ªói: B·∫°n ph·∫£i ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng ƒë·ªÉ k·∫øt n·ªëi v·ªõi Strava.');
                return;
            }

            const selectedOption = runnerSelect.options[runnerSelect.selectedIndex];
            if (!selectedOption || !selectedOption.value) {
                showAlert('Vui l√≤ng ch·ªçn m·ªôt Runner t·ª´ danh s√°ch tr∆∞·ªõc khi k·∫øt n·ªëi Strava.');
                return;
            }

            const credentialId = selectedOption.value; // Supabase credential ID (UUID)
            const clientId = selectedOption.dataset.clientId;
            const redirectUri = selectedOption.dataset.redirectUri;
            const runnerName = selectedOption.textContent;

            if (!clientId || !redirectUri) {
                showAlert('Thi·∫øu th√¥ng tin Client ID ho·∫∑c Redirect URI cho Runner ƒë√£ ch·ªçn. Vui l√≤ng ki·ªÉm tra l·∫°i th√¥ng tin ƒëƒÉng nh·∫≠p.');
                return;
            }
            
            // Store selected runner's basic info in local storage for callback processing
            // These will be retrieved by the handleStravaCallback function
            // when the user is redirected back.
            localStorage.setItem('strava_runner_credential_id_pending', credentialId);
            localStorage.setItem('strava_runner_name_pending', runnerName);
            // We do NOT store client_id_pending or redirect_uri_pending here anymore,
            // as the Edge Function will fetch them securely from the DB using runnerCredentialId.
            // These lines are kept for reference but are technically redundant for security reasons now.
            // localStorage.setItem('strava_client_id_pending', clientId);
            // localStorage.setItem('strava_redirect_uri_pending', redirectUri);

            const scope = 'activity:read_all';
            // Pass ONLY the runnerCredentialId in 'state' to the callback function via URL.
            // The Edge Function will fetch other details securely using this ID.
            const state = encodeURIComponent(JSON.stringify({ 
                credentialId: credentialId
            }));
            const authUrl = `https://www.strava.com/oauth/authorize?client_id=${clientId}&response_type=code&redirect_uri=${encodeURIComponent(redirectUri)}&approval_prompt=auto&scope=${scope}&state=${state}`;
            
            window.location.href = authUrl;
        });

        /**
         * Handles the Strava OAuth callback, exchanging code for tokens via Edge Function.
         */
        async function handleStravaCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const stateParam = urlParams.get('state'); // Contains runnerCredentialId
            const errorParam = urlParams.get('error');

            if (errorParam) {
                showAlert(`L·ªói t·ª´ Strava: ${errorParam}. Vui l√≤ng th·ª≠ l·∫°i.`);
                console.error('Strava OAuth Error:', errorParam);
                window.history.replaceState({}, document.title, window.location.pathname);
                return;
            }

            if (code) { // Only check for code, stateParam might be null/missing on redirect sometimes or for old sessions
                authStatus.textContent = 'ƒêang x·ª≠ l√Ω k·∫øt n·ªëi Strava ...';
                let runnerCredentialId = null;

                if (stateParam) {
                    try {
                        const parsedState = JSON.parse(decodeURIComponent(stateParam));
                        runnerCredentialId = parsedState.credentialId;
                        if (!runnerCredentialId) {
                            console.error('Thi·∫øu th√¥ng tin runnerCredentialId trong tham s·ªë "state".');
                            // Continue to check localStorage as fallback if stateParam exists but is malformed
                        }
                    } catch (e) {
                        console.error('L·ªói gi·∫£i m√£ tham s·ªë "state":', e);
                        // Continue to check localStorage as fallback
                    }
                }

                // Fallback to localStorage if runnerCredentialId is still null
                if (!runnerCredentialId) {
                    runnerCredentialId = localStorage.getItem('strava_runner_credential_id_pending');
                    if (!runnerCredentialId) {
                        console.error('Kh√¥ng t√¨m th·∫•y runnerCredentialId trong state ho·∫∑c localStorage.');
                        showAlert('L·ªói: Th√¥ng tin phi√™n kh√¥ng h·ª£p l·ªá ho·∫∑c thi·∫øu Runner ID. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i Strava.');
                        window.history.replaceState({}, document.title, window.location.pathname);
                        return;
                    }
                }

                try {
                    // G·ªåI EDGE FUNCTION ƒë·ªÉ trao ƒë·ªïi m√£ l·∫•y token
                    console.log(`[Client] Calling strava-oauth-callback Edge Function for runnerCredentialId: ${runnerCredentialId}`);
                    const response = await fetch(STRAVA_OAUTH_CALLBACK_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            code: code,
                            runnerCredentialId: runnerCredentialId
                        }),
                    });

                    const result = await response.json();

                    if (response.ok && result.success) {
                        // L∆∞u c√°c token v√† athlete info t·ª´ ph·∫£n h·ªìi c·ªßa Edge Function v√†o localStorage
                        localStorage.setItem('strava_access_token', result.access_token);
                        localStorage.setItem('strava_refresh_token', result.refresh_token);
                        localStorage.setItem('strava_expires_at', result.expires_at); // expires_at ƒë√£ l√† mili gi√¢y t·ª´ EF
                        localStorage.setItem('strava_athlete_id', result.athlete_id);
                        localStorage.setItem('strava_runner_name', result.runner_name); 
                        localStorage.setItem('strava_runner_credential_id', result.runnerCredentialId); 
                        localStorage.setItem('strava_authenticated', 'true'); 

                        showAlert('ƒêƒÉng nh·∫≠p Strava th√†nh c√¥ng! B·∫°n c√≥ th·ªÉ t·∫£i d·ªØ li·ªáu ho·∫°t ƒë·ªông ngay b√¢y gi·ªù.');
                        window.history.replaceState({}, document.title, window.location.pathname); // Clean URL
                        checkStravaAuthState(); // Update UI
                    } else {
                        console.error('[Client] Error from Edge Function:', result.error);
                        showAlert(`L·ªói ƒëƒÉng nh·∫≠p Strava: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`);
                        clearStravaSession();
                        checkStravaAuthState();
                        window.history.replaceState({}, document.title, window.location.pathname); // Clean URL
                    }
                } catch (err) {
                    console.error('L·ªói khi g·ªçi Edge Function strava-oauth-callback:', err);
                    showAlert(`L·ªói m·∫°ng ho·∫∑c m√°y ch·ªß khi x·ª≠ l√Ω ƒëƒÉng nh·∫≠p Strava: ${err.message}`);
                    clearStravaSession();
                    checkStravaAuthState();
                    window.history.replaceState({}, document.title, window.location.pathname); // Clean URL
                }
            } else {
                console.log('Kh√¥ng c√≥ m√£ ·ªßy quy·ªÅn ho·∫∑c tham s·ªë "state" trong URL. Kh√¥ng c√≥ h√†nh ƒë·ªông n√†o ƒë∆∞·ª£c th·ª±c hi·ªán.');
            }
        }

        /**
         * Disconnects Strava account from the current runner.
         */
        disconnectStravaBtn.addEventListener('click', () => {
            clearStravaSession();
            checkStravaAuthState();
            showAlert('ƒê√£ ƒëƒÉng xu·∫•t Strava.');
        });


        // --- Data Fetching & Management ---

        /**
         * Fetches activities from Strava API and saves them to Supabase.
         */
        fetchActivitiesBtn.addEventListener('click', async () => {
            if (!currentAppUserId || !isAuthenticated || !currentRunnerCredentialId || !currentAthleteId) {
                showAlert('Vui l√≤ng ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng v√† k·∫øt n·ªëi v·ªõi Strava tr∆∞·ªõc khi th·ª±c hi·ªán ch·ª©c nƒÉng n√†y.');
                return;
            }

            const dataStatus = document.getElementById('data-status');
            dataStatus.textContent = 'ƒêang t·∫£i d·ªØ li·ªáu ho·∫°t ƒë·ªông t·ª´ Strava ...';

            const activitiesLimit = parseInt(activitiesLimitInput.value, 10) || 60;
            
            console.log('Fetching activities:');
            console.log('  currentRunnerCredentialId (Supabase Credential ID to send):', currentRunnerCredentialId);
            console.log('  currentAthleteId (Strava Athlete ID - for local logging):', currentAthleteId); 

            try {
                // Get current Supabase Auth session to pass access token securely
                const { data: { session }, error: sessionError } = await supabaseClientInstance.auth.getSession();
                if (sessionError || !session?.access_token) {
                    showAlert('L·ªói: Kh√¥ng t√¨m th·∫•y phi√™n ƒëƒÉng nh·∫≠p Supabase. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.');
                    dataStatus.textContent = 'L·ªói x√°c th·ª±c: Kh√¥ng t√¨m th·∫•y phi√™n ƒëƒÉng nh·∫≠p.';
                    return;
                }

                const response = await fetch(FETCH_ACTIVITIES_API_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${session.access_token}` // Pass Supabase Auth token
                    },
                    body: JSON.stringify({ 
                        runnerCredentialId: currentRunnerCredentialId, // G·ª≠i ID c·ªßa runner credential
                        limit: activitiesLimit 
                    }),
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    dataStatus.textContent = `ƒê√£ t·∫£i v√† l∆∞u ${result.count} ho·∫°t ƒë·ªông th√†nh c√¥ng!`;
                    showAlert(`ƒê√£ t·∫£i v√† l∆∞u ${result.count} ho·∫°t ƒë·ªông th√†nh c√¥ng!`);
                    // Optionally, reload recent activities and stats after fetching new data
                    await loadRecentActivitiesBtn.click(); 
                    await viewStatsBtn.click();
                } else {
                    dataStatus.textContent = `L·ªói khi t·∫£i ho·∫°t ƒë·ªông: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`;
                    showAlert(`L·ªói khi t·∫£i ho·∫°t ƒë·ªông: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`);
                }
            } catch (error) {
                console.error('L·ªói khi t·∫£i ho·∫°t ƒë·ªông:', error);
                dataStatus.textContent = 'L·ªói m·∫°ng ho·∫∑c m√°y ch·ªß khi t·∫£i ho·∫°t ƒë·ªông.';
                showAlert('L·ªói m·∫°ng ho·∫∑c m√°y ch·ªß khi t·∫£i ho·∫°t ƒë·ªông.');
            }
        });

        /**
         * Loads recent activities from Supabase and displays them.
         */
        loadRecentActivitiesBtn.addEventListener('click', async () => {
            if (!currentAppUserId || !isAuthenticated || !currentRunnerCredentialId || !currentAthleteId) {
                showAlert('Vui l√≤ng ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng v√† k·∫øt n·ªëi v·ªõi Strava tr∆∞·ªõc khi th·ª±c hi·ªán ch·ª©c nƒÉng n√†y.');
                return;
            }

            recentActivitiesStatus.textContent = 'ƒêang t·∫£i ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y ...';
            recentActivitiesList.innerHTML = ''; // Clear previous list

            const activitiesTableUserId = currentAthleteId; // Use Strava Athlete ID for activities table
           
            console.log('Loading recent activities:');
            console.log('  Querying Supabase for activities.user_id (Strava Athlete ID):', activitiesTableUserId);

            const numActivitiesToDisplay = parseInt(numRecentActivitiesInput.value, 10) || 10;
            const selectedTypes = selectedActivityTypesRecent; // Get selected types for filtering
            const startDate = startDateRecent.value;
            const endDate = endDateRecent.value;

            try {
                let query = supabaseClientInstance
                    .from('activities')
                    .select('strava_activity_id, name, type, distance, moving_time, total_elevation_gain, start_date, average_speed, average_heartrate') // Changed activity_id to strava_activity_id
                    .eq('user_id', activitiesTableUserId); // Filter by Strava Athlete ID (t·ª©c l√† user_id trong b·∫£ng activities)

                if (selectedTypes.length > 0) {
                    query = query.in('type', selectedTypes); // Apply type filter
                }
                if (startDate) {
                    query = query.gte('start_date', startDate);
                }
                if (endDate) {
                    query = query.lt('start_date', new Date(new Date(endDate).getTime() + 24 * 60 * 60 * 1000).toISOString().split('T')[0]); // End of selected day
                }

                const { data, error } = await query
                    .order('start_date', { ascending: false })
                    .limit(numActivitiesToDisplay);

                if (error) {
                    console.error('L·ªói khi t·∫£i ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y t·ª´ Supabase:', error);
                    recentActivitiesStatus.textContent = `L·ªói khi t·∫£i ho·∫°t ƒë·ªông: ${error.message}`;
                    showAlert(`L·ªói khi t·∫£i ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y: ${error.message}`);
                    return; 
                }
                
                console.log('Data returned from Supabase for recent activities:', data); // Log the raw data

                if (data && data.length > 0) {
                    const activitiesToDisplay = data; 
                    userActivities = activitiesToDisplay;

                    activitiesToDisplay.forEach(activity => {
                        const li = document.createElement('li');
                        li.className = 'border-b last:border-b-0 py-2';
                        li.innerHTML = `
                            <p class="font-semibold">${activity.name} (${activity.type})</p>
                            <p>Ng√†y: ${new Date(activity.start_date).toLocaleDateString('vi-VN')}</p>
                            <p>Qu√£ng ƒë∆∞·ªùng: ${(activity.distance / 1000).toFixed(2)} km</p>
                            <p>Th·ªùi gian: ${formatDuration(activity.moving_time)}</p>
                            <p>Pace: ${formatPace(activity.average_speed)}</p>
                            <p>Nh·ªãp tim TB: ${activity.average_heartrate ? `${activity.average_heartrate.toFixed(0)} bpm` : 'N/A'}</p>
                            <p>ƒê·ªô cao tƒÉng: ${formatElevationGain(activity.total_elevation_gain)}</p>
                            ${activity.strava_activity_id ? `<button class="btn-secondary mt-2 text-sm view-map-btn" data-activity-id="${activity.strava_activity_id}">Xem b·∫£n ƒë·ªì</button>` : ''} <!-- Changed data-activity-id to use strava_activity_id -->
                        `;
                        recentActivitiesList.appendChild(li);
                    });
                    recentActivitiesStatus.textContent = `ƒê√£ t·∫£i ${activitiesToDisplay.length} ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y.`;

                    // Add event listeners for "Xem b·∫£n ƒë·ªì" buttons
                    document.querySelectorAll('.view-map-btn').forEach(button => {
                        button.onclick = (e) => {
                            const activityId = e.target.dataset.activityId;
                            if (activityId) {
                                window.open(`https://www.strava.com/activities/${activityId}`, '_blank');
                            }
                        };
                    });

                } else {
                    recentActivitiesList.innerHTML = '<li class="text-gray-500">Kh√¥ng t√¨m th·∫•y ho·∫°t ƒë·ªông n√†o g·∫ßn ƒë√¢y cho runner n√†y ho·∫∑c v·ªõi b·ªô l·ªçc ƒë√£ ch·ªçn.</li>';
                    recentActivitiesStatus.textContent = 'Kh√¥ng c√≥ ho·∫°t ƒë·ªông n√†o ƒë·ªÉ hi·ªÉn th·ªã.';
                    userActivities = []; // Clear activities if none found
                }
                renderDetailedStatsTable(); // Re-render detailed stats table after recent activities load
            } catch (error) {
                console.error('L·ªói khi t·∫£i ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y t·ª´ Supabase:', error);
                recentActivitiesStatus.textContent = `L·ªói khi t·∫£i ho·∫°t ƒë·ªông: ${error.message}`;
                showAlert(`L·ªói khi t·∫£i ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y: ${error.message}`);
            }
        });

        /**
         * Fetches activities for a specific week from Supabase and displays them in a modal.
         * @param {string} weekString - The ISO week string (e.g., "YYYY-WW").
         * @param {number} athleteId - The Strava athlete ID associated with the activities.
         */
        async function fetchActivitiesForWeek(weekString, athleteId) {
            weeklyActivitiesStatus.textContent = 'ƒêang t·∫£i ho·∫°t ƒë·ªông cho tu·∫ßn n√†y ...';
            weeklyActivitiesList.innerHTML = ''; // Clear previous list

            // Calculate start and end dates for the given ISO week
            const [yearStr, weekNumStr] = weekString.split('-W');
            const year = parseInt(yearStr);
            const weekNum = parseInt(weekNumStr);

            // Get the first day of the year
            const jan1 = new Date(year, 0, 1);
            // Get the day of the week for Jan 1 (0 for Sunday, 1 for Monday, etc.)
            const dayOfWeekJan1 = jan1.getDay();
            // Calculate the first Thursday of the year (ISO week 1 always contains the first Thursday)
            const firstThursday = new Date(year, 0, 1 + (4 - dayOfWeekJan1 + 7) % 7);

            // Calculate the start date of the target week (Monday of that week)
            const startDate = new Date(firstThursday.getTime() + (weekNum - 1) * 7 * 24 * 60 * 60 * 1000);
            startDate.setDate(startDate.getDate() - (startDate.getDay() + 6) % 7); // Go back to Monday

            // Calculate the end date of the target week (Sunday of that week)
            const endDate = new Date(startDate);
            endDate.setDate(endDate.getDate() + 7); // Go to the beginning of the next week

            const selectedTypes = selectedActivityTypesStats; // Use stats filter for this modal

            try {
                let query = supabaseClientInstance
                    .from('activities')
                    .select('strava_activity_id, name, type, distance, moving_time, total_elevation_gain, start_date, average_speed, average_heartrate') // Changed activity_id to strava_activity_id
                    .eq('user_id', athleteId)
                    .gte('start_date', startDate.toISOString())
                    .lt('start_date', endDate.toISOString());
                
                if (selectedTypes.length > 0) {
                    query = query.in('type', selectedTypes); // Apply type filter
                }

                const { data, error } = await query
                    .order('start_date', { ascending: false });

                if (error) throw error;

                if (data && data.length > 0) {
                    data.forEach(activity => {
                        const li = document.createElement('li');
                        li.className = 'border-b last:border-b-0 py-2';
                        li.innerHTML = `
                            <p class="font-semibold">${activity.name} (${activity.type})</p>
                            <p>Ng√†y: ${new Date(activity.start_date).toLocaleDateString('vi-VN')}</p>
                            <p>Qu√£ng ƒë∆∞·ªùng: ${(activity.distance / 1000).toFixed(2)} km</p>
                            <p>Th·ªùi gian: ${formatDuration(activity.moving_time)}</p>
                            <p>Pace: ${formatPace(activity.average_speed)}</p>
                            <p>Nh·ªãp tim TB: ${activity.average_heartrate ? `${activity.average_heartrate.toFixed(0)} bpm` : 'N/A'}</p>
                            <p>ƒê·ªô cao tƒÉng: ${formatElevationGain(activity.total_elevation_gain)}</p>
                            ${activity.strava_activity_id ? `<button class="btn-secondary mt-2 text-sm view-map-btn-modal" data-activity-id="${activity.strava_activity_id}">Xem b·∫£n ƒë·ªì</button>` : ''} <!-- Changed data-activity-id to use strava_activity_id -->
                        `;
                        weeklyActivitiesList.appendChild(li);
                    });
                    weeklyActivitiesStatus.textContent = `ƒê√£ t·∫£i ${data.length} ho·∫°t ƒë·ªông cho tu·∫ßn ${weekString}.`;

                     // Add event listeners for "Xem b·∫£n ƒë·ªì" buttons in modal
                    document.querySelectorAll('.view-map-btn-modal').forEach(button => {
                        button.onclick = (e) => {
                            const activityId = e.target.dataset.activityId;
                            if (activityId) {
                                window.open(`https://www.strava.com/activities/${activityId}`, '_blank');
                            }
                        };
                    });

                } else {
                    weeklyActivitiesList.innerHTML = '<li class="text-gray-500">Kh√¥ng t√¨m th·∫•y ho·∫°t ƒë·ªông n√†o cho tu·∫ßn n√†y ho·∫∑c v·ªõi b·ªô l·ªçc ƒë√£ ch·ªçn.</li>';
                    weeklyActivitiesStatus.textContent = `Kh√¥ng c√≥ ho·∫°t ƒë·ªông n√†o cho tu·∫ßn ${weekString}.`;
                }
                weeklyActivitiesModal.style.display = 'flex'; // Show modal
            } catch (error) {
                console.error('L·ªói khi t·∫£i ho·∫°t ƒë·ªông theo tu·∫ßn t·ª´ Supabase:', error.message);
                weeklyActivitiesStatus.textContent = `L·ªói: ${error.message}`;
                showAlert(`L·ªói khi t·∫£i ho·∫°t ƒë·ªông theo tu·∫ßn: ${error.message}`);
            }
        }

        // Helper function to get Date from ISO week string (YYYY-WW)
        function getDateFromISOWeek(w) {
            const [year, weekNum] = w.split('-W').map(Number);
            const jan1 = new Date(year, 0, 1);
            const days = (weekNum - 1) * 7;
            const targetDate = new Date(jan1.getFullYear(), 0, jan1.getDate() + days);
            // Adjust to Monday of the ISO week
            targetDate.setDate(targetDate.getDate() - (targetDate.getDay() + 6) % 7);
            return targetDate;
        }


        // Function to draw the bubble chart
        function renderBubbleChart(data) {
            console.log('renderBubbleChart: D·ªØ li·ªáu ƒë·∫ßu v√†o:', data); // Log the input data

            const monthlyDataMap = new Map();

            data.forEach(d => {
                const dateInWeek = getDateFromISOWeek(d.week);
                const monthYear = dateInWeek.getFullYear() + '-' + String(dateInWeek.getMonth() + 1).padStart(2, '0');
                const monthTotalDistance = d.totalDistance; // This will be summed later

                if (!monthlyDataMap.has(monthYear)) {
                    monthlyDataMap.set(monthYear, { month: monthYear, weeks: [], totalMonthlyDistance: 0 });
                }
                monthlyDataMap.get(monthYear).weeks.push(d);
                monthlyDataMap.get(monthYear).totalMonthlyDistance += d.totalDistance;
            });

            const monthlyData = Array.from(monthlyDataMap.values()).sort((a, b) => b.month.localeCompare(a.month)); // Sort months descending

            const container = document.getElementById('bubble-chart-container');
            container.innerHTML = ''; 

            if (!monthlyData || monthlyData.length === 0) {
                container.innerHTML = '<p class="text-gray-500 text-center">Kh√¥ng c√≥ d·ªØ li·ªáu th·ªëng k√™ ƒë·ªÉ hi·ªÉn th·ªã bi·ªÉu ƒë·ªì. Vui l√≤ng t·∫£i d·ªØ li·ªáu t·ª´ Strava ho·∫∑c ch·ªçn b·ªô l·ªçc kh√°c.</p>'; // More specific message
                console.log('renderBubbleChart: Kh√¥ng c√≥ d·ªØ li·ªáu h√†ng th√°ng ƒë·ªÉ v·∫Ω bi·ªÉu ƒë·ªì.');
                return;
            }

            const width = container.clientWidth;
            const monthBandHeight = width < 768 ? 120 : 180;
            const topPaddingForChart = width < 768 ? 70 : 100;

            const totalSvgContentHeight = (monthlyData.length * monthBandHeight) + topPaddingForChart;
            const svgHeight = Math.max(container.clientHeight, totalSvgContentHeight);

            console.log(`renderBubbleChart: K√≠ch th∆∞·ªõc SVG - Width: ${width}, Height: ${svgHeight}`);
            if (width <= 0 || svgHeight <= 0) {
                 console.error('L·ªói renderBubbleChart: K√≠ch th∆∞·ªõc bi·ªÉu ƒë·ªì kh√¥ng h·ª£p l·ªá. Width ho·∫∑c Height <= 0.');
                 container.innerHTML = '<p class="text-red-500">L·ªói: K√≠ch th∆∞·ªõc bi·ªÉu ƒë·ªì kh√¥ng h·ª£p l·ªá. Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c ƒë·∫£m b·∫£o khung ch·ª©a hi·ªÉn th·ªã.</p>';
                 return;
            }


            const svg = d3.select(container)
                .append("svg")
                .attr("width", width)
                .attr("height", svgHeight)
                .attr("viewBox", `0 0 ${width} ${svgHeight}`)
                .attr("preserveAspectRatio", "xMidYMid meet");

            const maxDistance = d3.max(data, d => d.totalDistance);
            const minDistance = d3.min(data, d => d.totalDistance);
            // const maxElevationGain = d3.max(data, d => d.totalElevationGain || 0); // Not used in bubble size/color

            console.log(`renderBubbleChart: Qu√£ng ƒë∆∞·ªùng Min: ${minDistance}, Max: ${maxDistance}`);
            
            const maxRadius = width < 768 ? 30 : 60;
            const minRadius = width < 768 ? 8 : 15;

            const radiusScale = d3.scaleSqrt()
                .domain([0, maxDistance || 1]) // Use 1 as fallback to prevent domain from being [0,0] if maxDistance is 0
                .range([minRadius, maxRadius]);

            const colorScale = d3.scaleSequential(d3.interpolateViridis)
                .domain([maxDistance || 1, minDistance || 0]); // Use 1 as fallback for max, 0 for min


            const bubbleHorizontalPadding = width < 768 ? 10 : 20;
            const bubbleVerticalOffset = monthBandHeight / 2;

            let currentYOffset = topPaddingForChart;

            let tooltip = d3.select("body").select(".tooltip");
            if (tooltip.empty()) {
                tooltip = d3.select("body").append("div")
                    .attr("class", "tooltip");
            }

            monthlyData.forEach((monthObj) => {
                const monthGroup = svg.append("g")
                    .attr("transform", `translate(0, ${currentYOffset})`);

                const monthDisplay = `Th√°ng ${monthObj.month.substring(5)}/${monthObj.month.substring(0, 4)}`;
                const totalMonthlyKm = (monthObj.totalMonthlyDistance / 1000).toFixed(1);

                monthGroup.append("text")
                    .attr("x", 20)
                    .attr("y", 25)
                    .attr("font-size", width < 768 ? "1rem" : "1.2rem")
                    .attr("font-weight", "bold")
                    .attr("fill", "#555")
                    .text(`${monthDisplay} (${totalMonthlyKm}KM)`); // Updated text here

                monthObj.weeks.sort((a, b) => a.week.localeCompare(b.week));

                let currentX = 20;

                const positionedWeeks = monthObj.weeks.map(d => {
                    const r = radiusScale(d.totalDistance);
                    const cx = currentX + r;
                    currentX += (r * 2) + bubbleHorizontalPadding;
                    return { ...d, r, cx, cy: bubbleVerticalOffset + (width < 768 ? 20 : 30) };
                });

                console.log('renderBubbleChart: positionedWeeks cho th√°ng', monthObj.month, ':', positionedWeeks);

                monthGroup.selectAll(".bubble")
                    .data(positionedWeeks)
                    .enter().append("circle")
                    .attr("class", "bubble")
                    .attr("cx", d => d.cx)
                    .attr("cy", d => d.cy)
                    .attr("r", d => d.r)
                    .attr("fill", d => colorScale(d.totalDistance))
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 2)
                    .on("mouseover", function(event, d) {
                        d3.select(this).attr("stroke", "orange").attr("stroke-width", 3);
                        // Calculate average pace for the week
                        const avgPace = d.totalTime && d.totalDistance ? formatPace(d.totalDistance / d.totalTime) : 'N/A';

                        tooltip.style("opacity", 1)
                            .html(`Tu·∫ßn: ${d.week.split('-W')[1]}<br>
                                   Ho·∫°t ƒë·ªông: ${d.activityCount}<br>
                                   Qu√£ng ƒë∆∞·ªùng: ${(d.totalDistance / 1000).toFixed(2)} km<br>
                                   Th·ªùi gian: ${formatDuration(d.totalTime)}<br>
                                   Pace TB: ${avgPace}<br>
                                   ƒê·ªô cao tƒÉng TB: ${d.totalElevationGain ? formatElevationGain(d.totalElevationGain / d.activityCount) : 'N/A'}`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this).attr("stroke", "#fff").attr("stroke-width", 2);
                        tooltip.style("opacity", 0);
                    })
                    .on("click", function(event, d) {
                        // Pass athleteId from current session for fetching specific activities
                        fetchActivitiesForWeek(d.week, currentAthleteId); 
                        weeklyActivitiesTitle.textContent = `Ho·∫°t ƒë·ªông trong tu·∫ßn ${d.week.split('-W')[1]} (${d.week.split('-W')[0]}):`;
                    });

                monthGroup.selectAll(".bubble-text")
                    .data(positionedWeeks)
                    .enter().append("text")
                    .attr("class", "bubble-text")
                    .attr("x", d => d.cx)
                    .attr("y", d => d.cy)
                    .text(d => d.r > (width < 768 ? 15 : 25) ? `${(d.totalDistance / 1000).toFixed(1)}km` : '') // Display KM on bubble
                    .attr("dy", "0.35em")
                    .attr("fill", "white")
                    .attr("pointer-events", "none");

                currentYOffset += monthBandHeight;
            });
        }


        // Function to convert basic Markdown to HTML for LLM analysis
        function markdownToHtml(markdownText) {
            let htmlText = markdownText;
            htmlText = htmlText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            htmlText = htmlText.replace(/\*(.*?)\*/g, '<em>$1</em>');
            htmlText = htmlText.replace(/\n/g, '<br>');
            return htmlText;
        }

        // --- LLM activity analysis feature ---
        analyzeActivitiesBtn.addEventListener('click', async () => {
            if (!currentAppUserId || !isAuthenticated || !currentRunnerCredentialId || !currentAthleteId) {
                showAlert('Vui l√≤ng ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng v√† k·∫øt n·ªëi v·ªõi Strava tr∆∞·ªõc khi th·ª±c hi·ªán ch·ª©c nƒÉng n√†y.');
                return;
            }

            const llmAnalysisSection = document.getElementById('llm-analysis-section');
            const llmAnalysisContent = document.getElementById('llm-analysis-content');
            const llmAnalysisStatus = document.getElementById('llm-analysis-status');

            llmAnalysisSection.classList.remove('hidden');
            llmAnalysisContent.innerHTML = '<p class="text-gray-500">ƒêang ph√¢n t√≠ch ho·∫°t ƒë·ªông c·ªßa b·∫°n... <span class="loader"></span></p>';
            llmAnalysisStatus.textContent = '';

            const activitiesTableUserId = currentAthleteId; 
            const selectedTypes = selectedActivityTypesRecent; // Apply recent activities filter to AI analysis
            const startDate = startDateRecent.value;
            const endDate = endDateRecent.value;

            console.log('Analyzing activities:');
            console.log('  activitiesTableUserId (Strava Athlete ID):', activitiesTableUserId);
            console.log('  Selected Types for AI analysis:', selectedTypes);
            console.log('  Start Date for AI analysis:', startDate);
            console.log('  End Date for AI analysis:', endDate);

            try {
                // Get current Supabase Auth session to pass access token securely
                const { data: { session }, error: sessionError } = await supabaseClientInstance.auth.getSession();
                if (sessionError || !session?.access_token) {
                    showAlert('L·ªói: Kh√¥ng t√¨m th·∫•y phi√™n ƒëƒÉng nh·∫≠p. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.');
                    llmAnalysisContent.innerHTML = '<p class="text-red-500">L·ªói x√°c th·ª±c: Kh√¥ng t√¨m th·∫•y phi√™n ƒëƒÉng nh·∫≠p.</p>';
                    llmAnalysisStatus.textContent = '';
                    return;
                }
                console.log('LLM Analysis: Supabase Session Access Token is available.');

                // Fetch recent activities from Supabase to send to LLM, applying current filters
                let query = supabaseClientInstance
                    .from('activities')
                    .select('*') // Select all columns to get new metrics
                    .eq('user_id', activitiesTableUserId);

                if (selectedTypes.length > 0) {
                    query = query.in('type', selectedTypes);
                }
                if (startDate) {
                    query = query.gte('start_date', startDate);
                }
                if (endDate) {
                    query = query.lt('start_date', new Date(new Date(endDate).getTime() + 24 * 60 * 60 * 1000).toISOString().split('T')[0]);
                }

                const { data: recentActivitiesFromDB, error: fetchError } = await query
                    .order('start_date', { ascending: false })
                    .limit(50); // Limit activities for LLM analysis to avoid large payloads

                if (fetchError) throw fetchError;

                if (!recentActivitiesFromDB || recentActivitiesFromDB.length === 0) {
                    llmAnalysisContent.innerHTML = '<p class="text-gray-500">Kh√¥ng c√≥ ho·∫°t ƒë·ªông n√†o trong c∆° s·ªü d·ªØ li·ªáu ƒë·ªÉ ph√¢n t√≠ch v·ªõi c√°c b·ªô l·ªçc ƒë√£ ch·ªçn. Vui l√≤ng t·∫£i d·ªØ li·ªáu t·ª´ Strava ho·∫∑c ƒëi·ªÅu ch·ªânh b·ªô l·ªçc.</p>';
                    return;
                }

                // Prepare activity data to send to Edge Function, including new metrics
                const activitiesForEdgeFunction = recentActivitiesFromDB.map(activity => ({
                    name: activity.name,
                    distance_km: (activity.distance / 1000).toFixed(2),
                    moving_time_seconds: activity.moving_time,
                    start_date: new Date(activity.start_date).toISOString().split('T')[0],
                    type: activity.type, // Include type
                    average_speed_mps: activity.average_speed, // Include average speed
                    average_heartrate: activity.average_heartrate, // Include average heart rate
                    total_elevation_gain_meters: activity.total_elevation_gain // Include elevation gain
                }));

                llmAnalysisStatus.textContent = 'ƒêang g·ªçi AI ƒë·ªÉ ph√¢n t√≠ch ...';

                // Call the Supabase Edge Function to analyze activities
                const response = await fetch(ANALYZE_ACTIVITIES_FUNCTION_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${session.access_token}` // Pass Supabase Auth token
                    },
                    body: JSON.stringify({
                        activities: activitiesForEdgeFunction, // Send raw activities data with new metrics
                        runnerCredentialId: currentRunnerCredentialId,
                        // Pass filter information to AI for context (optional, depending on LLM prompt)
                        filters: {
                            activityTypes: selectedTypes,
                            startDate: startDate,
                            endDate: endDate
                        }
                    })
                });

                const result = await response.json();

                if (response.ok && result.success) { // Check for success from Edge Function's response
                    const analysisText = result.analysis; // Edge Function should return an 'analysis' field
                    llmAnalysisContent.innerHTML = markdownToHtml(analysisText);
                    llmAnalysisStatus.textContent = 'Ph√¢n t√≠ch ho√†n t·∫•t!';
                } else {
                    console.error('Error from Edge Function:', result.error);
                    llmAnalysisContent.innerHTML = `<p class="text-red-500">Kh√¥ng th·ªÉ nh·∫≠n ƒë∆∞·ª£c ph√¢n t√≠ch t·ª´ AI: ${result.error || 'L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ Edge Function'}</p>`;
                    llmAnalysisStatus.textContent = 'L·ªói ph√¢n t√≠ch AI.';
                }
            }
            catch (error) {
                console.error('Error during LLM analysis:', error);
                llmAnalysisContent.innerHTML = '<p class="text-red-500">ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh ph√¢n t√≠ch AI.</p>';
                llmAnalysisStatus.textContent = `L·ªói: ${error.message}`;
            }
        });

        // Event listener for "Xem th·ªëng k√™ theo tu·∫ßn" button
        viewStatsBtn.addEventListener('click', async () => {
            if (!currentAppUserId || !isAuthenticated || !currentRunnerCredentialId || !currentAthleteId) {
                showAlert('Vui l√≤ng ƒëƒÉng nh·∫≠p ·ª©ng d·ª•ng v√† k·∫øt n·ªëi v·ªõi Strava tr∆∞·ªõc khi xem th·ªëng k√™.');
                return;
            }

            const chartStatus = document.getElementById('chart-status');
            chartStatus.textContent = 'ƒêang t·∫£i th·ªëng k√™ theo tu·∫ßn ...';
            weeklyStatsData = []; // Clear previous data

            try {
                // Get current Supabase Auth session to pass access token securely
                const { data: { session }, error: sessionError } = await supabaseClientInstance.auth.getSession();
                console.log('viewStatsBtn: Supabase session retrieved:', session);
                console.log('viewStatsBtn: Session error:', sessionError);

                // Construct headers object conditionally
                const headers = { 'Content-Type': 'application/json' };
                if (session?.access_token) {
                    headers['Authorization'] = `Bearer ${session.access_token}`;
                    console.log('viewStatsBtn: Adding Authorization header with valid access token.');
                } else {
                    console.warn('viewStatsBtn: No Supabase session access token found. Request will be sent without Authorization header.');
                    showAlert('L·ªói: Kh√¥ng t√¨m th·∫•y phi√™n ƒëƒÉng nh·∫≠p. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i ƒë·ªÉ xem th·ªëng k√™.');
                    chartStatus.textContent = 'L·ªói x√°c th·ª±c: Kh√¥ng t√¨m th·∫•y phi√™n ƒëƒÉng nh·∫≠p.';
                    return; // Exit if no valid session token
                }

                const selectedTypes = selectedActivityTypesStats; // Get selected types for stats filtering
                const startDate = startDateStats.value;
                const endDate = endDateStats.value;
                console.log('viewStatsBtn: Selected activity types for stats:', selectedTypes);
                console.log('viewStatsBtn: Start Date for stats:', startDate);
                console.log('viewStatsBtn: End Date for stats:', endDate);


                const response = await fetch(GET_STATS_API_URL, {
                    method: 'POST',
                    headers: headers, // Use the conditionally built headers object
                    body: JSON.stringify({ 
                        userId: currentRunnerCredentialId, // Pass runnerCredentialId
                        activityTypes: selectedTypes.length > 0 ? selectedTypes : undefined, // Pass selected types, or undefined if none
                        startDate: startDate,
                        endDate: endDate
                    }) 
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    weeklyStatsData = result.weekly_stats; // Store data globally
                    userActivities = result.detailed_activities; // Store detailed activities for the table
                    chartStatus.textContent = `ƒê√£ t·∫£i ${weeklyStatsData.length} tu·∫ßn th·ªëng k√™.`;
                    renderBubbleChart(weeklyStatsData); // Render chart with fetched data
                    renderDetailedStatsTable(); // Render detailed stats table
                } else {
                    chartStatus.textContent = `L·ªói khi t·∫£i th·ªëng k√™: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`;
                    showAlert(`L·ªói khi t·∫£i th·ªëng k√™: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`);
                }
            } catch (error) {
                console.error('L·ªói khi t·∫£i th·ªëng k√™ theo tu·∫ßn:', error);
                chartStatus.textContent = 'L·ªói m·∫°ng ho·∫∑c m√°y ch·ªß khi t·∫£i th·ªëng k√™.';
                showAlert('L·ªói m·∫°ng ho·∫∑c m√°y ch·ªß khi t·∫£i th·ªëng k√™.');
            }
        });

        /**
         * Renders the detailed statistics table based on userActivities.
         */
        function renderDetailedStatsTable() {
            detailedStatsTableBody.innerHTML = '';
            detailedStatsStatus.textContent = '';

            if (!userActivities || userActivities.length === 0) {
                detailedStatsStatus.textContent = 'Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã.';
                return;
            }

            const penaltyPerKm = parseFloat(penaltyPerKmInput.value) || 0;
            const targetKmPerWeek = parseFloat(targetKmPerWeekInput.value) || 0;

            // Group activities by runner
            const activitiesByRunner = userActivities.reduce((acc, activity) => {
                // Find the runner name from allRunnerCredentials using activity.user_id (athlete_id)
                const runner = allRunnerCredentials.find(rc => rc.athlete_id == activity.user_id);
                const runnerName = runner ? runner.runner_name : `Runner ID: ${activity.user_id}`;

                if (!acc[runnerName]) {
                    acc[runnerName] = [];
                }
                acc[runnerName].push(activity);
                return acc;
            }, {});

            // Sort runner names alphabetically
            const sortedRunnerNames = Object.keys(activitiesByRunner).sort();

            sortedRunnerNames.forEach(runnerName => {
                const runnerActivities = activitiesByRunner[runnerName];
                let totalRunnerDistanceKm = 0;
                let totalRunnerTime = 0;

                runnerActivities.forEach(activity => {
                    const distanceKm = (activity.distance / 1000);
                    totalRunnerDistanceKm += distanceKm;
                    totalRunnerTime += activity.moving_time;

                    const row = detailedStatsTableBody.insertRow();
                    row.innerHTML = `
                        <td>${runnerName}</td>
                        <td>${new Date(activity.start_date).toLocaleDateString('vi-VN')}</td>
                        <td>${activity.type}</td>
                        <td>${distanceKm.toFixed(2)}</td>
                        <td>${formatPace(activity.average_speed)}</td>
                        <td>${activity.average_heartrate ? `${activity.average_heartrate.toFixed(0)}` : 'N/A'}</td>
                        <td>${formatElevationGain(activity.total_elevation_gain)}</td>
                        <td>${formatDuration(activity.moving_time)}</td>
                    `;
                });

                // Add total row for the runner
                const totalRow = detailedStatsTableBody.insertRow();
                totalRow.className = 'total-row';
                totalRow.innerHTML = `
                    <td colspan="3">T·ªïng c·ªông cho ${runnerName}:</td>
                    <td>${totalRunnerDistanceKm.toFixed(2)}</td>
                    <td>N/A</td>
                    <td>N/A</td>
                    <td>N/A</td>
                    <td>${formatDuration(totalRunnerTime)}</td>
                `;

                // Calculate missing KM and penalty/bonus
                const missingKm = Math.max(0, targetKmPerWeek - totalRunnerDistanceKm);
                const penaltyAmount = missingKm * penaltyPerKm;

                const missingKmRow = detailedStatsTableBody.insertRow();
                missingKmRow.className = 'missing-row';
                missingKmRow.innerHTML = `
                    <td colspan="3">S·ªë KM thi·∫øu (M·ª•c ti√™u ${targetKmPerWeek}KM):</td>
                    <td colspan="5">${missingKm.toFixed(2)} KM</td>
                `;

                const penaltyRow = detailedStatsTableBody.insertRow();
                penaltyRow.className = 'missing-row';
                penaltyRow.innerHTML = `
                    <td colspan="3">S·ªë ti·ªÅn thi·∫øu (Ph·∫°t ${penaltyPerKm}K/KM):</td>
                    <td colspan="5">${penaltyAmount.toLocaleString('vi-VN')} ngh√¨n VNƒê</td>
                `;

                // Add a spacer row for better readability
                const spacerRow = detailedStatsTableBody.insertRow();
                spacerRow.innerHTML = `<td colspan="8" class="h-4 bg-gray-100"></td>`;
            });
        }


        // When the page loads
        window.onload = async () => {
            if (typeof window.supabase === 'undefined') {
                showAlert('L·ªói: Th∆∞ vi·ªán Supabase kh√¥ng ƒë∆∞·ª£c t·∫£i. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi internet ho·∫∑c URL CDN.');
                console.error('Th∆∞ vi·ªán Supabase kh√¥ng ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a. Vui l√≤ng ki·ªÉm tra th·∫ª script CDN Supabase.');
                return;
            }
            supabaseClientInstance = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            
            console.log('Supabase URL:', SUPABASE_URL);
            console.log('Supabase Anon Key (first 10 chars):', SUPABASE_ANON_KEY.substring(0, 10) + '...');

            // Supabase Auth Listener
            supabaseClientInstance.auth.onAuthStateChange((event, session) => {
                console.log('Supabase Auth state changed:', event, session);
                updateAppAuthUI(session?.user || null);
            });

            // Set up event listeners for app authentication forms
            authForm.addEventListener('submit', handleAuth);
            guestLoginBtn.addEventListener('click', handleGuestLogin);
            signoutBtn.addEventListener('click', handleSignOut);


            // Set up event listeners for credential management
            addCredentialBtn.addEventListener('click', () => openCredentialModal());
            closeModalBtn.addEventListener('click', () => credentialModal.style.display = 'none');
            cancelModalBtn.addEventListener('click', () => credentialModal.style.display = 'none');
            credentialForm.addEventListener('submit', saveCredential);
            
            // Set up event listener for Strava disconnect button
            disconnectStravaBtn.addEventListener('click', () => {
                clearStravaSession();
                checkStravaAuthState();
                showAlert('ƒê√£ ƒëƒÉng xu·∫•t Strava.');
            });

            // Set up event listener for weekly activities modal close button
            closeWeeklyActivitiesModalBtn.addEventListener('click', () => weeklyActivitiesModal.style.display = 'none');

            // Handle initial Strava OAuth callback if any
            await handleStravaCallback(); 
            // The initial UI update will be handled by the onAuthStateChange listener
            // once Supabase session is established.
            // No direct call to displayCredentials() or checkStravaAuthState() here anymore
            // as onAuthStateChange will trigger updateAppAuthUI which calls them.

            // Add resize event listener to redraw the chart
            window.addEventListener('resize', () => {
                if (weeklyStatsData && weeklyStatsData.length > 0) {
                    renderBubbleChart(weeklyStatsData);
                }
            });

            // Initialize activity type filters
            populateActivityTypeFilters();
            updateMultiSelectDisplay(multiSelectDisplayRecent, selectedActivityTypesRecent, multiSelectOptionsRecent);
            updateMultiSelectDisplay(multiSelectDisplayStats, selectedActivityTypesStats, multiSelectOptionsStats);

            // Add event listeners for collapsible headers
            document.querySelectorAll('.collapsible-header').forEach(header => {
                header.addEventListener('click', () => {
                    const targetId = header.dataset.target;
                    const contentElement = document.getElementById(targetId);
                    const toggleIcon = header.querySelector('.toggle-icon');
                    toggleCollapsible(contentElement, toggleIcon);
                });
            });

            // Add event listeners for detailed stats table inputs
            penaltyPerKmInput.addEventListener('input', renderDetailedStatsTable);
            targetKmPerWeekInput.addEventListener('input', renderDetailedStatsTable);

            // Add event listeners for date filters to trigger activity reload
            startDateRecent.addEventListener('change', loadRecentActivitiesBtn.click);
            endDateRecent.addEventListener('change', loadRecentActivitiesBtn.click);
            startDateStats.addEventListener('change', viewStatsBtn.click);
            endDateStats.addEventListener('change', viewStatsBtn.click);

            // Initial collapse instruction section
            toggleCollapsible(instructionContent, instructionSection.querySelector('.toggle-icon'), true);
        };
    </script>
</body>
</html>
